<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Han Joosten" />
  <meta name="date" content="21 februari 2012" />
  <style type="text/css">
/*<![CDATA[*/
/* slidy.css

   Copyright (c) 2005-2010 W3C (MIT, ERCIM, Keio), All Rights Reserved.
   W3C liability, trademark, document use and software licensing
   rules apply, see:

   http://www.w3.org/Consortium/Legal/copyright-documents
   http://www.w3.org/Consortium/Legal/copyright-software
*/
body
{
  margin: 0 0 0 0;
  padding: 0 0 0 0;
  width: 100%;
  height: 100%;
  color: black;
  background-color: white;
  font-family: "Gill Sans MT", "Gill Sans", GillSans, sans-serif;
  font-size: 14pt;
}

div.toolbar {
  position: fixed; z-index: 200;
  top: auto; bottom: 0; left: 0; right: 0;
  height: 1.2em; text-align: right;
  padding-left: 1em;
  padding-right: 1em; 
  font-size: 60%;
  color: red;
  background-color: rgb(240,240,240);
  border-top: solid 1px rgb(180,180,180);
}

div.toolbar span.copyright {
  color: black;
  margin-left: 0.5em;
}

div.initial_prompt {
  position: absolute;
  z-index: 1000;
  bottom: 1.2em;
  width: 100%;
  background-color: rgb(200,200,200);
  opacity: 0.35;
  background-color: rgb(200,200,200, 0.35);
  cursor: pointer;
}

div.initial_prompt p.help {
  text-align: center;
}

div.initial_prompt p.close {
  text-align: right;
  font-style: italic;
}

div.slidy_toc {
  position: absolute;
  z-index: 300;
  width: 60%;
  max-width: 30em;
  height: 30em;
  overflow: auto;
  top: auto;
  right: auto;
  left: 4em;
  bottom: 4em;
  padding: 1em;
  background: rgb(240,240,240);
  border-style: solid;
  border-width: 2px;
  font-size: 60%;
}

div.slidy_toc .toc_heading {
  text-align: center;
  width: 100%;
  margin: 0;
  margin-bottom: 1em;
  border-bottom-style: solid;
  border-bottom-color: rgb(180,180,180);
  border-bottom-width: 1px;
}

div.slide {
  z-index: 20;
  margin: 0 0 0 0;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 20px;
  padding-right: 20px;
  border-width: 0;
  clear: both;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  line-height: 120%;
  background-color: transparent;
}

div.background {
  display: none;
}

div.handout {
  margin-left: 20px;
  margin-right: 20px;
}

div.slide.titlepage {
  text-align: center;
}

div.slide.titlepage h1 {
  padding-top: 10%;
  margin-right: 0;
}

div.slide h1 {
  padding-left: 0;
  padding-right: 20pt;
  padding-top: 4pt;
  padding-bottom: 4pt;
  margin-top: 0;
  margin-left: 0;
  margin-right: 60pt;
  margin-bottom: 0.5em;
  display: block; 
  font-size: 160%;
  line-height: 1.2em;
  background: transparent;
}

div.toc {
  position: absolute;
  top: auto;
  bottom: 4em;
  left: 4em;
  right: auto;
  width: 60%;
  max-width: 30em;
  height: 30em;
  border: solid thin black;
  padding: 1em;
  background: rgb(240,240,240);
  color: black;
  z-index: 300;
  overflow: auto;
  display: block;
  visibility: visible;
}

div.toc-heading {
  width: 100%;
  border-bottom: solid 1px rgb(180,180,180);
  margin-bottom: 1em;
  text-align: center;
}

pre {
 font-size: 80%;
 font-weight: bold;
 line-height: 120%;
 padding-top: 0.2em;
 padding-bottom: 0.2em;
 padding-left: 1em;
 padding-right: 1em;
 border-style: solid;
 border-left-width: 1em;
 border-top-width: thin;
 border-right-width: thin;
 border-bottom-width: thin;
 border-color: #95ABD0;
 color: #00428C;
 background-color: #E4E5E7;
}

li pre { margin-left: 0; }

blockquote { font-style: italic }

img { background-color: transparent }

p.copyright { font-size: smaller }

.center { text-align: center }
.footnote { font-size: smaller; margin-left: 2em; }

a img { border-width: 0; border-style: none }

a:visited { color: navy }
a:link { color: navy }
a:hover { color: red; text-decoration: underline }
a:active { color: red; text-decoration: underline }

a {text-decoration: none}
.navbar a:link {color: white}
.navbar a:visited {color: yellow}
.navbar a:active {color: red}
.navbar a:hover {color: red}

ul { list-style-type: square; }
ul ul { list-style-type: disc; }
ul ul ul { list-style-type: circle; }
ul ul ul ul { list-style-type: disc; }
li { margin-left: 0.5em; margin-top: 0.5em; }
li li { font-size: 85%; font-style: italic }
li li li { font-size: 85%; font-style: normal }

div dt
{
  margin-left: 0;
  margin-top: 1em;
  margin-bottom: 0.5em;
  font-weight: bold;
}
div dd
{
  margin-left: 2em;
  margin-bottom: 0.5em;
}


p,pre,ul,ol,blockquote,h2,h3,h4,h5,h6,dl,table {
  margin-left: 1em;
  margin-right: 1em;
}

p.subhead { font-weight: bold; margin-top: 2em; }

.smaller { font-size: smaller }
.bigger { font-size: 130% }

td,th { padding: 0.2em }

ul {
  margin: 0.5em 1.5em 0.5em 1.5em;
  padding: 0;
}

ol {
  margin: 0.5em 1.5em 0.5em 1.5em;
  padding: 0;
}

ul { list-style-type: square; }
ul ul { list-style-type: disc; }
ul ul ul { list-style-type: circle; }
ul ul ul ul { list-style-type: disc; }

ul li { 
  list-style: square;
  margin: 0.1em 0em 0.6em 0;
  padding: 0 0 0 0;
  line-height: 140%;
}

ol li { 
  margin: 0.1em 0em 0.6em 1.5em;
  padding: 0 0 0 0px;
  line-height: 140%;
  list-style-type: decimal;
}

li ul li { 
  font-size: 85%; 
  font-style: italic;
  list-style-type: disc;
  background: transparent;
  padding: 0 0 0 0;
}
li li ul li { 
  font-size: 85%; 
  font-style: normal;
  list-style-type: circle;
  background: transparent;
  padding: 0 0 0 0;
}
li li li ul li {
  list-style-type: disc;
  background: transparent;
  padding: 0 0 0 0;
}

li ol li {
  list-style-type: decimal;
}


li li ol li {
  list-style-type: decimal;
}

/*
 setting class="outline on ol or ul makes it behave as an
 ouline list where blocklevel content in li elements is
 hidden by default and can be expanded or collapsed with
 mouse click. Set class="expand" on li to override default
*/

ol.outline li:hover { cursor: pointer }
ol.outline li.nofold:hover { cursor: default }

ul.outline li:hover { cursor: pointer }
ul.outline li.nofold:hover { cursor: default }

ol.outline { list-style:decimal; }
ol.outline ol { list-style-type:lower-alpha }

ol.outline li.nofold {
  padding: 0 0 0 20px;
  background: transparent url(../graphics/nofold-dim.gif) no-repeat 0px 0.5em;
}
ol.outline li.unfolded {
  padding: 0 0 0 20px;
  background: transparent url(../graphics/fold-dim.gif) no-repeat 0px 0.5em;
}
ol.outline li.folded {
  padding: 0 0 0 20px;
  background: transparent url(../graphics/unfold-dim.gif) no-repeat 0px 0.5em;
}
ol.outline li.unfolded:hover {
  padding: 0 0 0 20px;
  background: transparent url(../graphics/fold.gif) no-repeat 0px 0.5em;
}
ol.outline li.folded:hover {
  padding: 0 0 0 20px;
  background: transparent url(../graphics/unfold.gif) no-repeat 0px 0.5em;
}

ul.outline li.nofold {
  padding: 0 0 0 20px;
  background: transparent url(../graphics/nofold-dim.gif) no-repeat 0px 0.5em;
}
ul.outline li.unfolded {
  padding: 0 0 0 20px;
  background: transparent url(../graphics/fold-dim.gif) no-repeat 0px 0.5em;
}
ul.outline li.folded {
  padding: 0 0 0 20px;
  background: transparent url(../graphics/unfold-dim.gif) no-repeat 0px 0.5em;
}
ul.outline li.unfolded:hover {
  padding: 0 0 0 20px;
  background: transparent url(../graphics/fold.gif) no-repeat 0px 0.5em;
}
ul.outline li.folded:hover {
  padding: 0 0 0 20px;
  background: transparent url(../graphics/unfold.gif) no-repeat 0px 0.5em;
}

/* for slides with class "title" in table of contents */
a.titleslide { font-weight: bold; font-style: italic }

/*
 hide images for work around for save as bug
 where browsers fail to save images used by CSS
*/
img.hidden { display: none; visibility: hidden }
div.initial_prompt { display: none; visibility: hidden }

  div.slide {
     visibility: visible;
     position: inherit;
  }
  div.handout {
     border-top-style: solid;
     border-top-width: thin;
     border-top-color: black;
  }

@media screen {
  .hidden { display: none; visibility: visible }

  div.slide.hidden { display: block; visibility: visible }
  div.handout.hidden { display: block; visibility: visible }
  div.background { display: none; visibility: hidden }
  body.single_slide div.initial_prompt { display: block; visibility: visible }
  body.single_slide div.background { display: block; visibility: visible }
  body.single_slide div.background.hidden { display: none; visibility: hidden }
  body.single_slide .invisible { visibility: hidden }
  body.single_slide .hidden { display: none; visibility: hidden }
  body.single_slide div.slide { position: absolute }
  body.single_slide div.handout { display: none; visibility: hidden }
}

@media print {
  .hidden { display: block; visibility: visible }

  div.slide pre { font-size: 60%; padding-left: 0.5em; }
  div.toolbar { display: none; visibility: hidden; }
  div.slidy_toc { display: none; visibility: hidden; }
  div.background { display: none; visibility: hidden; }
  div.slide { page-break-before: always }
  /* :first-child isn't reliable for print media */
  div.slide.first-slide { page-break-before: avoid }
}

/*]]>*/
  </style>
<script type="text/javascript" charset="utf-8">
/*<![CDATA[*/
var w3c_slidy={ns_pos:(typeof window.pageYOffset!="undefined"),khtml:((navigator.userAgent).indexOf("KHTML")>=0?true:false),opera:((navigator.userAgent).indexOf("Opera")>=0?true:false),ipad:((navigator.userAgent).indexOf("iPad")>=0?true:false),iphone:((navigator.userAgent).indexOf("iPhone")>=0?true:false),ie:(typeof document.all!="undefined"&&!this.opera),ie6:(!this.ns_pos&&navigator.userAgent.indexOf("MSIE 6")!=-1),ie7:(!this.ns_pos&&navigator.userAgent.indexOf("MSIE 7")!=-1),ie8:(!this.ns_pos&&navigator.userAgent.indexOf("MSIE 8")!=-1),ie9:(!this.ns_pos&&navigator.userAgent.indexOf("MSIE 9")!=-1),keyboardless:(this.ipad||this.iphone),is_xhtml:/xml/.test(document.contentType),slide_number:0,slide_number_element:null,slides:[],notes:[],backgrounds:[],toolbar:null,title:null,last_shown:null,eos:null,toc:null,outline:null,selected_text_len:0,view_all:0,want_toolbar:true,mouse_click_enabled:true,scroll_hack:0,disable_slide_click:false,lang:"en",help_anchor:null,help_page:"http://www.w3.org/Talks/Tools/Slidy2/help/help.html",help_text:"Navigate with mouse click, space bar, Cursor Left/Right, or Pg Up and Pg Dn. Use S and B to change font size.",size_index:0,size_adjustment:0,sizes:new Array("10pt","12pt","14pt","16pt","18pt","20pt","22pt","24pt","26pt","28pt","30pt","32pt"),last_width:0,last_height:0,objects:[],set_up:function(){var a=function(){w3c_slidy.init()};if(typeof window.addEventListener!="undefined"){window.addEventListener("load",a,false)}else{window.attachEvent("onload",a)}},hide_slides:function(){if(document.body&&!w3c_slidy.initialized){document.body.style.visibility="hidden"}else{setTimeout(w3c_slidy.hide_slides,50)}},ie_hack:function(){window.resizeBy(0,-1);window.resizeBy(0,1)},init:function(){document.body.style.visibility="visible";this.init_localization();this.add_toolbar();this.wrap_implicit_slides();this.collect_slides();this.collect_notes();this.collect_backgrounds();this.objects=document.body.getElementsByTagName("object");this.patch_anchors();this.slide_number=this.find_slide_number(location.href);window.offscreenbuffering=true;this.size_adjustment=this.find_size_adjust();this.time_left=this.find_duration();this.hide_image_toolbar();this.init_outliner();this.title=document.title;this.is_xhtml=(document.body.tagName=="BODY"?false:true);if(this.slides.length>0){var a=this.slides[this.slide_number];if(this.slide_number>0){this.set_visibility_all_incremental("visible");this.last_shown=this.previous_incremental_item(null);this.set_eos_status(true)}else{this.last_shown=null;this.set_visibility_all_incremental("hidden");this.set_eos_status(!this.next_incremental_item(this.last_shown))}this.set_location();this.add_class(this.slides[0],"first-slide");w3c_slidy.show_slide(a)}this.toc=this.table_of_contents();this.add_initial_prompt();if(!this.keyboardless){this.add_listener(document.body,"click",this.mouse_button_click)}this.add_listener(document,"keydown",this.key_down);this.add_listener(document,"keypress",this.key_press);this.add_listener(window,"resize",this.resized);this.add_listener(window,"scroll",this.scrolled);this.add_listener(window,"unload",this.unloaded);this.single_slide_view();this.resized();if(this.ie7){setTimeout(w3c_slidy.ie_hack,100)}this.show_toolbar();setInterval(function(){w3c_slidy.check_location()},200);w3c_slidy.initialized=true},table_of_contents:function(){var c=this.create_element("div");this.add_class(c,"slidy_toc hidden");var k=this.create_element("div");this.add_class(k,"toc-heading");k.innerHTML=this.localize("Table of Contents");c.appendChild(k);var f=null;for(var d=0;d<this.slides.length;++d){var g=this.has_class(this.slides[d],"title");var e=document.createTextNode((d+1)+". ");c.appendChild(e);var h=this.create_element("a");h.setAttribute("href","#("+(d+1)+")");if(g){this.add_class(h,"titleslide")}var b=document.createTextNode(this.slide_name(d));h.appendChild(b);h.onclick=w3c_slidy.toc_click;h.onkeydown=w3c_slidy.toc_key_down;h.previous=f;if(f){f.next=h}c.appendChild(h);if(d==0){c.first=h}if(d<this.slides.length-1){var j=this.create_element("br");c.appendChild(j)}f=h}c.focus=function(){if(this.first){this.first.focus()}};c.onmouseup=w3c_slidy.mouse_button_up;c.onclick=function(a){a||(a=window.event);if(w3c_slidy.selected_text_len<=0){w3c_slidy.hide_table_of_contents(true)}w3c_slidy.stop_propagation(a);if(a.cancel!=undefined){a.cancel=true}if(a.returnValue!=undefined){a.returnValue=false}return false};document.body.insertBefore(c,document.body.firstChild);return c},is_shown_toc:function(){return !w3c_slidy.has_class(w3c_slidy.toc,"hidden")},show_table_of_contents:function(){w3c_slidy.remove_class(w3c_slidy.toc,"hidden");var a=w3c_slidy.toc;a.focus();if(w3c_slidy.ie7&&w3c_slidy.slide_number==0){setTimeout(w3c_slidy.ie_hack,100)}},hide_table_of_contents:function(a){w3c_slidy.add_class(w3c_slidy.toc,"hidden");if(a&&!w3c_slidy.opera){w3c_slidy.help_anchor.focus()}},toggle_table_of_contents:function(){if(w3c_slidy.is_shown_toc()){w3c_slidy.hide_table_of_contents(true)}else{w3c_slidy.show_table_of_contents()}},toc_click:function(d){if(!d){d=window.event}var c=w3c_slidy.get_target(d);if(c&&c.nodeType==1){var b=c.getAttribute("href");if(b){var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=w3c_slidy.find_slide_number(b);a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.last_shown=null;w3c_slidy.set_location();w3c_slidy.set_visibility_all_incremental("hidden");w3c_slidy.set_eos_status(!w3c_slidy.next_incremental_item(w3c_slidy.last_shown));w3c_slidy.show_slide(a);try{if(!w3c_slidy.opera){w3c_slidy.help_anchor.focus()}}catch(d){}}}w3c_slidy.hide_table_of_contents(true);if(w3c_slidy.ie7){w3c_slidy.ie_hack()}w3c_slidy.stop_propagation(d);return w3c_slidy.cancel(d)},toc_key_down:function(d){var b;if(!d){var d=window.event}if(window.event){b=window.event.keyCode}else{if(d.which){b=d.which}else{return true}}if(!b){return true}if(d.ctrlKey||d.altKey){return true}if(b==13){var c=this.getAttribute("href");if(c){var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=w3c_slidy.find_slide_number(c);a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.last_shown=null;w3c_slidy.set_location();w3c_slidy.set_visibility_all_incremental("hidden");w3c_slidy.set_eos_status(!w3c_slidy.next_incremental_item(w3c_slidy.last_shown));w3c_slidy.show_slide(a);try{if(!w3c_slidy.opera){w3c_slidy.help_anchor.focus()}}catch(f){}}w3c_slidy.hide_table_of_contents(true);if(self.ie7){w3c_slidy.ie_hack()}return w3c_slidy.cancel(d)}if(b==40&&this.next){this.next.focus();return w3c_slidy.cancel(d)}if(b==38&&this.previous){this.previous.focus();return w3c_slidy.cancel(d)}return true},before_print:function(){this.show_all_slides();this.hide_toolbar();alert("before print")},after_print:function(){if(!this.view_all){this.single_slide_view();this.show_toolbar()}alert("after print")},print_slides:function(){this.before_print();window.print();this.after_print()},toggle_view:function(){if(this.view_all){this.single_slide_view();this.show_toolbar();this.view_all=0}else{this.show_all_slides();this.hide_toolbar();this.view_all=1}},show_all_slides:function(){this.remove_class(document.body,"single_slide");this.set_visibility_all_incremental("visible")},single_slide_view:function(){this.add_class(document.body,"single_slide");this.set_visibility_all_incremental("visible");this.last_shown=this.previous_incremental_item(null)},hide_image_toolbar:function(){if(!this.ns_pos){var a=document.getElementsByTagName("IMG");for(var b=0;b<a.length;++b){a[b].setAttribute("galleryimg","no")}}},unloaded:function(a){},is_KHTML:function(){var a=navigator.userAgent;return(a.indexOf("KHTML")>=0?true:false)},slide_name:function(c){var b=null;var a=this.slides[c];var d=this.find_heading(a);if(d){b=this.extract_text(d)}if(!b){b=this.title+"("+(c+1)+")"}b.replace(/\&/g,"&amp;");b.replace(/\</g,"&lt;");b.replace(/\>/g,"&gt;");return b},find_heading:function(a){if(!a||a.nodeType!=1){return null}if(a.nodeName=="H1"||a.nodeName=="h1"){return a}var b=a.firstChild;while(b){a=this.find_heading(b);if(a){return a}b=b.nextSibling}return null},extract_text:function(a){if(!a){return""}if(a.nodeType==3){return a.nodeValue}if(a.nodeType==1){a=a.firstChild;var b="";while(a){b=b+this.extract_text(a);a=a.nextSibling}return b}return""},find_copyright:function(){var a,c;var d=document.getElementsByTagName("meta");for(var b=0;b<d.length;++b){a=d[b].getAttribute("name");c=d[b].getAttribute("content");if(a=="copyright"){return c}}return null},find_size_adjust:function(){var a,c,e;var d=document.getElementsByTagName("meta");for(var b=0;b<d.length;++b){a=d[b].getAttribute("name");c=d[b].getAttribute("content");if(a=="font-size-adjustment"){return 1*c}}return 1},find_duration:function(){var a,c,e;var d=document.getElementsByTagName("meta");for(var b=0;b<d.length;++b){a=d[b].getAttribute("name");c=d[b].getAttribute("content");if(a=="duration"){return 60000*c}}return null},replace_by_non_breaking_space:function(b){for(var a=0;a<b.length;++a){b[a]=160}},init_outliner:function(){var a=document.getElementsByTagName("li");for(var b=0;b<a.length;++b){var c=a[b];if(!this.has_class(c.parentNode,"outline")){continue}c.onclick=this.outline_click;if(this.foldable(c)){c.foldable=true;c.onfocus=function(){w3c_slidy.outline=this};c.onblur=function(){w3c_slidy.outline=null};if(!c.getAttribute("tabindex")){c.setAttribute("tabindex","0")}if(this.has_class(c,"expand")){this.unfold(c)}else{this.fold(c)}}else{this.add_class(c,"nofold");c.visible=true;c.foldable=false}}},foldable:function(b){if(!b||b.nodeType!=1){return false}var a=b.firstChild;while(a){if(a.nodeType==1&&this.is_block(a)){return true}a=a.nextSibling}return false},fold:function(b){if(b){this.remove_class(b,"unfolded");this.add_class(b,"folded")}var a=b?b.firstChild:null;while(a){if(a.nodeType==1&&this.is_block(a)){w3c_slidy.add_class(a,"hidden")}a=a.nextSibling}b.visible=false},unfold:function(b){if(b){this.add_class(b,"unfolded");this.remove_class(b,"folded")}var a=b?b.firstChild:null;while(a){if(a.nodeType==1&&this.is_block(a)){w3c_slidy.remove_class(a,"hidden")}a=a.nextSibling}b.visible=true},outline_click:function(c){if(!c){c=window.event}var a=false;var b=w3c_slidy.get_target(c);while(b&&b.visible==undefined){b=b.parentNode}if(!b){return true}if(c.which){a=(c.which==3)}else{if(c.button){a=(c.button==2)}}if(!a&&b.visible!=undefined){if(b.foldable){if(b.visible){w3c_slidy.fold(b)}else{w3c_slidy.unfold(b)}}w3c_slidy.stop_propagation(c);c.cancel=true;c.returnValue=false}return false},add_initial_prompt:function(){var a=this.create_element("div");a.setAttribute("class","initial_prompt");var b=this.create_element("p");a.appendChild(b);b.setAttribute("class","help");if(this.keyboardless){b.innerHTML="Tap footer to move to next slide"}else{b.innerHTML="Space or Right Arrow to move to next slide, click help below for more details"}this.add_listener(a,"click",function(c){document.body.removeChild(a);w3c_slidy.stop_propagation(c);if(c.cancel!=undefined){c.cancel=true}if(c.returnValue!=undefined){c.returnValue=false}return false});document.body.appendChild(a);this.initial_prompt=a;setTimeout(function(){document.body.removeChild(a)},5000)},add_toolbar:function(){var a,i;this.toolbar=this.create_element("div");this.toolbar.setAttribute("class","toolbar");if(this.ns_pos||!this.ie6){var k=this.create_element("div");k.setAttribute("style","float: right; text-align: right");a=this.create_element("span");a.innerHTML=this.localize("slide")+" n/m";k.appendChild(a);this.toolbar.appendChild(k);var e=this.create_element("div");e.setAttribute("style","text-align: left");this.eos=this.create_element("span");this.eos.innerHTML="* ";e.appendChild(this.eos);var g=this.create_element("a");g.setAttribute("href",this.help_page);g.setAttribute("title",this.localize(this.help_text));g.innerHTML=this.localize("help?");e.appendChild(g);this.help_anchor=g;var d=document.createTextNode(" ");e.appendChild(d);var f=this.create_element("a");f.setAttribute("href","javascript:w3c_slidy.toggle_table_of_contents()");f.setAttribute("title",this.localize("table of contents"));f.innerHTML=this.localize("contents?");e.appendChild(f);var b=document.createTextNode(" ");e.appendChild(b);var h=this.find_copyright();if(h){var j=this.create_element("span");j.className="copyright";j.innerHTML=h;e.appendChild(j)}this.toolbar.setAttribute("tabindex","0");this.toolbar.appendChild(e)}else{this.toolbar.style.position=(this.ie7?"fixed":"absolute");this.toolbar.style.zIndex="200";this.toolbar.style.width="99.9%";this.toolbar.style.height="1.2em";this.toolbar.style.top="auto";this.toolbar.style.bottom="0";this.toolbar.style.left="0";this.toolbar.style.right="0";this.toolbar.style.textAlign="left";this.toolbar.style.fontSize="60%";this.toolbar.style.color="red";this.toolbar.borderWidth=0;this.toolbar.className="toolbar";this.toolbar.style.background="rgb(240,240,240)";var c=this.create_element("span");c.innerHTML="&nbsp;&nbsp;*&nbsp;";this.toolbar.appendChild(c);this.eos=c;var g=this.create_element("a");g.setAttribute("href",this.help_page);g.setAttribute("title",this.localize(this.help_text));g.innerHTML=this.localize("help?");this.toolbar.appendChild(g);this.help_anchor=g;var d=document.createTextNode(" ");this.toolbar.appendChild(d);var f=this.create_element("a");f.setAttribute("href","javascript:toggleTableOfContents()");f.setAttribute("title",this.localize("table of contents".localize));f.innerHTML=this.localize("contents?");this.toolbar.appendChild(f);var b=document.createTextNode(" ");this.toolbar.appendChild(b);var h=this.find_copyright();if(h){var j=this.create_element("span");j.innerHTML=h;j.style.color="black";j.style.marginLeft="0.5em";this.toolbar.appendChild(j)}a=this.create_element("div");a.style.position="absolute";a.style.width="auto";a.style.height="1.2em";a.style.top="auto";a.style.bottom=0;a.style.right="0";a.style.textAlign="right";a.style.color="red";a.style.background="rgb(240,240,240)";a.innerHTML=this.localize("slide")+" n/m";this.toolbar.appendChild(a)}this.toolbar.onclick=function(m){if(!m){m=window.event}var l=m.target;if(!l&&m.srcElement){l=m.srcElement}if(l&&l.nodeType==3){l=l.parentNode}w3c_slidy.stop_propagation(m);if(l&&l.nodeName.toLowerCase()!="a"){w3c_slidy.mouse_button_click(m)}};this.slide_number_element=a;this.set_eos_status(false);document.body.appendChild(this.toolbar)},wrap_implicit_slides:function(){var a,d,c,b,f;var e=document.getElementsByTagName("h1");if(!e){return}for(a=0;a<e.length;++a){d=e[a];if(d.parentNode!=document.body){continue}c=d.nextSibling;f=document.createElement("div");this.add_class(f,"slide");document.body.replaceChild(f,d);f.appendChild(d);while(c){if(c.nodeType==1&&(c.nodeName=="H1"||c.nodeName=="h1"||c.nodeName=="DIV"||c.nodeName=="div")){break}b=c.nextSibling;c=document.body.removeChild(c);f.appendChild(c);c=b}}},collect_slides:function(){var e=new Array();var d=document.body.getElementsByTagName("div");for(var c=0;c<d.length;++c){div=d.item(c);if(this.has_class(div,"slide")){e[e.length]=div;this.add_class(div,"hidden");var b=document.createElement("br");div.appendChild(b);var a=document.createElement("br");div.appendChild(a)}else{if(this.has_class(div,"background")){div.style.display="block"}}}this.slides=e},collect_notes:function(){var b=new Array();var c=document.body.getElementsByTagName("div");for(var a=0;a<c.length;++a){div=c.item(a);if(this.has_class(div,"handout")){b[b.length]=div;this.add_class(div,"hidden")}}this.notes=b},collect_backgrounds:function(){var c=new Array();var b=document.body.getElementsByTagName("div");for(var a=0;a<b.length;++a){div=b.item(a);if(this.has_class(div,"background")){c[c.length]=div;this.add_class(div,"hidden")}}this.backgrounds=c},patch_anchors:function(){var a=w3c_slidy;var c=function(g){if(a.page_address(this.href)==a.page_address(location.href)){var f=a.find_slide_number(this.href);if(f!=a.slide_number){var e=a.slides[a.slide_number];a.hide_slide(e);a.slide_number=f;e=a.slides[a.slide_number];a.show_slide(e);a.set_location()}}else{w3c_slidy.stop_propagation(g)}this.blur();a.disable_slide_click=true};var d=document.body.getElementsByTagName("a");for(var b=0;b<d.length;++b){if(window.addEventListener){d[b].addEventListener("click",c,false)}else{d[b].attachEvent("onclick",c)}}},show_slide_number:function(){var a=w3c_slidy.get_timer();w3c_slidy.slide_number_element.innerHTML=a+w3c_slidy.localize("slide")+" "+(w3c_slidy.slide_number+1)+"/"+w3c_slidy.slides.length},check_location:function(){var b=location.hash;if(w3c_slidy.slide_number>0&&(b==""||b=="#")){w3c_slidy.goto_slide(0)}else{if(b.length>2&&b!="#("+(w3c_slidy.slide_number+1)+")"){var a=parseInt(location.hash.substr(2));if(!isNaN(a)){w3c_slidy.goto_slide(a-1)}}}if(w3c_slidy.time_left&&w3c_slidy.slide_number>0){w3c_slidy.show_slide_number();if(w3c_slidy.time_left>0){w3c_slidy.time_left-=200}}},get_timer:function(){var c="";if(w3c_slidy.time_left){var b,a;a=Math.floor(w3c_slidy.time_left/1000);b=Math.floor(a/60);a=a%60;c=(b?b+"m":"")+a+"s "}return c},set_location:function(){var a=w3c_slidy.page_address(location.href);var b="#("+(w3c_slidy.slide_number+1)+")";if(w3c_slidy.slide_number>=0){a=a+b}if(w3c_slidy.ie&&(w3c_slidy.ie6||w3c_slidy.ie7)){w3c_slidy.push_hash(b)}if(a!=location.href){location.href=a}if(this.khtml){b="("+(w3c_slidy.slide_number+1)+")"}if(!this.ie&&location.hash!=b&&location.hash!=""){location.hash=b}document.title=w3c_slidy.title+" ("+(w3c_slidy.slide_number+1)+")";w3c_slidy.show_slide_number()},page_address:function(b){var a=b.indexOf("#");if(a<0){a=b.indexOf("%23")}if(a<0){return b}return b.substr(0,a)},on_frame_loaded:function(b){location.hash=b;var a=w3c_slidy.page_address(location.href);location.href=a+b},push_hash:function(b){if(b==""){b="#(1)"}window.location.hash=b;var a=document.getElementById("historyFrame").contentWindow.document;a.open("javascript:'<html></html>'");a.write('<html><head><script type="text/javascript">window.parent.w3c_slidy.on_frame_loaded(\''+(b)+"');\74/script></head><body>hello mum</body></html>");a.close()},find_slide_number:function(e){var c=e.indexOf("#");if(c<0){return 0}var b=unescape(e.substr(c+1));var f=document.getElementById(b);if(!f){var d=/\((\d)+\)/;if(b.match(d)){var a=parseInt(b.substring(1,b.length-1));if(a>this.slides.length){a=1}if(--a<0){a=0}return a}d=/\[(\d)+\]/;if(b.match(d)){var a=parseInt(b.substring(1,b.length-1));if(a>this.slides.length){a=1}if(--a<0){a=0}return a}return 0}while(true){if(f.nodeName.toLowerCase()=="div"&&this.has_class(f,"slide")){break}f=f.parentNode;if(!f){return 0}}for(c=0;c<slides.length;++c){if(slides[c]==f){return c}}return 0},previous_slide:function(b){if(!w3c_slidy.view_all){var a;if((b||w3c_slidy.slide_number==0)&&w3c_slidy.last_shown!=null){w3c_slidy.last_shown=w3c_slidy.hide_previous_item(w3c_slidy.last_shown);w3c_slidy.set_eos_status(false)}else{if(w3c_slidy.slide_number>0){a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=w3c_slidy.slide_number-1;a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.set_visibility_all_incremental("visible");w3c_slidy.last_shown=w3c_slidy.previous_incremental_item(null);w3c_slidy.set_eos_status(true);w3c_slidy.show_slide(a)}}w3c_slidy.set_location();if(!w3c_slidy.ns_pos){w3c_slidy.refresh_toolbar(200)}}},next_slide:function(c){if(!w3c_slidy.view_all){var a,b=w3c_slidy.last_shown;if(c||w3c_slidy.slide_number==w3c_slidy.slides.length-1){w3c_slidy.last_shown=w3c_slidy.reveal_next_item(w3c_slidy.last_shown)}if((!c||w3c_slidy.last_shown==null)&&w3c_slidy.slide_number<w3c_slidy.slides.length-1){a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=w3c_slidy.slide_number+1;a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.last_shown=null;w3c_slidy.set_visibility_all_incremental("hidden");w3c_slidy.show_slide(a)}else{if(!w3c_slidy.last_shown){if(b&&c){w3c_slidy.last_shown=b}}}w3c_slidy.set_location();w3c_slidy.set_eos_status(!w3c_slidy.next_incremental_item(w3c_slidy.last_shown));if(!w3c_slidy.ns_pos){w3c_slidy.refresh_toolbar(200)}}},first_slide:function(){if(!w3c_slidy.view_all){var a;if(w3c_slidy.slide_number!=0){a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=0;a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.last_shown=null;w3c_slidy.set_visibility_all_incremental("hidden");w3c_slidy.show_slide(a)}w3c_slidy.set_eos_status(!w3c_slidy.next_incremental_item(w3c_slidy.last_shown));w3c_slidy.set_location()}},last_slide:function(){if(!w3c_slidy.view_all){var a;w3c_slidy.last_shown=null;if(w3c_slidy.last_shown==null&&w3c_slidy.slide_number<w3c_slidy.slides.length-1){a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=w3c_slidy.slides.length-1;a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.set_visibility_all_incremental("visible");w3c_slidy.last_shown=w3c_slidy.previous_incremental_item(null);w3c_slidy.show_slide(a)}else{w3c_slidy.set_visibility_all_incremental("visible");w3c_slidy.last_shown=w3c_slidy.previous_incremental_item(null)}w3c_slidy.set_eos_status(true);w3c_slidy.set_location()}},set_eos_status:function(a){if(this.eos){this.eos.style.color=(a?"rgb(240,240,240)":"red")}},goto_slide:function(b){var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=b;a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.last_shown=null;w3c_slidy.set_visibility_all_incremental("hidden");w3c_slidy.set_eos_status(!w3c_slidy.next_incremental_item(w3c_slidy.last_shown));document.title=w3c_slidy.title+" ("+(w3c_slidy.slide_number+1)+")";w3c_slidy.show_slide(a);w3c_slidy.show_slide_number()},show_slide:function(a){this.sync_background(a);window.scrollTo(0,0);this.remove_class(a,"hidden")},hide_slide:function(a){this.add_class(a,"hidden")},sync_background:function(a){var e;var g;if(a.currentStyle){g=a.currentStyle.backgroundColor}else{if(document.defaultView){var f=document.defaultView.getComputedStyle(a,null);if(f){g=f.getPropertyValue("background-color")}else{g="transparent"}}else{g=="transparent"}}if(g=="transparent"||g.indexOf("rgba")>=0||g.indexOf("opacity")>=0){var c=this.get_class_list(a);for(var d=0;d<this.backgrounds.length;d++){e=this.backgrounds[d];var b=this.get_class_list(e);if(this.matching_background(c,b)){this.remove_class(e,"hidden")}else{this.add_class(e,"hidden")}}}else{this.hide_backgrounds()}},hide_backgrounds:function(){for(var a=0;a<this.backgrounds.length;a++){background=this.backgrounds[a];this.add_class(background,"hidden")}},matching_background:function(c,b){var d,e,f,a;f=/\w+/g;a=b.match(f);for(d=e=0;d<a.length;d++){if(a[d]=="hidden"){continue}if(a[d]=="background"){continue}++e}if(e==0){return true}a=c.match(f);for(d=e=0;d<a.length;d++){if(a[d]=="hidden"){continue}if(this.has_token(b,a[d])){return true}}return false},resized:function(){var c=0;if(typeof(window.innerWidth)=="number"){c=window.innerWidth}else{if(document.documentElement&&document.documentElement.clientWidth){c=document.documentElement.clientWidth}else{if(document.body&&document.body.clientWidth){c=document.body.clientWidth}}}var b=0;if(typeof(window.innerHeight)=="number"){b=window.innerHeight}else{if(document.documentElement&&document.documentElement.clientHeight){b=document.documentElement.clientHeight}else{if(document.body&&document.body.clientHeight){b=document.body.clientHeight}}}if(b&&(c/b>1.05*1024/768)){c=b*1024/768}if(c!=w3c_slidy.last_width||b!=w3c_slidy.last_height){if(c>=1100){w3c_slidy.size_index=5}else{if(c>=1000){w3c_slidy.size_index=4}else{if(c>=800){w3c_slidy.size_index=3}else{if(c>=600){w3c_slidy.size_index=2}else{if(c){w3c_slidy.size_index=0}}}}}if(0<=w3c_slidy.size_index+w3c_slidy.size_adjustment&&w3c_slidy.size_index+w3c_slidy.size_adjustment<w3c_slidy.sizes.length){w3c_slidy.size_index=w3c_slidy.size_index+w3c_slidy.size_adjustment}w3c_slidy.adjust_object_dimensions(c,b);if(document.body.style.fontSize!=w3c_slidy.sizes[w3c_slidy.size_index]){document.body.style.fontSize=w3c_slidy.sizes[w3c_slidy.size_index]}w3c_slidy.last_width=c;w3c_slidy.last_height=b;if(w3c_slidy.ns_pos){var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.show_slide(a)}w3c_slidy.refresh_toolbar(200)}},scrolled:function(){if(w3c_slidy.toolbar&&!w3c_slidy.ns_pos&&!w3c_slidy.ie7){w3c_slidy.hack_offset=w3c_slidy.scroll_x_offset();w3c_slidy.toolbar.style.display="none";if(w3c_slidy.scrollhack==0&&!w3c_slidy.view_all){setTimeout(function(){w3c_slidy.show_toolbar()},1000);w3c_slidy.scrollhack=1}}},hide_toolbar:function(){w3c_slidy.add_class(w3c_slidy.toolbar,"hidden");window.focus()},refresh_toolbar:function(a){if(!w3c_slidy.ns_pos&&!w3c_slidy.ie7){w3c_slidy.hide_toolbar();setTimeout(function(){w3c_slidy.show_toolbar()},a)}},show_toolbar:function(){if(w3c_slidy.want_toolbar){w3c_slidy.toolbar.style.display="block";if(!w3c_slidy.ns_pos){var b=w3c_slidy.scroll_x_offset();w3c_slidy.toolbar.style.left=b;w3c_slidy.toolbar.style.right=b;w3c_slidy.toolbar.style.bottom=0}w3c_slidy.remove_class(w3c_slidy.toolbar,"hidden")}w3c_slidy.scrollhack=0;try{if(!w3c_slidy.opera){w3c_slidy.help_anchor.focus()}}catch(a){}},toggle_toolbar:function(){if(!w3c_slidy.view_all){if(w3c_slidy.has_class(w3c_slidy.toolbar,"hidden")){w3c_slidy.remove_class(w3c_slidy.toolbar,"hidden");w3c_slidy.want_toolbar=1}else{w3c_slidy.add_class(w3c_slidy.toolbar,"hidden");w3c_slidy.want_toolbar=0}}},scroll_x_offset:function(){if(window.pageXOffset){return self.pageXOffset}if(document.documentElement&&document.documentElement.scrollLeft){return document.documentElement.scrollLeft}if(document.body){return document.body.scrollLeft}return 0},scroll_y_offset:function(){if(window.pageYOffset){return self.pageYOffset}if(document.documentElement&&document.documentElement.scrollTop){return document.documentElement.scrollTop}if(document.body){return document.body.scrollTop}return 0},optimize_font_size:function(){var a=w3c_slidy.slides[w3c_slidy.slide_number];var d=a.scrollHeight;var b=getWindowHeight();var c=100*d/b;alert("window utilization = "+c+"% (doc "+d+" win "+b+")")},get_doc_height:function(a){if(!a){a=document}if(a&&a.body&&a.body.offsetHeight){return a.body.offsetHeight}if(a&&a.body&&a.body.scrollHeight){return a.body.scrollHeight}alert("couldn't determine document height")},get_window_height:function(){if(typeof(window.innerHeight)=="number"){return window.innerHeight}if(document.documentElement&&document.documentElement.clientHeight){return document.documentElement.clientHeight}if(document.body&&document.body.clientHeight){return document.body.clientHeight}},document_height:function(){var a,b;a=document.body.scrollHeight;b=document.body.offsetHeight;if(a&&b){return(a>b?a:b)}return 0},smaller:function(){if(w3c_slidy.size_index>0){--w3c_slidy.size_index}w3c_slidy.toolbar.style.display="none";document.body.style.fontSize=w3c_slidy.sizes[w3c_slidy.size_index];var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.show_slide(a);setTimeout(function(){w3c_slidy.show_toolbar()},50)},bigger:function(){if(w3c_slidy.size_index<w3c_slidy.sizes.length-1){++w3c_slidy.size_index}w3c_slidy.toolbar.style.display="none";document.body.style.fontSize=w3c_slidy.sizes[w3c_slidy.size_index];var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.show_slide(a);setTimeout(function(){w3c_slidy.show_toolbar()},50)},adjust_object_dimensions:function(c,k){for(var e=0;e<w3c_slidy.objects.length;e++){var d=this.objects[e];var b=d.getAttribute("type");if(b=="image/svg+xml"||b=="application/x-shockwave-flash"){if(!d.initialWidth){d.initialWidth=d.getAttribute("width")}if(!d.initialHeight){d.initialHeight=d.getAttribute("height")}if(d.initialWidth&&d.initialWidth.charAt(d.initialWidth.length-1)=="%"){var j=parseInt(d.initialWidth.slice(0,d.initialWidth.length-1));var a=c*(j/100);d.setAttribute("width",a)}if(d.initialHeight&&d.initialHeight.charAt(d.initialHeight.length-1)=="%"){var f=parseInt(d.initialHeight.slice(0,d.initialHeight.length-1));var g=k*(f/100);d.setAttribute("height",g)}}}},key_press:function(a){if(!a){a=window.event}if(!w3c_slidy.key_wanted){return w3c_slidy.cancel(a)}return true},key_down:function(d){var c,e,a;w3c_slidy.key_wanted=true;if(!d){d=window.event}if(window.event){c=window.event.keyCode;e=window.event.srcElement}else{if(d.which){c=d.which;e=d.target}else{return true}}if(!c){return true}if(!w3c_slidy.slidy_chrome(e)&&w3c_slidy.special_element(e)){return true}if(d.ctrlKey||d.altKey||d.metaKey){return true}if(w3c_slidy.is_shown_toc()&&c!=9&&c!=16&&c!=38&&c!=40){w3c_slidy.hide_table_of_contents(true);if(c==27||c==84||c==67){return w3c_slidy.cancel(d)}}if(c==34){if(w3c_slidy.view_all){return true}w3c_slidy.next_slide(false);return w3c_slidy.cancel(d)}else{if(c==33){if(w3c_slidy.view_all){return true}w3c_slidy.previous_slide(false);return w3c_slidy.cancel(d)}else{if(c==32){w3c_slidy.next_slide(true);return w3c_slidy.cancel(d)}else{if(c==37){w3c_slidy.previous_slide(!d.shiftKey);return w3c_slidy.cancel(d)}else{if(c==36){w3c_slidy.first_slide();return w3c_slidy.cancel(d)}else{if(c==35){w3c_slidy.last_slide();return w3c_slidy.cancel(d)}else{if(c==39){w3c_slidy.next_slide(!d.shiftKey);return w3c_slidy.cancel(d)}else{if(c==13){if(w3c_slidy.outline){if(w3c_slidy.outline.visible){w3c_slidy.fold(w3c_slidy.outline)}else{w3c_slidy.unfold(w3c_slidy.outline)}return w3c_slidy.cancel(d)}}else{if(c==188){w3c_slidy.smaller();return w3c_slidy.cancel(d)}else{if(c==190){w3c_slidy.bigger();return w3c_slidy.cancel(d)}else{if(c==189||c==109){w3c_slidy.smaller();return w3c_slidy.cancel(d)}else{if(c==187||c==191||c==107){w3c_slidy.bigger();return w3c_slidy.cancel(d)}else{if(c==83){w3c_slidy.smaller();return w3c_slidy.cancel(d)}else{if(c==66){w3c_slidy.bigger();return w3c_slidy.cancel(d)}else{if(c==90){w3c_slidy.last_slide();return w3c_slidy.cancel(d)}else{if(c==70){w3c_slidy.toggle_toolbar();return w3c_slidy.cancel(d)}else{if(c==65){w3c_slidy.toggle_view();return w3c_slidy.cancel(d)}else{if(c==75){w3c_slidy.mouse_click_enabled=!w3c_slidy.mouse_click_enabled;var b=(w3c_slidy.mouse_click_enabled?"enabled":"disabled")+" mouse click advance";alert(w3c_slidy.localize(b));return w3c_slidy.cancel(d)}else{if(c==84||c==67){if(w3c_slidy.toc){w3c_slidy.toggle_table_of_contents()}return w3c_slidy.cancel(d)}else{if(c==72){window.location=w3c_slidy.help_page;return w3c_slidy.cancel(d)}}}}}}}}}}}}}}}}}}}}return true},create_element:function(a){if(this.xhtml&&(typeof document.createElementNS!="undefined")){return document.createElementNS("http://www.w3.org/1999/xhtml",a)}return document.createElement(a)},get_element_style:function(d,b,c){if(d.currentStyle){return d.currentStyle[b]}else{if(window.getComputedStyle){var a=window.getComputedStyle(d,"");return a.getPropertyValue(c)}}return""},has_token:function(e,c){if(e){var d=/\w+/g;var a=e.match(d);for(var b=0;b<a.length;b++){if(a[b]==c){return true}}}return false},get_class_list:function(a){if(typeof a.className!="undefined"){return a.className}return a.getAttribute("class")},has_class:function(b,a){if(b.nodeType!=1){return false}var c=new RegExp("(^| )"+a+"W*");if(typeof b.className!="undefined"){return c.test(b.className)}return c.test(b.getAttribute("class"))},remove_class:function(b,a){var d=new RegExp("(^| )"+a+"W*");var c="";if(typeof b.className!="undefined"){c=b.className;if(c){c=c.replace(d,"");b.className=c}}else{c=b.getAttribute("class");if(c){c=c.replace(d,"");b.setAttribute("class",c)}}},add_class:function(b,a){if(!this.has_class(b,a)){if(typeof b.className!="undefined"){b.className+=" "+a}else{var c=b.getAttribute("class");c=c?c+" "+a:a;b.setAttribute("class",c)}}},incremental_elements:null,okay_for_incremental:function(a){if(!this.incremental_elements){var b=new Array();b.p=true;b.pre=true;b.li=true;b.blockquote=true;b.dt=true;b.dd=true;b.h2=true;b.h3=true;b.h4=true;b.h5=true;b.h6=true;b.span=true;b.address=true;b.table=true;b.tr=true;b.th=true;b.td=true;b.img=true;b.object=true;this.incremental_elements=b}return this.incremental_elements[a.toLowerCase()]},next_incremental_item:function(c){var b=this.is_xhtml?"br":"BR";var a=w3c_slidy.slides[w3c_slidy.slide_number];for(;;){c=w3c_slidy.next_node(a,c);if(c==null||c.parentNode==null){break}if(c.nodeType==1){if(c.nodeName==b){continue}if(w3c_slidy.has_class(c,"incremental")&&w3c_slidy.okay_for_incremental(c.nodeName)){return c}if(w3c_slidy.has_class(c.parentNode,"incremental")&&!w3c_slidy.has_class(c,"non-incremental")){return c}}}return c},previous_incremental_item:function(c){var b=this.is_xhtml?"br":"BR";var a=w3c_slidy.slides[w3c_slidy.slide_number];for(;;){c=w3c_slidy.previous_node(a,c);if(c==null||c.parentNode==null){break}if(c.nodeType==1){if(c.nodeName==b){continue}if(w3c_slidy.has_class(c,"incremental")&&w3c_slidy.okay_for_incremental(c.nodeName)){return c}if(w3c_slidy.has_class(c.parentNode,"incremental")&&!w3c_slidy.has_class(c,"non-incremental")){return c}}}return c},set_visibility_all_incremental:function(b){var a=this.next_incremental_item(null);if(b=="hidden"){while(a){w3c_slidy.add_class(a,"invisible");a=w3c_slidy.next_incremental_item(a)}}else{while(a){w3c_slidy.remove_class(a,"invisible");a=w3c_slidy.next_incremental_item(a)}}},reveal_next_item:function(a){a=w3c_slidy.next_incremental_item(a);if(a&&a.nodeType==1){w3c_slidy.remove_class(a,"invisible")}return a},hide_previous_item:function(a){if(a&&a.nodeType==1){w3c_slidy.add_class(a,"invisible")}return this.previous_incremental_item(a)},next_node:function(a,b){if(b==null){return a.firstChild}if(b.firstChild){return b.firstChild}if(b.nextSibling){return b.nextSibling}for(;;){b=b.parentNode;if(!b||b==a){break}if(b&&b.nextSibling){return b.nextSibling}}return null},previous_node:function(a,b){if(b==null){b=a.lastChild;if(b){while(b.lastChild){b=b.lastChild}}return b}if(b.previousSibling){b=b.previousSibling;while(b.lastChild){b=b.lastChild}return b}if(b.parentNode!=a){return b.parentNode}return null},previous_sibling_element:function(a){a=a.previousSibling;while(a&&a.nodeType!=1){a=a.previousSibling}return a},next_sibling_element:function(a){a=a.nextSibling;while(a&&a.nodeType!=1){a=a.nextSibling}return a},first_child_element:function(a){var b;for(b=a.firstChild;b;b=b.nextSibling){if(b.nodeType==1){break}}return b},first_tag:function(b,a){var c;if(!this.is_xhtml){a=a.toUpperCase()}for(c=b.firstChild;c;c=c.nextSibling){if(c.nodeType==1&&c.nodeName==a){break}}return c},hide_selection:function(){if(window.getSelection){var b=window.getSelection();if(b.rangeCount>0){var a=b.getRangeAt(0);a.collapse(false)}}else{var c=document.selection.createRange();c.collapse(false)}},get_selected_text:function(){try{if(window.getSelection){return window.getSelection().toString()}if(document.getSelection){return document.getSelection().toString()}if(document.selection){return document.selection.createRange().text}}catch(a){}return""},mouse_button_up:function(a){w3c_slidy.selected_text_len=w3c_slidy.get_selected_text().length},mouse_button_click:function(g){var c=false;var b=false;var d=false;var f;if(!g){var g=window.event}if(g.target){f=g.target}else{if(g.srcElement){f=g.srcElement}}if(f.nodeType==3){f=f.parentNode}if(g.which){b=(g.which==1);d=(g.which==2);c=(g.which==3)}else{if(g.button){if(g.button==4){d=true}c=(g.button==2)}else{b=true}}if(w3c_slidy.selected_text_len>0){w3c_slidy.stop_propagation(g);g.cancel=true;g.returnValue=false;return false}w3c_slidy.hide_table_of_contents(false);var a=f.nodeName.toLowerCase();if(w3c_slidy.mouse_click_enabled&&b&&!w3c_slidy.special_element(f)&&!f.onclick){w3c_slidy.next_slide(true);w3c_slidy.stop_propagation(g);g.cancel=true;g.returnValue=false;return false}return true},special_element:function(b){var a=b.nodeName.toLowerCase();return b.onkeydown||b.onclick||a=="a"||a=="embed"||a=="object"||a=="video"||a=="audio"||a=="input"||a=="textarea"||a=="select"||a=="option"},slidy_chrome:function(a){while(a){if(a==w3c_slidy.toc||a==w3c_slidy.toolbar||w3c_slidy.has_class(a,"outline")){return true}a=a.parentNode}return false},get_key:function(b){var a;if(typeof window.event!="undefined"){a=window.event.keyCode}else{if(b.which){a=b.which}}return a},get_target:function(b){var a;if(!b){b=window.event}if(b.target){a=b.target}else{if(b.srcElement){a=b.srcElement}}if(a.nodeType!=1){a=a.parentNode}return a},is_block:function(b){var a=b.nodeName.toLowerCase();return a=="ol"||a=="ul"||a=="p"||a=="li"||a=="table"||a=="pre"||a=="h1"||a=="h2"||a=="h3"||a=="h4"||a=="h5"||a=="h6"||a=="blockquote"||a=="address"},add_listener:function(a,c,b){if(window.addEventListener){a.addEventListener(c,b,false)}else{a.attachEvent("on"+c,b)}},stop_propagation:function(a){a=a?a:window.event;a.cancelBubble=true;if(a.stopPropagation){a.stopPropagation()}return true},cancel:function(a){if(a){a.cancel=true;a.returnValue=false;if(a.preventDefault){a.preventDefault()}}w3c_slidy.key_wanted=false;return false},strings_es:{slide:"pág.","help?":"Ayuda","contents?":"Índice","table of contents":"tabla de contenidos","Table of Contents":"Tabla de Contenidos","restart presentation":"Reiniciar presentación","restart?":"Inicio"},help_es:"Utilice el ratón, barra espaciadora, teclas Izda/Dcha, o Re pág y Av pág. Use S y B para cambiar el tamaño de fuente.",strings_ca:{slide:"pàg..","help?":"Ajuda","contents?":"Índex","table of contents":"taula de continguts","Table of Contents":"Taula de Continguts","restart presentation":"Reiniciar presentació","restart?":"Inici"},help_ca:"Utilitzi el ratolí, barra espaiadora, tecles Esq./Dta. o Re pàg y Av pàg. Usi S i B per canviar grandària de font.",strings_cs:{slide:"snímek","help?":"nápověda","contents?":"obsah","table of contents":"obsah prezentace","Table of Contents":"Obsah prezentace","restart presentation":"znovu spustit prezentaci","restart?":"restart"},help_cs:"Prezentaci můžete procházet pomocí kliknutí myši, mezerníku, šipek vlevo a vpravo nebo kláves PageUp a PageDown. Písmo se dá zvětšit a zmenšit pomocí kláves B a S.",strings_nl:{slide:"pagina","help?":"Help?","contents?":"Inhoud?","table of contents":"inhoudsopgave","Table of Contents":"Inhoudsopgave","restart presentation":"herstart presentatie","restart?":"Herstart?"},help_nl:"Navigeer d.m.v. het muis, spatiebar, Links/Rechts toetsen, of PgUp en PgDn. Gebruik S en B om de karaktergrootte te veranderen.",strings_de:{slide:"Seite","help?":"Hilfe","contents?":"Übersicht","table of contents":"Inhaltsverzeichnis","Table of Contents":"Inhaltsverzeichnis","restart presentation":"Präsentation neu starten","restart?":"Neustart"},help_de:"Benutzen Sie die Maus, Leerschlag, die Cursortasten links/rechts oder Page up/Page Down zum Wechseln der Seiten und S und B für die Schriftgrösse.",strings_pl:{slide:"slajd","help?":"pomoc?","contents?":"spis treści?","table of contents":"spis treści","Table of Contents":"Spis Treści","restart presentation":"Restartuj prezentację","restart?":"restart?"},help_pl:"Zmieniaj slajdy klikając myszą, naciskając spację, strzałki lewo/prawolub PgUp / PgDn. Użyj klawiszy S i B, aby zmienić rozmiar czczionki.",strings_fr:{slide:"page","help?":"Aide","contents?":"Index","table of contents":"table des matières","Table of Contents":"Table des matières","restart presentation":"Recommencer l'exposé","restart?":"Début"},help_fr:"Naviguez avec la souris, la barre d'espace, les flèches gauche/droite ou les touches Pg Up, Pg Dn. Utilisez les touches S et B pour modifier la taille de la police.",strings_hu:{slide:"oldal","help?":"segítség","contents?":"tartalom","table of contents":"tartalomjegyzék","Table of Contents":"Tartalomjegyzék","restart presentation":"bemutató újraindítása","restart?":"újraindítás"},help_hu:"Az oldalak közti lépkedéshez kattintson az egérrel, vagy használja a szóköz, a bal, vagy a jobb nyíl, illetve a Page Down, Page Up billentyűket. Az S és a B billentyűkkel változtathatja a szöveg méretét.",strings_it:{slide:"pag.","help?":"Aiuto","contents?":"Indice","table of contents":"indice","Table of Contents":"Indice","restart presentation":"Ricominciare la presentazione","restart?":"Inizio"},help_it:"Navigare con mouse, barra spazio, frecce sinistra/destra o PgUp e PgDn. Usare S e B per cambiare la dimensione dei caratteri.",strings_el:{slide:"σελίδα","help?":"βοήθεια;","contents?":"περιεχόμενα;","table of contents":"πίνακας περιεχομένων","Table of Contents":"Πίνακας Περιεχομένων","restart presentation":"επανεκκίνηση παρουσίασης","restart?":"επανεκκίνηση;"},help_el:"Πλοηγηθείτε με το κλίκ του ποντικιού, το space, τα βέλη αριστερά/δεξιά, ή Page Up και Page Down. Χρησιμοποιήστε τα πλήκτρα S και B για να αλλάξετε το μέγεθος της γραμματοσειράς.",strings_ja:{slide:"スライド","help?":"ヘルプ","contents?":"目次","table of contents":"目次を表示","Table of Contents":"目次","restart presentation":"最初から再生","restart?":"最初から"},help_ja:"マウス左クリック ・ スペース ・ 左右キー または Page Up ・ Page Downで操作， S ・ Bでフォントサイズ変更",strings_zh:{slide:"幻灯片","help?":"帮助?","contents?":"内容?","table of contents":"目录","Table of Contents":"目录","restart presentation":"重新启动展示","restart?":"重新启动?"},help_zh:"用鼠标点击, 空格条, 左右箭头, Pg Up 和 Pg Dn 导航. 用 S, B 改变字体大小.",strings_ru:{slide:"слайд","help?":"помощь?","contents?":"содержание?","table of contents":"оглавление","Table of Contents":"Оглавление","restart presentation":"перезапустить презентацию","restart?":"перезапуск?"},help_ru:"Перемещайтесь кликая мышкой, используя клавишу пробел, стрелкивлево/вправо или Pg Up и Pg Dn. Клавиши S и B меняют размер шрифта.",strings_sv:{slide:"sida","help?":"hjälp","contents?":"innehåll","table of contents":"innehållsförteckning","Table of Contents":"Innehållsförteckning","restart presentation":"visa presentationen från början","restart?":"börja om"},help_sv:"Bläddra med ett klick med vänstra musknappen, mellanslagstangenten, vänster- och högerpiltangenterna eller tangenterna Pg Up, Pg Dn. Använd tangenterna S och B för att ändra textens storlek.",strings:{},localize:function(d){if(d==""){return d}var b,c=w3c_slidy.strings[w3c_slidy.lang];if(c){b=c[d];if(b){return b}}var a=w3c_slidy.lang.split("-");if(a.length>1){c=w3c_slidy.strings[a[0]];if(c){b=c[d];if(b){return b}}}return d},init_localization:function(){var b=w3c_slidy;var a=w3c_slidy.help_text;this.strings={es:this.strings_es,ca:this.strings_ca,cs:this.strings_cs,nl:this.strings_nl,de:this.strings_de,pl:this.strings_pl,fr:this.strings_fr,hu:this.strings_hu,it:this.strings_it,el:this.strings_el,jp:this.strings_ja,zh:this.strings_zh,ru:this.strings_ru,sv:this.strings_sv},b.strings_es[a]=b.help_es;b.strings_ca[a]=b.help_ca;b.strings_cs[a]=b.help_cs;b.strings_nl[a]=b.help_nl;b.strings_de[a]=b.help_de;b.strings_pl[a]=b.help_pl;b.strings_fr[a]=b.help_fr;b.strings_hu[a]=b.help_hu;b.strings_it[a]=b.help_it;b.strings_el[a]=b.help_el;b.strings_ja[a]=b.help_ja;b.strings_zh[a]=b.help_zh;b.strings_ru[a]=b.help_ru;b.strings_sv[a]=b.help_sv;w3c_slidy.lang=document.body.parentNode.getAttribute("lang");if(!w3c_slidy.lang){w3c_slidy.lang=document.body.parentNode.getAttribute("xml:lang")}if(!w3c_slidy.lang){w3c_slidy.lang="en"}}};if(w3c_slidy.ie6||w3c_slidy.ie7){document.write("<iframe id='historyFrame' src='javascript:\"<html></html>\"' height='1' width='1' style='position:absolute;left:-800px'></iframe>")}w3c_slidy.set_up();setTimeout(w3c_slidy.hide_slides,50);
/*]]>*/
</script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Introductie Functioneel Programmeren (met Haskell)</h1>
  <p class="author">
Han Joosten
  </p>
  <p class="date">21 februari 2012</p>
</div>
<div class="slide">
<h1 id="welkom">Welkom!</h1>
<pre class="haskell"><code>main = putStrLn &quot;hallo!&quot;
</code></pre>
<ul>
<li><p>Mijn naam is Han Joosten (han.joosten@atos.net)</p></li>
<li><p>Ik ben Requirements Engineer bij TS Noord</p></li>
<li><p>Begonnen met Haskell ca. 2006</p></li>
<li><p>Ik help mee bij een open source project</p>
<ul>
<li><a href="http://ampersand.sourceforge.net">ampersand.sourceforge.net</a></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="achtergrond-in-functioneel-programmeren">Achtergrond in (functioneel) programmeren</h1>
<p>ik ben in aanraking gekomen met functionele talen op de universiteit</p>
<pre><code>* Twentel, Miranda, Lisp
</code></pre>
<p>Diverse specificatie talen:</p>
<pre><code>* Lotos, ASF+SDF, Typol, LaTeX
</code></pre>
<p>Na mijn afstuderen in 1990 heb ik geprogrammeerd in iteratieve talen</p>
<pre><code>* Pascal, C, Perl, Rexx, Cool:Gen (integrated Case tool)
</code></pre>
<ul>
<li><p>Mijn interesse voor Haskell werd gewekt rond 2006</p></li>
<li><p>Haskell is een volwassen allround programmeertaal</p></li>
<li><p>Haskell community is heel behulpzaam</p></li>
</ul>
</div>
<div class="slide">
<h1 id="over-deze-presentatie">Over deze presentatie</h1>
<ul>
<li><p>Reden: Omdat ik enthousiast ben over Functioneel Programmeren</p></li>
<li><p>Doel: Enthousiasmeren van jullie</p></li>
</ul>
</div>
<div class="slide">
<h1 id="over-deze-sheets">Over deze sheets</h1>
<ul>
<li>Veel is (met dank!) gepikt van Bryan O'Sullivan</li>
</ul>
<p><img src="http://www.realworldhaskell.org/blog/wp-content/themes/mistylook-101/img/profile.jpg" alt="Real World Haskell" /> Bryan O'Sullivan is co-auteur van het boek <a href="http://www.realworldhaskell.org">Real World Haskell</a>. Dit is een gratis online boek dan zeer goed bruikbaar is als leerboek als je verder wilt met Haskell.</p>
<ul>
<li><p>Na te lezen op <a href="http://hanjoosten.github.com/HaskellWorkshop/slides/slidesDutch.html">http://hanjoosten.github.com/HaskellWorkshop/slides/slidesDutch.html</a></p></li>
<li><p>beschikbaar op Github:</p></li>
</ul>
<pre><code>git clone https://github.com/hanjoosten/HaskellWorkshop
</code></pre>
</div>
<div class="slide">
<h1 id="wat-kan-je-verwachten-1">Wat kan je verwachten 1</h1>
<ul>
<li><p>Haskell is een behoorlijk uitgebreide taal</p></li>
<li><p>Omdat er veel onbekend is voor nieuwkomers, kan je er van uit gaan dat je ver van je comfort-zone zal geraken</p></li>
<li><p>Ik ga je <em>interessante</em> dingen leren, maar niet <em>alles</em></p></li>
</ul>
</div>
<div class="slide">
<h1 id="wat-kan-je-verwachten-2">Wat kan je verwachten 2</h1>
<ul>
<li><p>Dit is een <em>hands-on</em> workshop: je gaat zelf code schrijven!</p></li>
<li><p>Na ongeveer een uur is er een korte pauze</p></li>
<li><p>Schroom niet! Stel gerust vragen!</p></li>
</ul>
</div>
<div class="slide">
<h1 id="je-gereedschap">Je gereedschap</h1>
<ul>
<li><p>Je hebt het Haskell Platform al geïnstalleerd als het goed is.</p>
<ul>
<li><a href="http://hackage.haskell.org/platform/">hackage.haskell.org/platform</a></li>
</ul></li>
<li><p>We hebben nu een super gereedschapskist</p>
<ul>
<li><p>De GHC compiler (<code>ghc</code>)</p></li>
<li><p>De GHCi interpreter (<code>ghci</code>)</p></li>
<li><p>De Cabal package manager (<code>cabal</code>)</p></li>
<li><p>Enkele handige libraries en tools</p></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="wat-hebben-we-nog-meer-nodig">Wat hebben we nog meer nodig?</h1>
<ul>
<li><p>Een text editor</p></li>
<li><p>Een terminal window</p></li>
</ul>
</div>
<div class="slide">
<h1 id="probleemstelling">Probleemstelling</h1>
<p>Gegeven een website. We willen er data afhalen (web-scraping) en er andere belangrijke web pagina's mee vinden.</p>
<p>Er valt dan ook veel uit te zoeken!</p>
<ol style="list-style-type: decimal">
<li><p>Haskell leren</p></li>
<li><p>Een web pagina downloaden</p></li>
<li><p>De links van een pagina halen, zodat we meer pagina's kunnen vinden om te downloaden</p></li>
<li><p>Als we zo ver zijn, bepalen we de pagina's die relevant zijn</p></li>
<li><p>en ook nog een beetje snel?</p></li>
</ol>
</div>
<div class="slide">
<h1 id="aan-de-slag">Aan de slag!</h1>
<p>Maak een file <code>Hello.hs</code> met de volgende inhoud:</p>
<pre class="haskell"><code>main = putStrLn &quot;hello, world!&quot;
</code></pre>
<p>De extentie <code>.hs</code> is de standaard voor Haskell source files.</p>
<p>De naam van een bestand begint met een hoofdletter en iedereen gebruikt <code>CamelCase</code>.</p>
</div>
<div class="slide">
<h1 id="vertalen">Vertalen</h1>
<p>Dit commando zoekt naar <code>Hello.hs</code> in de huidige directory, en vertaalt het:</p>
<pre><code>ghc --make Hello
</code></pre>
<p>Het gegenereerde programma heet <code>Hello</code> (<code>Hello.exe</code> op Windows).</p>
<ul>
<li>De <code>--make</code> optie zorgt er voor dat GHC de afhankelijkheden met andere bestanden en packages automatisch afhandelt.</li>
</ul>
</div>
<div class="slide">
<h1 id="even-controleren">Even controleren</h1>
<p>Is het iedereen gelukt om hun <code>Hello</code> programma te genereren en uit te voeren?</p>
</div>
<div class="slide">
<h1 id="en-nu-wat-handiger">En nu wat handiger</h1>
<p>Het is prettig om snelle, goede code te hebben.</p>
<p>maar als <em>ik</em> programmeer, dan:</p>
<ul>
<li><p>moet ik vaak nog veel uitzoeken.</p></li>
<li><p>ik maak best veel fouten.</p></li>
</ul>
<p>In deze omstandigheden werkt een echte compiler vertragend.</p>
<p>Er is daarom een interactieve interpreter, <code>ghci</code>.</p>
</div>
<div class="slide">
<h1 id="aan-de-slag-met-ghci">Aan de slag met GHCi</h1>
<p>Simpel genoeg:</p>
<pre><code>ghci
</code></pre>
<p>Er verschijnt wat opstart-tekst, gevolgd door de prompt:</p>
<pre><code>GHCi, version 7.0.3: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Loading package ffi-1.0 ... linking ... done.
Prelude&gt;
</code></pre>
<p>Deze standaard prompt vertelt ons welke modules er beschikbaar zijn om mee te spelen.</p>
</div>
<div class="slide">
<h1 id="spelen-met-ghci">Spelen met GHCi</h1>
<p>De <code>ghci</code> interpreter evalueert interactief expressies.</p>
<p>Probeer nu zelf:</p>
<pre class="haskell"><code>2 + 2
</code></pre>
<pre class="haskell"><code>123456781234567812345678 * 87654321876543
</code></pre>
<pre class="haskell"><code>&quot;foo&quot; ++ &quot;bar&quot;
</code></pre>
<p>(De <code>++</code> is de &quot;append&quot; operator.)</p>
</div>
<div class="slide">
<h1 id="interpreter-commandos">Interpreter commando's</h1>
<p>Alle interpreter commando's beginnen met een &quot;<code>:</code>&quot; teken.</p>
<p>Laten we ons programma in <code>ghci</code> laden:</p>
<pre><code>:load Hello.hs
</code></pre>
<p>De <code>ghci</code> prompt verandert:</p>
<pre><code>Main&gt;
</code></pre>
</div>
<div class="slide">
<h1 id="onze-code-uitvoeren-met-ghci">Onze code uitvoeren met ghci</h1>
<p>We hebben een functie met de naam <code>main</code> gedefinieerd. Voer het nu uit:</p>
<pre><code>main
</code></pre>
<p>Is het gelukt?</p>
<p>En wat zou dit doen?</p>
<pre class="haskell"><code>putStrLn &quot;hoi mam!&quot;
</code></pre>
</div>
<div class="slide">
<h1 id="enkele-van-de-nuttigste-commandos">Enkele van de nuttigste commando's</h1>
<p>Onthoud dat alle <code>ghci</code> commando's met een &quot;<code>:</code>&quot; beginnen.</p>
<ul>
<li><p><code>:help</code> toont welke commando's we tot onze beschikking hebben.</p></li>
<li><p><code>:reload</code> laden van het bestand dat het laatst is ge<code>:load</code>.</p></li>
<li><p><code>:edit</code> opent de tekst editor met het bestand dat het laatst is ge<code>:load</code>. (echter <em>niet</em> automatische <code>:reload</code>.)</p></li>
<li><p><code>:quit</code> beëindigt <code>GHCi</code>.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="enkele-ghci-efficiency-tips">Enkele ghci efficiency tips</h1>
<p>We kunnen commando's afkorten:</p>
<ul>
<li><p><code>:e</code> is synoniem voor <code>:edit</code></p></li>
<li><p><code>:r</code> is <code>:reload</code></p></li>
</ul>
<p>We hebben ook historie en command line editing.</p>
<ul>
<li><p>Op Unix, vergelijkbaar met <code>readline</code>.</p></li>
<li><p>Op Windows, zelfde als <code>cmd.exe</code>.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="gewenning-aan-de-cyclus">Gewenning aan de cyclus</h1>
<p>Gebruik <code>:edit</code> of je tekst editor om de &quot;hello&quot; tekst aan te passen.</p>
<p>Gebruik <code>:reload</code> om je bestand opnieuw te laden.</p>
<p>Test je nieuwe definitie van <code>main</code>.</p>
<ul>
<li>Oefening: Gebruik de &quot;pijl omhoog&quot; toets om door je commando historie te gaan totdat je terug komt op de laatste keer dat je <code>main</code> typte.</li>
</ul>
</div>
<div class="slide">
<h1 id="lijsten-en-strings">Lijsten en Strings</h1>
<pre class="haskell"><code>[1,2,3,4]
</code></pre>
<pre class="haskell"><code>['h','e','l','l','o']
</code></pre>
<p>Dubbele haakjes zijn alleen maar een verkorte schrijfwijze voor de langere vorm:</p>
<pre class="haskell"><code>&quot;hello&quot;
</code></pre>
<p>Wat zou dit als resultaat opleveren?</p>
<pre class="haskell"><code>&quot;foo&quot; == ['f','o','o']
</code></pre>
</div>
<div class="slide">
<h1 id="functies-aanroepen-1">Functies aanroepen: 1</h1>
<p>We gebruiken spaties om de functie van zijn argumenten te scheiden:</p>
<pre class="haskell"><code>head &quot;foo&quot;
</code></pre>
<pre class="haskell"><code>head [1,2,3]
</code></pre>
<pre class="haskell"><code>tail [1,2,3]
</code></pre>
</div>
<div class="slide">
<h1 id="functies-aanroepen-2">Functies aanroepen: 2</h1>
<p>Bij meerdere argumenten, worden alle argumenten onderling gescheiden door spaties:</p>
<pre class="haskell"><code>min 3 4
</code></pre>
<p>Als een argument zelf een samengestelde expressie is, moeten er haken omheen:</p>
<pre class="haskell"><code>compare (3+5) (2+7)
</code></pre>
<pre class="haskell"><code>max (min 3 4) 5
</code></pre>
</div>
<div class="slide">
<h1 id="zelf-doen-1">Zelf doen: 1</h1>
<p>Gebruik <code>ghci</code> als een rekenmachine.</p>
<p>De <code>**</code> operator is voor machtsverheffen.</p>
<ul>
<li>Als ik 500 Euro op een bankrekening zet tegen 3% rente per jaar, hoeveel heb ik dan na 10 jaar?</li>
</ul>
</div>
<div class="slide">
<h1 id="zelf-doen-2">Zelf doen: 2</h1>
<p>De notatie <code>['a'..'z']</code> genereert een lijst van start tot eind, inclusief.</p>
<p>De <code>sum</code> functie sommeert alle elementen in een lijst.</p>
<ul>
<li>Wat is de som van de getallen tussen 9 en 250, inclusief, <em>minus</em> 2?</li>
</ul>
</div>
<div class="slide">
<h1 id="zelf-doen-3">Zelf doen: 3</h1>
<p>De <code>show</code> functie toont een waarde als een String. Probeer maar!</p>
<pre class="haskell"><code>show (1 == 2)
</code></pre>
<p>De <code>length</code> functie geeft ons het aantal elementen in een lijst.</p>
<pre class="haskell"><code>length [1,2,3]
</code></pre>
<ul>
<li>Uit hoeveel cijfers bestaat het product van alle getallen tussen 0xBE en 0xEF, inclusief?</li>
</ul>
</div>
<div class="slide">
<h1 id="zelf-functies-defini&#235;ren">Zelf functies definiëren</h1>
<p>Zelf functies definiëren is best eenvoudig.</p>
<p>Open je tekst editor, maak een nieuw bestand met de <code>.hs</code> extentie, en begin te schrijven:</p>
<pre class="haskell"><code>isOdd x  =  (rem x 2) == 1
</code></pre>
<ul>
<li><p>We beginnen met de naam van de functie.</p></li>
<li><p>Vervolgens komen de namen van de parameter(s) die we willen, gescheiden door spaties.</p></li>
<li><p>Dan komt een enkel <code>=</code> teken, waarachter de <em>body</em> van de functie volgt.</p></li>
</ul>
<p>Laad je bestand in <code>ghci</code> en probeer <code>myOdd</code> maar eens uit.</p>
</div>
<div class="slide">
<h1 id="smaakmakers">Smaakmakers</h1>
<p>Nu kunnen we heel eenvoudige functies maken, maar we missen belangrijke ingredienten voor het echte werk.</p>
<p>Dus, waar wachten we op!</p>
</div>
<div class="slide">
<h1 id="conditionele-uitvoering">Conditionele uitvoering</h1>
<p>Q: Hoe ziet de bekende <code>if</code> er uit in Haskell?</p>
<p>A: Bekend!</p>
<pre class="haskell"><code>ggd a b = if b == 0
          then a
          else ggd b (rem a b)
</code></pre>
<p>We hebben de volgende elementen:</p>
<ul>
<li><p>Een Boolean expressie</p></li>
<li><p><code>then</code> een expressie die het resultaat is als de Boolean <code>True</code> is</p></li>
<li><p><code>else</code> een expressie die het resultaat is als de Boolean <code>False</code> is</p></li>
</ul>
</div>
<div class="slide">
<h1 id="eindelijk-een-klein-beetje-over-types">Eindelijk! Een klein beetje over types</h1>
<p>De twee mogelijke resultaat expressies van een <code>if</code> expressie moeten hetzelfde type hebben.</p>
<p>Als <code>then</code> een <code>String</code> oplevert, dan moet <code>else</code> dat ook doen!</p>
<p>Het volgende voorbeeld is natuurlijk onzin:</p>
<pre class="haskell"><code>if True
then 3.14
else &quot;wombat&quot;
</code></pre>
<p>Dit soort onzin-typering is in Haskell verboden.</p>
</div>
<div class="slide">
<h1 id="wat-nog-meer-over-else">Wat nog meer over else?</h1>
<p>In imperatieve talen kunnen we meestal het <code>else</code> deel na de <code>if</code> weglaten.</p>
<p>Maar niet in Haskell.</p>
<p>Waarom kan dit wel bij imperatieve talen, en niet in Haskell?</p>
</div>
<div class="slide">
<h1 id="een-bijna-triviale-oefening">Een bijna triviale oefening</h1>
<p>Schrijf een functie met als resultaat het argument met daarachter <code>&quot;, world&quot;</code> geplakt, als dat argument <code>&quot;hello&quot;</code> is, of alleen maar het onveranderde argument in andere gevallen.</p>
<ul>
<li>Oh ja, De &quot;append&quot;-functie luistert naar de naam <code>++</code>.</li>
</ul>
</div>
<div class="slide">
<h1 id="lijsten-in-haskell">Lijsten in Haskell</h1>
<p>We weten al hoe een lijst er in Haskell uitziet:</p>
<pre class="haskell"><code>[1,2,3]
</code></pre>
<p>En natuurlijk de verkorte schrijfwijze voor Strings:</p>
<pre class="haskell"><code>&quot;foo&quot; == ['f','o','o']
</code></pre>
<p>Maar is dit alles wat er valt te weten?</p>
</div>
<div class="slide">
<h1 id="lijst-constructors">Lijst constructors</h1>
<p>Stel dat we een lijst van de grond af aan willen opbouwen.</p>
<ul>
<li><p>We schrijven de <em>lege lijst</em> als <code>[]</code>.</p></li>
<li><p>Gegeven een bestaande lijst, kunnen we een ander element aan het <em>begin</em> van de lijst toevoegen met behulp van de <code>:</code> operator.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="typ-dit-in-ghci">Typ dit in ghci</h1>
<p>Voeg een element toe aan een lege lijst:</p>
<pre class="haskell"><code>1 : []
</code></pre>
</div>
<div class="slide">
<h1 id="en-nu-verder-vanaf-lijsten-met-&#233;&#233;n-element">En nu verder vanaf lijsten met één element</h1>
<p>Hoe breiden we zo'n lijst uit?</p>
<pre class="haskell"><code>2 : (1 : [])
</code></pre>
<p>Je hebt vaste wel geraden dat <code>[2,1]</code> een verkorte schrijfwijze is voor <code>2:(1:[])</code>. En dat is inderdaad zo!</p>
<p>Wat is het resultaat van deze expressie?</p>
<pre class="haskell"><code>5 : 8 : [] == [5,8]
</code></pre>
</div>
<div class="slide">
<h1 id="constructors">Constructors</h1>
<p>We refereren aan <code>[]</code> en <code>:</code> als <em>constructors</em>, omdat we ze gebruiken om lijsten mee te construreren.</p>
<p>Als je een lijst maakt, moet de Haskell runtime onthouden welke constructors je hebt gebruikt, en waar precies.</p>
<p>Dus de waarde <code>[5,8]</code> wordt gerepresenteerd als:</p>
<ul>
<li><p>Een <code>:</code> constructor, met <code>5</code> als zijn eerste argument, en als tweede ...</p></li>
<li><p>Nog een <code>:</code> constructor, deze keer met <code>8</code> als zijn eerste argument, en nu als tweede ...</p></li>
<li><p>Een <code>[]</code> constructor.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="wat-zagen-we-zojuist">Wat zagen we zojuist?</h1>
<p>Afhankelijk van je achtergrond, dacht je waarschijnlijk iets als:</p>
<div class="figure">
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Singly-linked-list.svg/408px-Singly-linked-list.svg.png" alt="Hee! Haskell lijsten lijken op enkelvoudig gelinkte lijsten" /><p class="caption">Hee! Haskell lijsten lijken op enkelvoudig gelinkte lijsten</p>
</div>
<div class="figure">
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Cons-cells.svg/300px-Cons-cells.svg.png" alt="Hee! Dat lijkt op de cons cellen in Lisp!" /><p class="caption">Hee! Dat lijkt op de <code>cons</code> cellen in Lisp!</p>
</div>
<p>Inderdaad.</p>
</div>
<div class="slide">
<h1 id="waarom-zouden-we-ons-druk-maken-om-constructors">Waarom zouden we ons druk maken om constructors?</h1>
<p>Haskell moet natuurlijk onthouden hoe een lijst is opgebouwd.</p>
<p>Het laat <em>ons</em> ook een lijst inspecteren, zodat we kunnen nagaan welke contstructors er gebruikt zijn.</p>
<p>Hoe doen we dat?</p>
<pre class="haskell"><code>import Data.Char

isCapitalized name
  = case name of
      (first:rest) -&gt; isUpper first
      []           -&gt; False
</code></pre>
</div>
<div class="slide">
<h1 id="de-case-expressie">De case-expressie</h1>
<p>De <code>case</code> expressie laat ons een structuur <em>inspecteren</em>.</p>
<pre class="haskell"><code>isCapitalized name
  = case name of
      []           -&gt; False
      (first:rest) -&gt; isUpper first
</code></pre>
<ul>
<li>Tussen <code>case</code> en <code>of</code> staat de te inspecteren expressie.</li>
<li>Als de structuur overeenkomt met de lege-lijst constructor <code>[]</code>, dan is de structuur <code>name</code> die we inspecteren leeg. Dus geen hoofdletter.</li>
</ul>
<p>Als de gebruikte constructor de &quot;aan de voorkant toevoegen&quot; <code>:</code> operator is, dan wordt het interessanter.</p>
<ul>
<li>Wat er ook maar als eerste argument gebruikt is voor de <code>:</code> constructor wordt gebonden aan de naam <code>first</code>.</li>
<li>Het tweede argument van de <code>:</code> constructor (dus alles in de lijst na het eerste element) wordt gebonden aan de naam <code>rest</code>.</li>
<li>De expressie volgend op <code>-&gt;</code> wordt geëvalueerd met deze waarden.</li>
</ul>
</div>
<div class="slide">
<h1 id="pattern-matching">Pattern matching</h1>
<p>Wat de <code>case</code> expressie doet, noemen we <em>pattern matching</em>.</p>
<ul>
<li><p>Patronen worden gecontroleerd van boven naar beneden.</p></li>
<li><p>Zodra een een patroon 'matcht', wordt het rechter deel (het deel achter de <code>-&gt;</code>) gebruikt als het resultaat van de hele <code>case</code> expressie.</p></li>
<li><p>Als geen enkel patroon 'matcht', ontstaat een exceptie.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="een-voorbeeld">Een voorbeeld</h1>
<p>Laten we stap voor stap kijken wat er gebeurt als we deze expressie evalueren.</p>
<pre class="haskell"><code>isCapitalized &quot;Ann&quot;
</code></pre>
</div>
<div class="slide">
<h1 id="whew-een-paar-oefeningen">Whew! Een paar oefeningen!</h1>
<p>Eindelijk! We kunnen nu iets ingewikkelder functies schrijven.</p>
<p>Nu je het begin van een lijst kan inspecteren, zou je een <em>hele</em> lijst recursief kunnen afhandelen.</p>
<p>Schrijf eerst een functie met de naam <code>myLength</code> die het aantal elementen in een lijst bepaalt.</p>
<p>Vervolgens schrijf je een functie met de naam <code>countCaps</code> die het aantal hoofdletters in een String bepaalt.</p>
<pre class="haskell"><code>countCaps &quot;Monkey Butter&quot; == 2
</code></pre>
</div>
<div class="slide">
<h1 id="het-tellen-van-hoofdletters">Het tellen van Hoofdletters</h1>
<p>Jôh, die countCaps functie was knap lastig. Of niet?</p>
<p>Hier is mijn definitie, gebruik makend van alleen de dingen die we tot nu toe hebben geleerd:</p>
<pre class="haskell"><code>countCaps string =
  case string of
    []     -&gt; 0
    (x:xs) -&gt; if isUpper x
              then 1 + countCaps xs
              else countCaps xs
</code></pre>
</div>
<div class="slide">
<h1 id="huh.">Huh.</h1>
<p>Ik dacht dat Haskell zo eenvoudig leesbaar was!?</p>
</div>
<div class="slide">
<h1 id="leesbaarheid-1-top-level-pattern-matching">Leesbaarheid 1: top-level pattern matching</h1>
<pre class="haskell"><code>countCaps []     = 0
countCaps (x:xs) =
    if isUpper x
    then 1 + countCaps xs
    else countCaps xs
</code></pre>
<p>We kunnen een functie definieren als een serie vergelijkingen, die elk een <code>pattern match</code> bevatten.</p>
<p>Dit is een beter leesbare schrijfwijze voor <code>case</code>.</p>
</div>
<div class="slide">
<h1 id="leesbaarheid-2-guards">Leesbaarheid 2: guards</h1>
<pre class="haskell"><code>countCaps []     = 0
countCaps (x:xs)
   | isUpper x    = 1 + countCaps xs
   | otherwise    = countCaps xs
</code></pre>
<p>Achter elke <code>|</code> staat een <em>guard</em>.</p>
<ul>
<li><p>Als een patroon matcht, evalueren we iedere Boolean guard expressie van boven naar beneden.</p></li>
<li><p>Zodra er een succes heeft, evalueren we de rechterkant als de <code>body</code> van de functie.</p></li>
</ul>
<p>(Jazeker, pattronen in een <code>case</code> kunnen ook guards hebben.)</p>
</div>
<div class="slide">
<h1 id="v&#243;&#243;r">Vóór</h1>
<p>Zoals in de originele versie, maar nu zonder gebruik van <code>case</code>:</p>
<pre class="haskell"><code>countCaps xs =
  if null xs
  then 0 
  else if isUpper (head xs)
       then 1 + countCaps (tail xs)
       else countCaps (tail xs)
</code></pre>
</div>
<div class="slide">
<h1 id="na">Na</h1>
<p>Zowel korter als beter leesbaar:</p>
<pre class="haskell"><code>countCaps []     = 0
countCaps (x:xs)
   | isUpper x    = 1 + countCaps xs
   | otherwise    = countCaps xs
</code></pre>
</div>
<div class="slide">
<h1 id="een-andere-aanpak">Een andere aanpak</h1>
<p>Schrijf een nieuwe versie van <code>countCaps</code>:</p>
<ul>
<li><p>Schrijf een functie die door een lijst loopt, en die een nieuwe lijst genereert bestaande uit alleen de hoofdletters van de oorspronkelijke lijst.</p></li>
<li><p>Gebruik <code>length</code> om het aantal elementen te tellen.</p></li>
</ul>
<p>Dit zou hetzelfde resultaat moeten opleveren als je eerste functie. Toch?</p>
</div>
<div class="slide">
<h1 id="wijziging-van-de-specificatie">Wijziging van de specificatie</h1>
<p>Stel dat we het aantal kleine letters in een string willen tellen.</p>
<p>Dit lijkt bijna hetzelfde als onze functie om hoofletters te tellen.</p>
<p>Wat kunnen we doen met deze observatie?</p>
</div>
<div class="slide">
<h1 id="hogere-orde-functies">Hogere orde functies</h1>
<p><em>Hogere orde functie</em>: een functie die een andere functie accepteert als argument.</p>
<pre class="haskell"><code>filter pred [] = []
filter pred (x:xs)
  | pred x     = x : filter pred xs
  | otherwise  =     filter pred xs
</code></pre>
<p>Hoe kunnen we dit gebruiken om <code>countLowerCase</code> te definieren?</p>
</div>
<div class="slide">
<h1 id="data-in-data-uit">Data in, data uit</h1>
<p>Tot nu toe hebben we verschillende definities gezien zoals deze:</p>
<pre class="haskell"><code>countLowerCase string =
  length (filter isLower string)
</code></pre>
<p>We zien hierin een terugkerend pattroon:</p>
<ul>
<li><p>Een functie met één argument</p></li>
<li><p>krijgt als input het resultaat van ...</p></li>
<li><p>... een andere functie met één argument</p></li>
</ul>
</div>
<div class="slide">
<h1 id="functie-compositie">Functie compositie</h1>
<p>Haskell beperkt ons niet tot alleen maar alfanumerieke namen voor functies.</p>
<p>We kunnen een functie definiëren met de simpele naam &quot;<code>.</code>&quot;, die we als een operator kunnen gebruiken:</p>
<pre class="haskell"><code>(f . g) x = f (g x)
</code></pre>
<p>Wat is hier het nut van?</p>
<pre class="haskell"><code>countLowerCase = length . filter isLower
</code></pre>
</div>
<div class="slide">
<h1 id="compositie">Compositie???</h1>
<p>Enige toelichting is wel op z'n plek, om het duidelijker te maken.</p>
<p>We plaatsen de argumenten in de rechterkant van onze functie definitie:</p>
<pre class="haskell"><code>(f . g) x = f (g x)
</code></pre>
<p>Als eerste argument van &quot;<code>.</code>&quot; hadden we <code>length</code>, en <code>filter isLower</code> als het tweede:</p>
<pre class="haskell"><code>(length . filter isLower) x 
  = length (filter isLower x)
</code></pre>
</div>
<div class="slide">
<h1 id="lokale-variabelen">Lokale variabelen</h1>
<p>Binnen in een expressie kunnen we nieuwe variabelen introduceren door gebruik te maken van <code>let</code>.</p>
<pre class="haskell"><code>let x = 2
    y = 4
in x + y
</code></pre>
<ul>
<li><p>Lokale definities komen na <code>let</code>.</p></li>
<li><p>De expressie waarin we ze gebruiken komen na <code>in</code>.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="white-space">White space</h1>
<p>Haskell is gevoelig voor white space!</p>
<ul>
<li><p>Een top-level definitie start in de meest linkse kolom.</p></li>
<li><p>Volgend op het begin van een definitie, als de volgende regel inspringt, wordt die regel behandeld als vervolg van die definitie.</p></li>
<li><p>Gebruik nooit 'Tab' in je source files.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="white-space-en-lokale-variabelen">White space en lokale variabelen</h1>
<p>Als je lokale variabelen definieert, dan moeten ze allemaal beginnen in dezelfde kolom.</p>
<p>Dit is goed:</p>
<pre class="haskell"><code>let x = 2
    y = 4
in x + y
</code></pre>
<p>Maar dit niet:</p>
<pre class="haskell"><code>let x = 2
      y = 4
in x + y
</code></pre>
</div>
<div class="slide">
<h1 id="oefenen-met-compositie">Oefenen met compositie</h1>
<p>Schrijf een functie die een String accepteert en die een nieuwe String oplevert, die alleen de woorden bevat die met een klinker beginnen. Maak hierbij zoveel mogelijk gebruik van functie compositie.</p>
<ul>
<li>Voor je begint, is het verstandig om eerst met de <code>words</code> en <code>unwords</code> functies te spelen.</li>
</ul>
<p>Voorbeeld:</p>
<pre class="haskell"><code>disemvowel &quot;I think, therefore I am.&quot;
  == &quot;I I am.&quot;
</code></pre>
</div>
<div class="slide">
<h1 id="een-oplossing">Een oplossing</h1>
<p>Dit is hoe ik <code>disemvowel</code> schreef:</p>
<pre class="haskell"><code>disemvowel = 
  let isVowel c = toLower c `elem` &quot;aeiou&quot;
  in  unwords . filter (isVowel . head) . words
</code></pre>
<p>Doet dit je denken aan een Unix shell pipeline, maar dan van rechts naar links?</p>
</div>
<div class="slide">
<h1 id="oh-ja-hoe-zat-het-met-onze-probleemstelling">Oh ja, hoe zat het met onze probleemstelling?</h1>
<p>Gegeven een website. We willen er data afhalen (web-scraping) en er andere belangrijke web pagina's mee vinden.</p>
<p>Nu zijn we Haskell pro's, toch?</p>
<ul>
<li>Een web pagina downloaden</li>
</ul>
</div>
<div class="slide">
<h1 id="doen-een-web-pagina-downloaden">Doen: Een web pagina downloaden!</h1>
<p>Eigenlijk willen we gebruik maken van een library om een webpagina te kunnen downloaden.</p>
<p>Gelukkig bestaat er voor dit soort gevallen een hele handige centrale repository van open source Haskell software:</p>
<ul>
<li><p><a href="http://hackage.haskell.org/">http://hackage.haskell.org</a></p></li>
<li><p>(In de volksmond: &quot;Hackage&quot;)</p></li>
</ul>
<p>Go er nu heen!</p>
<p>Click op de <a href="http://hackage.haskell.org/packages/archive/pkg-list.html">Packages</a> link bovenin de pagina om packages te doorzoeken.</p>
<p>Helaas is het een overweldigende grote lijst, maar wie geduld heeft, kan er altijd nuttige dingen vinden.</p>
<p>Wie heeft geduld?</p>
</div>
<div class="slide">
<h1 id="bah">Bah!</h1>
<p>Bladeren door <em>duizenden</em> libraries kost veel tijd/moeite. Is er geen betere manier?</p>
<p>Gebruik het <code>cabal</code> commando!</p>
<p>Voer dit commando uit in een terminal window:</p>
<pre><code>cabal update
</code></pre>
<p>Hiermee download je de meest recente index van alle software op Hackage.</p>
<p>Met deze bijgewerkte index kunnen we zoeken:</p>
<pre><code>cabal list http
</code></pre>
<p>Je hebt nu nog wel ruim 20 packages om door te akkeren, maar het is beter dan de duizenden packages op de Packages pagina.</p>
</div>
<div class="slide">
<h1 id="even-de-zoektocht-helpen.">Even de zoektocht 'helpen'.</h1>
<p>Een goede HTTP client library heet <code>http-enumerator</code>.</p>
<p>De documentatie staat natuurlijk online:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/http-enumerator">hackage.haskell.org/package/http-enumerator</a></li>
</ul>
<p>De startpagina voor een package kan intimiderend overkomen, maar kijk maar eens onderaan, bij de sectie &quot;Modules&quot;.</p>
<p>Wat zie je?</p>
</div>
<div class="slide">
<h1 id="een-package-installeren">Een package installeren</h1>
<p>We moeten <code>http-enumerator</code> eerst installeren, voordat we er gebuik van kunnen maken.</p>
<p>Het installeren van het <code>http-enumerator</code> package gaat met behulp van een eenvoudig commando:</p>
<pre><code>cabal install http-enumerator
</code></pre>
<p>Dit commando bepaalt alle andere packages waar <code>http-enumerator</code> afhankelijk van is. Vervolgens worden al deze packages gedownload, vertaald en geïnstalleerd.</p>
<p>Dit kan wel een paar minuten duren. De compiler output verschijnt op het scherm.</p>
</div>
<div class="slide">
<h1 id="documentatie-lezen-packages-en-modules">Documentatie lezen: packages en modules</h1>
<p>Nu we aan het wachten zijn tot het <code>http-enumerator</code> package gereed is voor gebruik, kunnen we vast uitzoeken hoe we het kunnen gebruiken.</p>
<p>Herinner je de link nog naar de API documentatie, onderin de webpage van de package? Ga daar maar eens heen en bekijk de documentatie.</p>
<p>Een API pagina begint met een titel die er als volgt uit kan zien:</p>
<pre><code>Network.HTTP.Enumerator
</code></pre>
<p>Dit is de naam van een <em>module</em>.</p>
<p>Een module is een verzameling van samenhangende code.</p>
<p>Een <em>package</em> is een verzameling van samenhangende modules.</p>
</div>
<div class="slide">
<h1 id="documentatie-lezen-de-rest">Documentatie lezen: de rest</h1>
<p>Na de gebruikelijke initiele bla bla, bevat de documentatie van een module uit type signatures en beschrijvingen.</p>
<p>Dit is een heel eenvoudige type signature:</p>
<pre><code>foo :: String
</code></pre>
<p>Wat is dat nou weer?</p>
<p>De <em>naam</em> van het ding dat hier wordt gedefinieerd komt voor het <code>::</code> teken.</p>
<p>Het <em>type</em> ervan volgt na de <code>::</code>.</p>
<p>Dit betekent dat &quot;de waarde met de naam <code>foo</code> is van het type <code>String</code>&quot;.</p>
</div>
<div class="slide">
<h1 id="type-systeem-van-haskell">Type systeem van Haskell</h1>
<p>Tot nu toe hebben we ons niet druk gemaakt over typering of type signatures.</p>
<p>Elke expressie en waarde in Haskell heeft één type.</p>
<p>Deze types kunnen vrijwel altijd automatisch worden <em>afgeleid</em> door de compiler of interpreter.</p>
</div>
<div class="slide">
<h1 id="veel-voorkomende-basis-types">Veel voorkomende basis types</h1>
<ul>
<li><p><code>Bool</code></p></li>
<li><p><code>Int</code></p></li>
<li><p><code>Char</code></p></li>
<li><p><code>Double</code></p></li>
</ul>
</div>
<div class="slide">
<h1 id="de-signature-van-een-functie">De signature van een functie</h1>
<p>Hier is nog een type signature:</p>
<pre><code>words :: String -&gt; [String]
</code></pre>
<p>we zien een nieuw symbool, <code>-&gt;</code>. Die zegt &quot;dit is een functie&quot;.</p>
<p>Het type na de laatste <code>-&gt;</code> is het return type van de functie.</p>
<p>Alles ertussen zijn de types van de argumenten.</p>
<p>Dus dit is een functie die een <code>String</code> als argument heeft. En het resultaat is een... wat?</p>
</div>
<div class="slide">
<h1 id="lijst-notatie">Lijst notatie</h1>
<p>De notatie <code>[a]</code> betekent &quot;een lijst van waarden, elk met een of ander type <code>a</code>&quot;.</p>
<p>Dus <code>[String]</code> betekent &quot;een lijst van waarden, elk met type <code>String</code>&quot;.</p>
</div>
<div class="slide">
<h1 id="type-synoniemen">Type synoniemen</h1>
<p>Wat is een <code>String</code> eigenlijk?</p>
<ul>
<li>Het is niks bijzonders, maar gewoon een <em>synoniem</em> voor <code>[Char]</code>, oftewel &quot;een lijst van <code>Char</code>&quot;.</li>
</ul>
<p>We kunnen zelf ook synoniemen definiëren.</p>
<pre class="haskell"><code>type Euros = Int
</code></pre>
<p>Een type synoniem kan handig zijn om de bedoeling van een bestaand type te documenteren.</p>
</div>
<div class="slide">
<h1 id="words">Words</h1>
<pre><code>words :: String -&gt; [String]
</code></pre>
<p>We zien nu dat deze functie een String als argument accepteert, en een lijst van Strings teruggeeft.</p>
<p>Als we dit zo zien, kan je dan raden wat <code>words</code> zou kunnen doen?</p>
</div>
<div class="slide">
<h1 id="nog-een-signature">Nog een signature</h1>
<p>Wat kan je hierover vertellen?</p>
<pre><code>mystery :: [String] -&gt; String
</code></pre>
<p>Welk gedrag zou deze functie kunnen hebben?</p>
</div>
<div class="slide">
<h1 id="documentatie-uit-de-echte-wereld">Documentatie uit de <em>echte</em> wereld</h1>
<p>Hier is het allereerste signature uit <code>http-enumerator</code>:</p>
<pre><code>simpleHttp :: MonadIO m =&gt; String -&gt; m ByteString
</code></pre>
<p>Dit is ingewikkelder! Hoe lezen we dit nu weer?</p>
<p>Tussen <code>'::'</code> en <code>'=&gt;'</code> zien we <em>constraints</em> over het gebruik van <code>simpleHttp</code> - Dit kunnen we nu wel even laten voor wat het is.</p>
<ul>
<li><em>Belangrijk</em>: Meestal kan je zonder gevaar dingen negeren die je (nog) niet begrijpt.</li>
</ul>
<p>We zullen die gekke kleine letter <code>m</code> nu ook maar even laten voor wat het is.</p>
<p>Wat kunnen we nu zeggen over deze functie?</p>
</div>
<div class="slide">
<h1 id="bytestring">ByteString</h1>
<p>Een <code>ByteString</code> is een blob van binaire data.</p>
<p>In tegenstelling tot <code>String</code>, wordt het niet als een lijst, maar als een packed array gerepresenteerd.</p>
<p>het bevat binaire <em>bytes</em>, geen tekst!</p>
<ul>
<li>maak geen gebruik van <code>ByteString</code> om datamanipulatie op tekst te doen.</li>
</ul>
</div>
<div class="slide">
<h1 id="speelkwartier-met-ghci">Speelkwartier met ghci!</h1>
<p>Heeft iedereen <code>http-enumerator</code> inmiddels geïnstalleerd?</p>
<p>Start <code>ghci</code>, en laten we eens wat spelen met de module:</p>
<pre><code>import Network.HTTP.Enumerator
</code></pre>
<p>Merk op dat de prompt verandert zodra we het hebben getypt:</p>
<pre><code>Prelude Network.HTTP.Enumerator&gt;
</code></pre>
<p>We weten hierdoor dat de module geladen en beschikbaar is voor gebruik.</p>
</div>
<div class="slide">
<h1 id="wacht-wie-gebruikt-windows">Wacht! Wie gebruikt Windows?</h1>
<p>Onder Windows moeten we eerst Winsock initiëren voordat we netwerken kunnen gebruiken.</p>
<p>First, let's load the lowest-level networking module:</p>
<pre><code>import Network.Socket
</code></pre>
<p>En zo initiëren we Winsock:</p>
<pre><code>withSocketsDo (return ())
</code></pre>
<p>(Onder Unix kan dit geen kwaad.)</p>
</div>
<div class="slide">
<h1 id="nu-we-dat-hobbeltje-genomen-hebben-...">Nu we dat hobbeltje genomen hebben ...</h1>
<p>Eindelijk - we gaan nu een webpagina ophalen!</p>
<pre><code>simpleHttp &quot;http://example.com/&quot;
</code></pre>
<p>Kreeg je een hoop HTML in je terminal window te zien? Yeah!</p>
</div>
<div class="slide">
<h1 id="van-binary-naar-tekst">Van binary naar tekst</h1>
<p>We hebben nu een <code>ByteString</code>, die we om moeten zetten naar tekst, om er mee te kunnen manipuleren.</p>
<p>Voor het gemak nemen we even aan, dat alle web pagina's UTF-8 gecodeerd zijn.</p>
</div>
<div class="slide">
<h1 id="pure-code">Pure code</h1>
<p>Tot nu toe is alle code die we hebben geschreven &quot;Puur&quot;.</p>
<ul>
<li><p>Het gedrag van al onze functies waren alleen afhankelijk van de input.</p></li>
<li><p>Al onze data is onveranderlijk.</p></li>
<li><p>Er is dus geen manier om een globale variabele of het gedrag van een functie aan te passen</p></li>
</ul>
</div>
<div class="slide">
<h1 id="niet-pure-code">niet-pure code</h1>
<p>En toch ... Op een of andere manier hebben we een webpagina gedownload!</p>
<ul>
<li>Webpagina's zijn duidelijk <em>niet</em> puur.</li>
</ul>
<p>Hoe kan dit dan?</p>
<pre class="haskell"><code>length (simpleHttp &quot;http://x.org/&quot;)
</code></pre>
<p>HELAAS.</p>
<p>Het type systeem van Haskell maakt onderscheid tussen code die puur moet zijn en code dat zij-effecten mag hebben (&quot;niet-pure&quot; code).</p>
</div>
<div class="slide">
<h1 id="wat-nu">Wat nu?</h1>
<p>Laten we eerst eens kijken naar een eenvoudiger voorbeeld dan <code>simpleHttp</code>.</p>
<p>Typ dit in <code>ghci</code>:</p>
<pre><code>:type readFile
</code></pre>
<p>We krijgen nu het type van <code>readFile</code> te zien.</p>
</div>
<div class="slide">
<h1 id="io">IO</h1>
<p>Het <code>:type</code> commando toont nu iets als dit:</p>
<pre class="haskell"><code>readFile :: FilePath -&gt; IO String
</code></pre>
<p>Zie je het <code>IO</code> in het resulterend type?</p>
<p>Dat betekent &quot;deze functie kan zij-effecten hebben&quot;.</p>
<p>niet-pure functies, met <code>IO</code> in het resulterend type, worden vaak <em>acties</em> genoemd.</p>
<ul>
<li>Dit helpt om ze te onderscheiden van pure functies.</li>
</ul>
</div>
<div class="slide">
<h1 id="mengen-van-io-met-ander-spul">Mengen van IO met ander spul</h1>
<p>Het type-systeem 'weet' welke functies <code>IO</code> doen en zorgt ervoor dat we hier op een eerlijke manier mee omgaan.</p>
<p>We kunnen echter op een natuurlijke manier pure code mengen met code met zijeffecten:</p>
<pre class="haskell"><code>charCount fileName = do
  contents &lt;- readFile fileName
  return (length contents)
</code></pre>
</div>
<div class="slide">
<h1 id="do-notatie">&quot;do&quot; notatie</h1>
<p>Cruciaal in wat we net zagen was het <code>do</code> keyword aan het begin van de functie definitie.</p>
<p>Het introduceert een serie van <code>IO</code> acties. Een per regel.</p>
</div>
<div class="slide">
<h1 id="opvangen-van-het-resultaat-van-niet-pure-code">Opvangen van het resultaat van niet-pure code</h1>
<p>Om het resultaat van een <code>IO</code> actie op te vangen, gebruiken we <code>&lt;-</code> in plaats van <code>=</code>.</p>
<pre class="haskell"><code>contents &lt;- readFile fileName
</code></pre>
<p>Het resultaat (<code>contents</code>) is puur - Het heeft <em>geen</em> <code>IO</code> type.</p>
<p>Hiermee voeden we pure code met data uit niet-pure code.</p>
</div>
<div class="slide">
<h1 id="de-return-actie">De &quot;return&quot; actie</h1>
<p>Dit is <em>niet</em> het <code>return</code> type zoals je gewend bent!</p>
<p>Het neemt een <em>pure</em> waarde (zonder <code>IO</code> in zijn type), en <em>wikkelt</em> het in het <code>IO</code> type.</p>
<p>Pure code kan niet-pure code nooit aanroepen. Het kan wel data opleveren aan de niet-pure wereld door gebruik te maken van <code>return</code>.</p>
</div>
<div class="slide">
<h1 id="haskell-programs-and-io">Haskell programs and IO</h1>
<p>Elk Haskell programma heeft als entry point een functie met als naam <code>main</code>.</p>
<p>Het type van <code>main</code> is altijd:</p>
<pre class="haskell"><code>main :: IO ()
</code></pre>
<p><code>()</code> heet &quot;unit&quot;, en betekent zo ongeveer hetzelfde als <code>void</code> in C or Java.</p>
<p>Dit betekent dat <em>alle</em> haskell programma's niet-puur zijn!</p>
</div>
<div class="slide">
<h1 id="binary-naar-tekst">Binary naar tekst</h1>
<p>Herinner je nog dat we probeerden vals te spelen?</p>
<p>We hadden dit:</p>
<pre class="haskell"><code>simpleHttp :: String -&gt; IO ByteString
</code></pre>
<p>In plaats hiervan hebben we iets nodig met als resultaat <code>IO String</code>.</p>
<p>Hoe moet dat er uit zien?</p>
</div>
<div class="slide">
<h1 id="utf-8-conversie">UTF-8 conversie</h1>
<p>Om de conversie te doen, gaan we gebruik maken van het package <code>utf8-string</code>.</p>
<pre><code>cabal install utf8-string
</code></pre>
<p>Dit package bevat een module met de naam <code>Data.ByteString.Lazy.UTF8</code>.</p>
<pre class="haskell"><code>import Data.ByteString.Lazy.UTF8
</code></pre>
<p>Hierin is een functie gedefiniëerd met de naam <code>toString</code>:</p>
<pre class="haskell"><code>toString :: ByteString -&gt; String
</code></pre>
</div>
<div class="slide">
<h1 id="utf-8-conversie-oefening">UTF-8 conversie oefening</h1>
<p>Gebruik <code>toString</code> om een actie te schrijven die een URL downloadt en het resultaat converteert naar een <code>String</code>.</p>
<p>Schrijf het type op van de actie.</p>
<ul>
<li><p>Haskell definities hebben gewoonlijk geen type signature nodig.</p></li>
<li><p>Ondanks dit is het een goede gewoonte om ze als <em>documentatie</em> op te schrijven bij top-level definities.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="downloaden-en-opslaan-van-een-web-pagina">Downloaden en opslaan van een web pagina</h1>
<p>Gebruik je <code>download</code> functie om een lokale kopie op te slaan van een webpagina.</p>
<pre class="haskell"><code>saveAs :: String -&gt; Int -&gt; IO ()
</code></pre>
<p>Laten we voor het gemak de lokale files opslaan met namen die nummers bevatten:</p>
<pre class="haskell"><code>makeFileName :: Int -&gt; FilePath
makeFileName k = &quot;download-&quot; ++ show k ++ &quot;.html&quot;
</code></pre>
<p>Om een lokale kopie van een bestand op te slaan, heb je de actie <code>writeFile</code> nodig.</p>
</div>
<div class="slide">
<h1 id="spitten-in-html">Spitten in HTML</h1>
<p>Twee waarheden:</p>
<ul>
<li><p>De meeste HTML in het wild is een zooitje.</p></li>
<li><p>Zelfs het parsen van nette HTML is ingewikkeld.</p></li>
</ul>
<p>Laten we voor de verandering maar weer eens een library gaan gebruiken!</p>
<pre><code>cabal install tagsoup
</code></pre>
<p>De <code>tagsoup</code> package kan willekeurig rommelige HTML aan.</p>
<p>Het levert ons een lijst met events, vergelijkbaar met een SAX parser.</p>
</div>
<div class="slide">
<h1 id="omgaan-met-problemen">Omgaan met problemen</h1>
<p>Probeer dit:</p>
<pre class="haskell"><code>head [1]
</code></pre>
<p>Probeer nu dit:</p>
<pre class="haskell"><code>head []
</code></pre>
</div>
<div class="slide">
<h1 id="oei">Oei</h1>
<p>Als we een lege lijst aanleveren, levert de <code>head</code> functie een foutmelding.</p>
<p>Stel dat we een versie van <code>head</code> nodig hebben die <em>geen</em> foutmelding geeft.</p>
<pre class="haskell"><code>safeHead :: [a] -&gt; ????
</code></pre>
<p>Wat zou de <code>????</code> moeten zijn?</p>
<p>Laten we wat proberen.</p>
<pre class="haskell"><code>safeHead (x:xs) = Some x
safeHead []     = None
</code></pre>
</div>
<div class="slide">
<h1 id="some-none">Some? None?</h1>
<ul>
<li><p>We gebruiken een constructor met de naam <code>Some</code> om het idee te vangen: &quot;We hebben een resultaat&quot;.</p></li>
<li><p>De constructor <code>None</code> geeft aan: &quot;We hebben hier geen resultaat&quot;.</p></li>
</ul>
<p>Om deze constructors in het leven te roepen, definiëren we een nieuw type.</p>
<pre class="haskell"><code>data Perhaps a = Some a
               | None
</code></pre>
<p>Het <code>|</code> teken scheidt de constructors. We lezen het als volgt:</p>
<ul>
<li><p>Het <code>Perhaps</code> type kent twee constructors:</p></li>
<li><p><code>Some</code> gevolgd door één argument</p></li>
<li><p>of <code>None</code> zonder argumenten</p></li>
</ul>
</div>
<div class="slide">
<h1 id="maybe">Maybe</h1>
<p>Eigenlijk heeft Haskell al een <code>Perhaps</code> type.</p>
<pre class="haskell"><code>data Maybe a = Just a
             | Nothing
</code></pre>
<p>De <code>a</code> is een <em>type parameter</em>, met als betekenis dat als we dit type opschrijven, dat we dan een ander moeten toevoegen als parameter:</p>
<ul>
<li><p><code>Maybe Int</code></p></li>
<li><p><code>Maybe String</code></p></li>
</ul>
</div>
<div class="slide">
<h1 id="gebruik-maken-van-constructors">Gebruik maken van constructors</h1>
<p>Als we een <code>Maybe Int</code> willen samenstellen door gebruik te maken van de <code>Just</code> constructor, dan moeten we een <code>Int</code> meegeven.</p>
<pre class="haskell"><code>Just 1  :: Maybe Int
Nothing :: Maybe Int
</code></pre>
<p>Dit gaat niet werken, want de types komen niet overeen:</p>
<pre class="haskell"><code>Just [1] :: Maybe String
</code></pre>
</div>
<div class="slide">
<h1 id="pattern-matching-met-constructors">Pattern matching met constructors</h1>
<p>We kunnen pattern matchen met constructors van <code>Maybe</code> op dezelfde manier als dat we dat hebben gedaan voor lijsten.</p>
<pre class="haskell"><code>case foo of
  Just x  -&gt; x
  Nothing -&gt; bar
</code></pre>
</div>
<div class="slide">
<h1 id="tags">Tags</h1>
<p>Het <code>tagsoup</code> package definieert het volgende type:</p>
<pre class="haskell"><code>data Tag = TagOpen String [Attribute]
         | TagClose String
         | TagText String
         | TagComment String
         | TagWarning String
         | TagPosition Row Column
</code></pre>
<p>Wat denk je dat deze constructors kunnen betekenen?</p>
</div>
<div class="slide">
<h1 id="pattern-matching-over-een-tag">Pattern matching over een Tag</h1>
<p>Stel dat we een predikaat willen schrijven die aangeeft of een <code>Tag</code> een opening tag is.</p>
<ul>
<li><p>Wat zou het type van deze functie zijn?</p></li>
<li><p>Hoe zou de bode van de functie er uit zien?</p></li>
</ul>
</div>
<div class="slide">
<h1 id="om-het-even">Om het even!</h1>
<p>Onze eerste body zag er als volgt uit:</p>
<pre class="haskell"><code>isOpenTag (TagOpen x y)     = True
isOpenTag (TagClose x)      = False
isOpenTag (TagText x)       = False
isOpenTag (TagComment x)    = False
isOpenTag (TagWarning x)    = False
isOpenTag (TagPosition x y) = False
</code></pre>
<p>Begrijpbaar, maar lelijk.</p>
<ul>
<li><p>We zijn maar in precies één constructor geïnteresseerd.</p></li>
<li><p>We gebruiken de gedeclareerde variabelen <code>x</code> or <code>y</code> helemaal niet.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="het-wild-card-patroon">Het wild card patroon</h1>
<p>We kunnen met het &quot;<code>_</code>&quot; teken opschrijven dat het ons niet uitmaakt wat een patroon of variabele precies is.</p>
<pre class="haskell"><code>isOpenTag (TagOpen _ _) = True
isOpenTag  _            = False
</code></pre>
<p>Het wild card patroon matcht altijd.</p>
<ul>
<li><p>Aangezien we toch geen gebruik maken van <code>x</code> of <code>y</code>, kunnen we dat expliciet aangeven door gebruik te maken van <code>_</code>.</p></li>
<li><p>Aangezien elke constructor behalve <code>TagOpen</code> ons niets interesseert, kunnen we ze allemaal laten matchen met <code>_</code>.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="even-een-vraag-tussendoor">Even een vraag tussendoor</h1>
<p>Waarom schrijven we de functie niet op deze manier?</p>
<pre class="haskell"><code>isOpenTag  _            = False
isOpenTag (TagOpen _ _) = True
</code></pre>
</div>
<div class="slide">
<h1 id="extractie-van-de-links-van-een-webpagina">Extractie van de links van een webpagina</h1>
<p>Stel dat we al een pagina geladen hebben.</p>
<ul>
<li><p>Bekijk de <code>tagsoup</code> documentatie in de module <code>Text.HTML.TagSoup</code> .</p></li>
<li><p>Zoek een functie die een webpagina parsed in een serie tags.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="die-kunnen-we-mooi-gebruiken">Die kunnen we mooi gebruiken!</h1>
<pre class="haskell"><code>processPage url = do
  page &lt;- download url
  return (parseTags page)
</code></pre>
</div>
<div class="slide">
<h1 id="tags-opschonen">Tags opschonen</h1>
<p>De geparsede tags kunnen verschillende soorten tag namen hebben.</p>
<pre><code>&lt;A HREF=&quot;...&quot;&gt;
</code></pre>
<pre><code>&lt;a hrEF=&quot;...&quot;&gt;
</code></pre>
<ul>
<li>Zoek een <code>tagsoup</code> functie die tag namen en attributen omzet in kleine letters.</li>
</ul>
</div>
<div class="slide">
<h1 id="tags-in-normaalvorm">Tags in normaalvorm</h1>
<p>Laten we onze functie gebruiken om het resultaat van <code>parseTags</code> op te schonen.</p>
<pre class="haskell"><code>processPage url = do
  page &lt;- download url
  return
    (canonicalizeTags
      (parseTags page))
</code></pre>
</div>
<div class="slide">
<h1 id="extractie-van-links">Extractie van links</h1>
<p>We zijn alleen geïnteresseerd in open tags die links bevatten, dus <code>&lt;a&gt;</code> tags.</p>
<ul>
<li><p>Hoe zouden we het type functie schrijven die aangeeft of een <code>Tag</code> een open tag is met de juiste naam?</p></li>
<li><p>Hoe zouden we die functie gebruiken om alleen de open tags over te houden van een lijst van geparsede tags?</p></li>
</ul>
</div>
<div class="slide">
<h1 id="poeh-hee">Poeh hee!</h1>
<p>Deze cascade begint belachelijke vormen te krijgen.</p>
<pre class="haskell"><code>processPage url = do
  page &lt;- download url
  return
    (filter (isTagOpenName &quot;a&quot;)
      (canonicalizeTags
        (parseTags page)))
</code></pre>
<p>Twee observaties:</p>
<ul>
<li><p>Onze actie is nu voor het merendeel pure code.</p></li>
<li><p>Het lijkt wel een pijplijn.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="een-herschrijf-oefening">Een herschrijf oefening</h1>
<p>Verdeel de functie in pure en niet-pure delen.</p>
<p>Schrijf het pure gedeelte met gebruikmaking van functie compositie.</p>
<pre class="haskell"><code>processPage url = do
  page &lt;- download url
  return
    (filter (isTagOpenName &quot;a&quot;)
      (canonicalizeTags
        (parseTags page)))
</code></pre>
</div>
<div class="slide">
<h1 id="mijn-oplossing">Mijn oplossing</h1>
<pre class="haskell"><code>processPage url = do
  page &lt;- download url
  return (process page)

process =
    filter (isTagOpenName &quot;a&quot;) .
    canonicalizeTags .
    parseTags
</code></pre>
</div>
<div class="slide">
<h1 id="we-willen-nog-meer-kwijt">We willen nog meer kwijt</h1>
<p>Laten we de <code>nofollow</code> links ook weglaten.</p>
<p>We willen het <code>&quot;rel&quot;</code> attribuut van een tag.</p>
<ul>
<li>Zoek een functie die een attribuut van een tag teruggeeft.</li>
</ul>
</div>
<div class="slide">
<h1 id="geen-following">Geen following</h1>
<pre class="haskell"><code>nofollow tag = fromAttrib &quot;rel&quot; tag == &quot;nofollow&quot;
</code></pre>
<pre class="haskell"><code>process =
    filter (not . nofollow) .
    filter (isTagOpenName &quot;a&quot;) .
    canonicalizeTags .
    parseTags
</code></pre>
</div>
<div class="slide">
<h1 id="we-hebben-een-lijst-met-a-tags">We hebben een lijst met &lt;a&gt; tags</h1>
<p>Hoe zouden we het <code>&quot;href&quot;</code> attribuute ophalen van elk element uit de lijst?</p>
</div>
<div class="slide">
<h1 id="allen-niet-lege-a-href-tags">Allen niet-lege &lt;a href&gt; tags</h1>
<pre class="haskell"><code>process =
    filter (not . null) .
    map (fromAttrib &quot;href&quot;) .
    filter (not . nofollow) .
    filter (isTagOpenName &quot;a&quot;) .
    canonicalizeTags .
    parseTags
</code></pre>
</div>
<div class="slide">
<h1 id="urls-in-normaalvorm">URLs in normaalvorm</h1>
<p>Links kunnen absoluut, relatief of onzinnige rommel zijn. We willen alleen maar absolute links die er geldig uitzien.</p>
<p>Om netjes een absolute link te maken moeten we de absolute URL kennen van de pagina waar we naar kijken.</p>
<pre class="haskell"><code>canonicalizeLink :: String -&gt; String -&gt; Maybe String
</code></pre>
</div>
<div class="slide">
<h1 id="werken-met-uris">Werken met URIs</h1>
<p>Het package <code>Network.URI</code> bevat een paar functies die hier goed van pas komen.</p>
<pre class="haskell"><code>parseURI :: String -&gt; Maybe URI
parseURIReference :: String -&gt; Maybe URI
uriToString id &quot;&quot; :: URI -&gt; String
nonStrictRelativeTo :: URI -&gt; URI -&gt; Maybe URI
</code></pre>
</div>
<div class="slide">
<h1 id="een-draak-van-een-inspringer">Een draak van een inspringer</h1>
<p>Dit is niet meer om te lezen!</p>
<pre class="haskell"><code>import Network.URI

canon :: String -&gt; String -&gt; Maybe String
canon referer path =
  case parseURI referer of
    Nothing -&gt; Nothing
    Just r  -&gt;
      case parseURIReference path of
        Nothing -&gt; Nothing
        Just p  -&gt;
          case nonStrictRelativeTo p r of
            Nothing -&gt; Nothing
            Just u -&gt;
             Just (uriToString id u &quot;&quot;)
</code></pre>
<p>Dat kan vast beter.</p>
</div>
<div class="slide">
<h1 id="traplopen">Traplopen</h1>
<p>Is het je opgevallen dat die functie een serie is van met <code>case</code> inspecties van <code>Maybe</code> waarden?</p>
<p>Stel je voor dat we een functie zouden hebben die een gewone waarde als input heeft, en die een <code>Maybe</code> waarde teruggeeft.</p>
<pre class="haskell"><code>a -&gt; Maybe b
</code></pre>
<p>En stel je voor dat we een begrijpbare syntax hebben om een anonieme functie te schrijven.</p>
<pre class="haskell"><code>\a -&gt; &quot;hoi mam! &quot; ++ a
</code></pre>
<p>De <code>\</code> noemen we &quot;lambda&quot;.</p>
</div>
<div class="slide">
<h1 id="observatie">Observatie</h1>
<p>De inspectie met <code>case</code> is nogal breedsprakig. Stel dat we een functie zouden hebben die de inspectie deed, en een andere functie zou aanroepen als de waarde een <code>Just</code> was.</p>
<pre class="haskell"><code>bind :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b
bind  Nothing      _     = Nothing
bind (Just value) action = action value
</code></pre>
</div>
<div class="slide">
<h1 id="het-gebruik-van-bind">Het gebruik van bind</h1>
<p>Hoe kunnen we dit gebruiken?</p>
<pre class="haskell"><code>canon1 referer path =
  parseURI referer                `bind`
   \r -&gt; parseURIReference path   `bind`
    \p -&gt; nonStrictRelativeTo p r `bind`
     \u -&gt; Just (uriToString id u &quot;&quot;)
</code></pre>
<p>Als we een functienaam omsluiten in &quot;`&quot;-tekens, dan kunnen we de functie als infix operator gebruiken.</p>
</div>
<div class="slide">
<h1 id="een-andere-layout-van-dezelfde-code">Een andere layout van dezelfde code</h1>
<pre class="haskell"><code>canon referer path =
  parseURI referer         `bind` \r -&gt;
  parseURIReference path   `bind` \p -&gt;
  nonStrictRelativeTo p r  `bind` \u -&gt;
  Just (uriToString id u &quot;&quot;)
</code></pre>
</div>
<div class="slide">
<h1 id="een-ingebouwde-naam-voor-bind">Een ingebouwde naam voor bind</h1>
<p>De <code>&gt;&gt;=</code> operator is een generieke versie van onze <code>bind</code> functie.</p>
<pre class="haskell"><code>canon referer path =
  parseURI referer &gt;&gt;= \r -&gt;
  parseURIReference path &gt;&gt;= \p -&gt;
  nonStrictRelativeTo p r &gt;&gt;= \u -&gt;
  Just (uriToString id u &quot;&quot;)
</code></pre>
</div>
<div class="slide">
<h1 id="gebruik-maken-van-vereenvoudigde-schrijfwijze">Gebruik maken van vereenvoudigde schrijfwijze</h1>
<p>Hier is wat nettere syntax, die je vast bekend voorkomt.</p>
<pre class="haskell"><code>canonicalize :: String -&gt; String -&gt; Maybe String

canonicalize referer path = do
  r &lt;- parseURI referer
  p &lt;- parseURIReference path
  u &lt;- nonStrictRelativeTo p r
  return (uriToString id u &quot;&quot;)
</code></pre>
</div>
<div class="slide">
<h1 id="bijna-klaar">Bijna klaar</h1>
<pre class="haskell"><code>process url =
   map (canonicalize url) .
   filter (not . null) .
   map (fromAttrib &quot;href&quot;) .
   filter (\t -&gt; fromAttrib &quot;rel&quot; t /= &quot;nofollow&quot;) .
   filter (isTagOpenName &quot;a&quot;) .
   canonicalizeTags .
   parseTags
</code></pre>
<p>Da's nou onhandig: wat is het type van deze functie?</p>
</div>
<div class="slide">
<h1 id="van-maybe-a-naar-a">Van [Maybe a] naar [a]</h1>
<p>Ga naar deze website:</p>
<ul>
<li><a href="http://haskell.org/hoogle">haskell.org/hoogle</a></li>
</ul>
<p>Typ dit in de search box:</p>
<pre class="haskell"><code>[Maybe a] -&gt; [a]
</code></pre>
<p>Wat zien we als eerste resultaat?</p>
</div>
<div class="slide">
<h1 id="klaar">Klaar!</h1>
<pre class="haskell"><code>import Data.Maybe
import Network.URI

links url =
  catMaybes .
  map (canonicalize url) .
  filter (not . null) .
  map (fromAttrib &quot;href&quot;) .
  filter (\t -&gt; fromAttrib &quot;rel&quot; t /= &quot;nofollow&quot;) .
  filter (isTagOpenName &quot;a&quot;) .
  canonicalizeTags .
  parseTags
</code></pre>
</div>
<div class="slide">
<h1 id="van-links-naar-spideren">Van links naar spideren</h1>
<p>Als we de links van een webpagina af kunnen halen, kunnen we eenvoudig een spider schrijven om die links te volgen.</p>
<p>Om het eenvoudig te houden, zetten we een limiet op het aantal pagina's dat we willen downloaden.</p>
<p>Welke informatie willen we genereren?</p>
<p>Wat willen we onderweg bijhouden?</p>
</div>
<div class="slide">
<h1 id="wat-we-willen-bijhouden">Wat we willen bijhouden</h1>
<p>De status die we willen bijhouden:</p>
<ul>
<li><p>Het aantal pagina's dat we hebben gedownload</p></li>
<li><p>Een verzameling pagina's waar we links naartoe hebben gezien, maar die we (nog) niet hebben gedownload</p></li>
<li><p>Een verzameling pagina's met hun uitgaande links</p></li>
</ul>
</div>
<div class="slide">
<h1 id="bijhouden-wat-we-gezien-hebben">Bijhouden wat we gezien hebben</h1>
<p>Voor een willekeurige pagina, willen we de pagina zelf bewaren en alle pagina's waar het naar verwijst.</p>
<p>Een mogelijkheid om deze twee te associeren is een <em>tuple</em>:</p>
<pre class="haskell"><code>(&quot;http://x.org/&quot;, [&quot;http://microsoft.com/&quot;])
</code></pre>
<p>Tuples zijn nuttig als we verschillende soorten data hebben zonder dat we het gedoe willen van het definieren van een nieuw type.</p>
<p>Nu we het toch over een nieuw type hebben, zo definieer je er een:</p>
<pre class="haskell"><code>data Link = Link String [String]

-- Let's define some accessors, too.
linkFrom (Link url _) = url
linkTo (Link _ links) = links
</code></pre>
</div>
<div class="slide">
<h1 id="dubbelingen-voork&#243;men">Dubbelingen voorkómen</h1>
<p>We willen een URL niet twee keer bezoeken.</p>
<p>Hoe voorkomen we dat?</p>
<pre class="haskell"><code>visited url = elem url . map linkTo
</code></pre>
<p>Deze functie heeft een probleem - zie je welk probleem?</p>
</div>
<div class="slide">
<h1 id="betere-performance">Betere performance</h1>
<p>We willen een structuur met een snelle opzoek operatie.</p>
<p>Wat zou je in jouw programmeertaal gebruiken?</p>
</div>
<div class="slide">
<h1 id="maps-and-importing">Maps and importing</h1>
<p>In Haskell bestaan muteerbare hash tables, maar die gebruiken we niet.</p>
<p>in plaats hiervan gebruiken we liever <em>onveranderlijke</em> key-value maps.</p>
<p>We moeten de nodige trucks uithalen bij het importeren, want de <code>Data.Map</code> module definieert veel namen die anders zouden overlappen met ingebouwde namen.</p>
<p>Dit betekent &quot;importeer alleen de naam <code>Map</code> van de module <code>Data.Map</code>&quot;:</p>
<pre class="haskell"><code>import Data.Map (Map)
</code></pre>
<p>En dit betekent &quot;importeer alles van <code>Data.Map</code>, maar elk van deze namen moet voorafgegaan worden door <code>Map.</code>&quot;:</p>
<pre class="haskell"><code>import qualified Data.Map as Map
</code></pre>
</div>
<div class="slide">
<h1 id="wat-is-het-nut-van-een-onveranderlijke-data-structuur">Wat is het nut van een onveranderlijke data structuur?</h1>
<p>Is iedereen bekend hoe je een key-value paar aan een hash tabel toevoegt?</p>
<p>En dat lijkt een fundamentele operatie.</p>
<p>Wat doen we met maps?</p>
<ul>
<li>Maak een <em>nieuwe</em> map die identiek is aan de map die we aanleveren, met het gevraagde element toegevoegd.</li>
</ul>
<p>Hoe kan dat nou werken? Is het efficient?</p>
</div>
<div class="slide">
<h1 id="een-hand-vol-dollars">Een hand vol dollars</h1>
<p>Hier is een verbazingwekkend handige ingebouwde operator:</p>
<pre class="haskell"><code>f $ x = f x
</code></pre>
<p>Waarom is dit nuttig? Omdat we hierdoor haakjes kunnen weglaten.</p>
<p>zonder $:</p>
<pre class="haskell"><code>explode k = error (&quot;failed on &quot; ++ show k)
</code></pre>
<p>met $:</p>
<pre class="haskell"><code>explode k = error $ &quot;failed on &quot; ++ show k
</code></pre>
</div>
<div class="slide">
<h1 id="partiele-toepassing">Partiele toepassing</h1>
<p>Dit is onhandig om op te schrijven:</p>
<pre class="haskell"><code>increment k = 1 + k
</code></pre>
<p>Bijna net zo erg:</p>
<pre class="haskell"><code>\k -&gt; 1 + k
</code></pre>
<p>Veel handiger, en identiek:</p>
<pre class="haskell"><code>(1+)
</code></pre>
<p>Dit is valide:</p>
<pre class="haskell"><code>increment = (1+)
</code></pre>
</div>
<div class="slide">
<h1 id="spideren-in-al-zijn-glans">Spideren, in al zijn glans</h1>
<pre class="haskell"><code>spider :: Int -&gt; URL -&gt; IO (Map URL [URL])
spider count url0 = go 0 Map.empty (Set.singleton url0)
  where
    go k seen queue0
        | k &gt;= count = return seen
        | otherwise  =
      case Set.minView queue0 of
        Nothing -&gt; return seen
        Just (url, queue) -&gt; do
          page &lt;- download url
          let ls       = links url page
              newSeen  = Map.insert url ls seen
              notSeen  = Set.fromList .
                         filter (`Map.notMember` newSeen) $ ls
              newQueue = queue `Set.union` notSeen
          go (k+1) newSeen newQueue
</code></pre>
</div>
<div class="slide">
<h1 id="stand-van-zaken">Stand van zaken?</h1>
<p>We kunnen nu:</p>
<ul>
<li><p>Een webpagina downloaden</p></li>
<li><p>De links ervan extraheren</p></li>
<li><p>van daar uit verder <code>spideren</code>, zonder doublures</p></li>
</ul>
<p>Wat blijft over?</p>
<ul>
<li><p>We zouden meerdere pagina's tegelijkertijd kunnen spideren</p></li>
<li><p>Of we zouden kunnen berekenen welke pagina's &quot;belangrijk&quot; zijn</p></li>
</ul>
</div>
<div class="slide">
<h1 id="fin">Fin</h1>
<p>In het hoogst onwaarschijnlijke geval dat we hier aankomen voordat we uit de tijd zijn gelopen, gaam we verder in een we-zien-wel-wat-voor-avontuur sessie.</p>
<p>Bedankt dat je tot nu toe niet bent afgehaakt!</p>
</div>
<div class="slide">
<h1 id="deze-slides-zijn-herbruikbaar-als-je-wilt">Deze slides zijn herbruikbaar, als je wilt:</h1>
<pre><code>git clone https://github.com/hanjoosten/HaskellWorkshop
</code></pre>
</div>
</body>
</html>
