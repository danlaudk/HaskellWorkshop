<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Han Joosten" />
  <meta name="date" content="7 maart 2012" />
  <title>Functioneel Programmeren met Haskell</title>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js.gz"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Functioneel Programmeren met Haskell</h1>
  <p class="author">
Han Joosten<br/><code>han.joosten.han@gmail.com</code><br/>
  </p>
  <p class="date">7 maart 2012</p>
</div>
<div class="slide">
<h1 id="welkom">Welkom!</h1>
<pre class="haskell"><code>main = putStrLn &quot;hallo!&quot;
</code></pre>
<ul>
<li><p>Mijn naam is Han Joosten</p></li>
<li><p>Ik ben Requirements Engineer bij TS Noord</p></li>
<li><p>Begonnen met Haskell ca. 2006</p></li>
<li><p>Ik help mee bij een open source project</p>
<ul>
<li><a href="http://ampersand.sourceforge.net">ampersand.sourceforge.net</a></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="achtergrond-in-functioneel-programmeren">Achtergrond in (functioneel) programmeren</h1>
<p>ik ben in aanraking gekomen met functionele talen op de universiteit</p>
<pre><code>* Twentel, Miranda, Lisp
</code></pre>
<p>Diverse specificatie talen:</p>
<pre><code>* Lotos, ASF+SDF, Typol, LaTeX
</code></pre>
<p>Na mijn afstuderen in 1990 heb ik geprogrammeerd in iteratieve talen</p>
<pre><code>* Pascal, C, Perl, Rexx, Cool:Gen (integrated Case tool)
</code></pre>
<ul>
<li><p>Mijn interesse voor Haskell werd gewekt rond 2006</p></li>
<li><p>Haskell is een volwassen allround programmeertaal</p></li>
<li><p>Haskell community is heel behulpzaam</p></li>
</ul>
</div>
<div class="slide">
<h1 id="over-deze-presentatie">Over deze presentatie</h1>
<ul>
<li><p>Reden: Omdat ik enthousiast ben over Functioneel Programmeren</p></li>
<li><p>Doel: Enthousiasmeren van jullie</p></li>
<li><p>Over deze sheets: gepikt van Bryan O'Sullivan</p></li>
</ul>
</div>
<div class="slide">
<h1 id="wat-kan-je-verwachten-1">Wat kan je verwachten 1</h1>
<ul>
<li><p>Haskell is een behoorlijk uitgebreide taal</p></li>
<li><p>Omdat er veel onbekend is voor nieuwkomers, kan je er van uit gaan dat je ver van je comfort-zone zal geraken</p></li>
<li><p>Ik ga je <em>interessante</em> dingen leren, maar niet <em>alles</em></p></li>
</ul>
</div>
<div class="slide">
<h1 id="wat-kan-je-verwachten-2">Wat kan je verwachten 2</h1>
<ul>
<li><p>Dit is een <em>hands-on</em> workshop: je gaat zelf code schrijven!</p></li>
<li><p>Na ongeveer een uur is er een korte pauze</p></li>
<li><p>Schroom niet! Stel gerust vragen!</p></li>
</ul>
</div>
<div class="slide">
<h1 id="je-gereedschap">Je gereedschap</h1>
<ul>
<li><p>Je hebt het Haskell Platform al geïnstalleerd als het goed is.</p>
<ul>
<li><a href="http://hackage.haskell.org/platform/">hackage.haskell.org/platform</a></li>
</ul></li>
<li><p>We hebben nu een super gereedschapskist</p>
<ul>
<li><p>De GHC compiler (<code>ghc</code>)</p></li>
<li><p>De GHCi interpreter (<code>ghci</code>)</p></li>
<li><p>De Cabal package manager (<code>cabal</code>)</p></li>
<li><p>Enkele handige libraries en tools</p></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="wat-hebben-we-nog-meer-nodig">Wat hebben we nog meer nodig?</h1>
<ul>
<li><p>Een text editor</p></li>
<li><p>Een terminal window</p></li>
</ul>
</div>
<div class="slide">
<h1 id="probleemstelling">Probleemstelling</h1>
<p>Gegeven een website. We willen er data afhalen (web-scraping) en er andere belangrijke web pagina's mee vinden.</p>
<p>Er valt dan ook veel uit te zoeken!</p>
<ol style="list-style-type: decimal">
<li><p>Haskell leren</p></li>
<li><p>Een web pagina downloaden</p></li>
<li><p>De links van een pagina halen, zodat we meer pagina's kunnen vinden om te downloaden</p></li>
<li><p>Als we zo ver zijn, bepalen we de pagina's die relevant zijn</p></li>
<li><p>en ook nog een beetje snel?</p></li>
</ol>
</div>
<div class="slide">
<h1 id="aan-de-slag">Aan de slag!</h1>
<p>Maak een file <code>Hello.hs</code> met de volgende inhoud:</p>
<pre class="haskell"><code>main = putStrLn &quot;hello, world!&quot;
</code></pre>
<p>De extentie <code>.hs</code> is de standaard voor Haskell source files.</p>
<p>De naam van een bestand begint met een hoofdletter en iedereen gebruikt <code>CamelCase</code>.</p>
</div>
<div class="slide">
<h1 id="vertalen">Vertalen</h1>
<p>Dit commando zoekt naar <code>Hello.hs</code> in de huidige directory, en vertaalt het:</p>
<pre><code>ghc --make Hello
</code></pre>
<p>Het gegenereerde programma heet <code>Hello</code> (<code>Hello.exe</code> op Windows).</p>
<ul>
<li>De <code>--make</code> optie zorgt er voor dat GHC de afhankelijkheden met andere bestanden en packages automatisch afhandelt.</li>
</ul>
</div>
<div class="slide">
<h1 id="even-controleren">Even controleren</h1>
<p>Is het iedereen gelukt om hun <code>Hello</code> programma te genereren en uit te voeren?</p>
</div>
<div class="slide">
<h1 id="en-nu-wat-handiger">En nu wat handiger</h1>
<p>Het is prettig om snelle, goede code te hebben.</p>
<p>maar als <em>ik</em> programmeer, dan:</p>
<ul>
<li><p>moet ik vaak nog veel uitzoeken.</p></li>
<li><p>ik maak best veel fouten.</p></li>
</ul>
<p>In deze omstandigheden werkt een echte compiler vertragend.</p>
<p>Er is daarom een interactieve interpreter, <code>ghci</code>.</p>
</div>
<div class="slide">
<h1 id="aan-de-slag-met-ghci">Aan de slag met GHCi</h1>
<p>Simpel genoeg:</p>
<pre><code>ghci
</code></pre>
<p>Er verschijnt wat opstart-tekst, gevolgd door de prompt:</p>
<pre><code>GHCi, version 7.0.3: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Loading package ffi-1.0 ... linking ... done.
Prelude&gt;
</code></pre>
<p>Deze standaard prompt vertelt ons welke modules er beschikbaar zijn om mee te spelen.</p>
</div>
<div class="slide">
<h1 id="spelen-met-ghci">Spelen met GHCi</h1>
<p>De <code>ghci</code> interpreter evalueert interactief expressies.</p>
<p>Probeer nu zelf:</p>
<pre class="haskell"><code>2 + 2
</code></pre>
<pre class="haskell"><code>123456781234567812345678 * 87654321876543
</code></pre>
<pre class="haskell"><code>&quot;foo&quot; ++ &quot;bar&quot;
</code></pre>
<p>(De <code>++</code> is de &quot;append&quot; operator.)</p>
</div>
<div class="slide">
<h1 id="interpreter-commandos">Interpreter commando's</h1>
<p>Alle interpreter commando's beginnen met een &quot;<code>:</code>&quot; teken.</p>
<p>Laten we ons programma in <code>ghci</code> laden:</p>
<pre><code>:load Hello.hs
</code></pre>
<p>De <code>ghci</code> prompt verandert:</p>
<pre><code>*Main&gt;
</code></pre>
</div>
<div class="slide">
<h1 id="onze-code-uitvoeren-met-ghci">Onze code uitvoeren met ghci</h1>
<p>We hebben een functie met de naam <code>main</code> gedefinieerd. Voer het nu uit:</p>
<pre><code>main
</code></pre>
<p>Is het gelukt?</p>
<p>En wat zou dit doen?</p>
<pre class="haskell"><code>putStrLn &quot;hoi mam!&quot;
</code></pre>
</div>
<div class="slide">
<h1 id="enkele-van-de-nuttigste-commandos">Enkele van de nuttigste commando's</h1>
<p>Onthoud dat alle <code>ghci</code> commando's met een &quot;<code>:</code>&quot; beginnen.</p>
<ul>
<li><p><code>:help</code> toont welke commando's we tot onze beschikking hebben.</p></li>
<li><p><code>:reload</code> laden van het bestand dat het laatst is ge<code>:load</code>.</p></li>
<li><p><code>:edit</code> opent de tekst editor met het bestand dat het laatst is ge<code>:load</code>. (echter <em>niet</em> automatische <code>:reload</code>.)</p></li>
<li><p><code>:quit</code> beëindigt <code>GHCi</code>.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="enkele-ghci-efficiency-tips">Enkele ghci efficiency tips</h1>
<p>We kunnen commando's afkorten:</p>
<ul>
<li><p><code>:e</code> is synoniem voor <code>:edit</code></p></li>
<li><p><code>:r</code> is <code>:reload</code></p></li>
</ul>
<p>We hebben ook historie en command line editing.</p>
<ul>
<li><p>Op Unix, vergelijkbaar met <code>readline</code>.</p></li>
<li><p>Op Windows, zelfde als <code>cmd.exe</code>.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="gewenning-aan-de-cyclus">Gewenning aan de cyclus</h1>
<p>Gebruik <code>:edit</code> of je tekst editor om de &quot;hello&quot; tekst aan te passen.</p>
<p>Gebruik <code>:reload</code> om je bestand opnieuw te laden.</p>
<p>Test je nieuwe definitie van <code>main</code>.</p>
<ul>
<li>Oefening: Gebruik de &quot;pijl omhoog&quot; toets om door je commando historie te gaan totdat je terug komt op de laatste keer dat je <code>main</code> typte.</li>
</ul>
</div>
<div class="slide">
<h1 id="lijsten-en-strings">Lijsten en Strings</h1>
<pre class="haskell"><code>[1,2,3,4]
</code></pre>
<pre class="haskell"><code>['h','e','l','l','o']
</code></pre>
<p>Dubbele haakjes zijn alleen maar een verkorte schrijfwijze voor de langere vorm:</p>
<pre class="haskell"><code>&quot;hello&quot;
</code></pre>
<p>Wat zou dit als resultaat opleveren?</p>
<pre class="haskell"><code>&quot;foo&quot; == ['f','o','o']
</code></pre>
</div>
<div class="slide">
<h1 id="functies-aanroepen-1">Functies aanroepen: 1</h1>
<p>We gebruiken spaties om de functie van zijn argumenten te scheiden:</p>
<pre class="haskell"><code>head &quot;foo&quot;
</code></pre>
<pre class="haskell"><code>head [1,2,3]
</code></pre>
<pre class="haskell"><code>tail [1,2,3]
</code></pre>
</div>
<div class="slide">
<h1 id="functies-aanroepen-2">Functies aanroepen: 2</h1>
<p>Bij meerdere argumenten, worden alle argumenten onderling gescheiden door spaties:</p>
<pre class="haskell"><code>min 3 4
</code></pre>
<p>Als een argument zelf een samengestelde expressie is, moeten er haken omheen:</p>
<pre class="haskell"><code>compare (3+5) (2+7)
</code></pre>
<pre class="haskell"><code>max (min 3 4) 5
</code></pre>
</div>
<div class="slide">
<h1 id="zelf-doen-1">Zelf doen: 1</h1>
<p>Gebruik <code>ghci</code> als een rekenmachine.</p>
<p>De <code>**</code> operator is voor machtsverheffen.</p>
<ul>
<li>Als ik 5 FT's investeer met 3% samengestelde rente per jaar, hoeveel FT's heb ik dan na 10 jaar?</li>
</ul>
</div>
<div class="slide">
<h1 id="zelf-doen-2">Zelf doen: 2</h1>
<p>De notatie <code>['a'..'z']</code> genereert een lijst van start tot eind, inclusief.</p>
<p>De <code>sum</code> functie sommeert alle elementen in een lijst.</p>
<ul>
<li>Wat is de som van de getallen tussen 9 en 250, inclusief, <em>minus</em> 2?</li>
</ul>
</div>
<div class="slide">
<h1 id="zelf-doen-3">Zelf doen: 3</h1>
<p>De <code>show</code> functie toont een waarde als een String. Probeer maar!</p>
<pre class="haskell"><code>show (1 == 2)
</code></pre>
<p>De <code>length</code> functie geeft ons het aantal elementen in een lijst.</p>
<pre class="haskell"><code>length [1,2,3]
</code></pre>
<ul>
<li>Uit hoeveel cijfers bestaat het product van alle getallen tussen 0xBE en 0xEF, inclusief?</li>
</ul>
</div>
<div class="slide">
<h1 id="zelf-functies-defini&#235;ren">Zelf functies definiëren</h1>
<p>Zelf functies definiëren is best eenvoudig.</p>
<p>Open je tekst editor, maak een nieuw bestand met de <code>.hs</code> extentie, en begin te schrijven:</p>
<pre class="haskell"><code>isOdd x  =  (rem x 2) == 1
</code></pre>
<ul>
<li><p>We beginnen met de naam van de functie.</p></li>
<li><p>Vervolgens komen de namen van de parameter(s) die we willen, gescheiden door spaties.</p></li>
<li><p>Dan komt een enkel <code>=</code> teken, waarachter de <em>body</em> van de functie volgt.</p></li>
</ul>
<p>Laad je bestand in <code>ghci</code> en probeer <code>myOdd</code> maar eens uit.</p>
</div>
<div class="slide">
<h1 id="smaakmakers">Smaakmakers</h1>
<p>Nu kunnen we heel eenvoudige functies maken, maar we missen belangrijke ingredienten voor het echte werk.</p>
<p>Dus, waar wachten we op!</p>
</div>
<div class="slide">
<h1 id="conditionele-uitvoering">Conditionele uitvoering</h1>
<p>Q: Hoe ziet de bekende <code>if</code> er uit in Haskell?</p>
<p>A: Bekend!</p>
<pre class="haskell"><code>ggd a b = if b == 0
          then a
          else ggd b (rem a b)
</code></pre>
<p>We hebben de volgende elementen:</p>
<ul>
<li><p>Een Boolean expressie</p></li>
<li><p><code>then</code> een expressie die het resultaat is als de Boolean <code>True</code> is</p></li>
<li><p><code>else</code> een expressie die het resultaat is als de Boolean <code>False</code> is</p></li>
</ul>
</div>
<div class="slide">
<h1 id="eindelijk-een-klein-beetje-over-types">Eindelijk! Een klein beetje over types</h1>
<p>De twee mogelijke resultaat expressies van een <code>if</code> expressie moeten hetzelfde type hebben.</p>
<p>Als <code>then</code> een <code>String</code> oplevert, dan moet <code>else</code> dat ook doen!</p>
<p>Het volgende voorbeeld is natuurlijk onzin:</p>
<pre class="haskell"><code>if True
then 3.14
else &quot;wombat&quot;
</code></pre>
<p>Dit soort onzin-typering is in Haskell verboden.</p>
</div>
<div class="slide">
<h1 id="wat-nog-meer-over-else">Wat nog meer over else?</h1>
<p>In imperatieve talen kunnen we meestal het <code>else</code> deel na de <code>if</code> weglaten.</p>
<p>Maar niet in Haskell.</p>
<p>Waarom kan dit wel bij imperatieve talen, en niet in Haskell?</p>
</div>
<div class="slide">
<h1 id="een-bijna-triviale-oefening">Een bijna triviale oefening</h1>
<p>Schrijf een functie met als resultaat het argument met daarachter <code>&quot;, world&quot;</code> geplakt, als dat argument <code>&quot;hello&quot;</code> is, of alleen maar het onveranderde argument in andere gevallen.</p>
<ul>
<li>Oh ja, De &quot;append&quot;-functie luistert naar de naam <code>++</code>.</li>
</ul>
</div>
<div class="slide">
<h1 id="lijsten-in-haskell">Lijsten in Haskell</h1>
<p>We weten al hoe een lijst er in Haskell uitziet:</p>
<pre class="haskell"><code>[1,2,3]
</code></pre>
<p>En natuurlijk de verkorte schrijfwijze voor Strings:</p>
<pre class="haskell"><code>&quot;foo&quot; == ['f','o','o']
</code></pre>
<p>Maar is dit alles wat er valt te weten?</p>
</div>
<div class="slide">
<h1 id="lijst-constructors">Lijst constructors</h1>
<p>Stel dat we een lijst van de gront af aan willen opbouwen.</p>
<ul>
<li><p>We schrijven de <em>lege lijst</em> als <code>[]</code>.</p></li>
<li><p>Gegeven een bestaande lijst, kunnen we een ander element aan het <em>begin</em> van de lijst toevoegen met behulp van de <code>:</code> operator.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="typ-dit-in-ghci">Typ dit in ghci</h1>
<p>Voeg een element toe aan een lege lijst:</p>
<pre class="haskell"><code>1 : []
</code></pre>
</div>
<div class="slide">
<h1 id="en-nu-verder-vanaf-lijsten-met-&#233;&#233;n-element">En nu verder vanaf lijsten met één element</h1>
<p>Hoe breiden we zo'n lijst uit?</p>
<pre class="haskell"><code>2 : (1 : [])
</code></pre>
<p>Je hebt vaste wel geraden dat <code>[2,1]</code> een verkorte schrijfwijze is voor <code>2:(1:[])</code>. En dat is inderdaad zo!</p>
<p>Wat is het resultaat van deze expressie?</p>
<pre class="haskell"><code>5 : 8 : [] == [5,8]
</code></pre>
</div>
<div class="slide">
<h1 id="constructors">Constructors</h1>
<p>We refereren aan <code>[]</code> en <code>:</code> als <em>constructors</em>, omdat we ze gebruiken om lijsten mee te constureren.</p>
<p>Als je een lijst maakt, moet de Haskell runtime onthouden welke constructors je hebt gebruikt, en waar precies.</p>
<p>Dus de waarde <code>[5,8]</code> wordt gerepresenteerd als:</p>
<ul>
<li><p>Een <code>:</code> constructor, met <code>5</code> als zijn eerste argument, en als tweede ...</p></li>
<li><p>Nog een <code>:</code> constructor, deze keer met <code>8</code> als zijn eerste argument, en nu als tweede ...</p></li>
<li><p>Een <code>[]</code> constructor.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="wat-zagen-we-zojuist">Wat zagen we zojuist?</h1>
<p>Afhankelijk van je achtergrond, dacht je waarschijnlijk iets als:</p>
<ul>
<li><p>&quot;Hee! Haskell lijsten lijken op enkelvoudig gelinkte lijsten!&quot;</p></li>
<li><p>&quot;Hee! Dat lijkt op de <code>cons</code> cellen van Lisp!&quot;</p></li>
</ul>
<p>Inderdaad.</p>
</div>
<div class="slide">
<h1 id="waarom-zouden-we-ons-druk-maken-om-constructors">Waarom zouden we ons druk maken om constructors?</h1>
<p>Haskell moet natuurlijk onthouden hoe een lijst is opgebouwd.</p>
<p>Het laat <em>ons</em> ook een lijst inspecteren, zodat we kunnen nagaan welke contstructors er gebruikt zijn.</p>
<p>Hoe doen we dat?</p>
<pre class="haskell"><code>import Data.Char

isCapitalized name
  = case name of
      (first:rest) -&gt; isUpper first
      []           -&gt; False
</code></pre>
</div>
<div class="slide">
<h1 id="de-case-expressie">De case-expressie</h1>
<p>De <code>case</code> expressie laat ons een structuur <em>inspecteren</em>.</p>
<pre class="haskell"><code>isCapitalized name
  = case name of
      []           -&gt; False
      (first:rest) -&gt; isUpper first
</code></pre>
<ul>
<li>Tussen <code>case</code> en <code>of</code> staat de te inspecteren expressie.</li>
<li>Als de structuur overeenkomt met de lege-lijst constructor <code>[]</code>, dan is de structuur <code>name</code> die we inspecteren leeg. Dus geen hoofdletter.</li>
</ul>
<p>Als de gebruikte constructor de &quot;aan de voorkant toevoegen&quot; <code>:</code> operator is, dan wordt het interessanter.</p>
<ul>
<li>Wat er ook maar als eerste argument gebruikt is voor de <code>:</code> constructor wordt gebonden aan de naam <code>first</code>.</li>
<li>Het tweede argument van de <code>:</code> constructor (dus alles in de lijst na het eerste element) wordt gebonden aan de naam <code>rest</code>.</li>
<li>De expressie volgend op <code>-&gt;</code> wordt ge-evalueerd met deze waarden.</li>
</ul>
</div>
<div class="slide">
<h1 id="pattern-matching">Pattern matching</h1>
<p>Wat de <code>case</code> expressie doet, noemen we <em>pattern matching</em>.</p>
<ul>
<li><p>Patronen worden gecontroleerd van boven naar beneden.</p></li>
<li><p>Zodra een een patroon 'matcht', wordt het rechter deel (het deel achter de <code>-&gt;</code>) gebruikt als het resultaat van de hele <code>case</code> expressie.</p></li>
<li><p>Als geen enkel patroon 'matcht', ontstaat een exceptie.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="een-voorbeeld">Een voorbeeld</h1>
<p>Laten we stap voor stap kijken wat er gebeurt als we deze expressie evalueren.</p>
<pre class="haskell"><code>isCapitalized &quot;Ann&quot;
</code></pre>
</div>
<div class="slide">
<h1 id="whew-een-paar-oefeningen">Whew! Een paar oefeningen!</h1>
<p>Eindelijk! We kunnen nu iets ingewikkelder functies schrijven.</p>
<p>Nu je het begin van een lijst kan inspecteren, zou je een <em>hele</em> lijst recursief kunnen afhandelen.</p>
<p>Schrijf eerst een functie met de naam <code>myLength</code> die het aantal elementen in een lijst bepaalt.</p>
<p>Vervolgens schrijf je een functie met de naam <code>countCaps</code> die het aantal hoofdletters in een String bepaalt.</p>
<pre class="haskell"><code>countCaps &quot;Monkey Butter&quot; == 2
</code></pre>
</div>
<div class="slide">
<h1 id="het-tellen-van-hoofdletters">Het tellen van Hoofdletters</h1>
<p>Jôh, die countCaps functie was knap lastig. Of niet?</p>
<p>Hier is mijn definitie, gebruik makend van alleen de dingen die we tot nu toe hebben geleerd:</p>
<pre class="haskell"><code>countCaps string =
  case string of
    []     -&gt; 0
    (x:xs) -&gt; if isUpper x
              then 1 + countCaps xs
              else countCaps xs
</code></pre>
</div>
<div class="slide">
<h1 id="huh.">Huh.</h1>
<p>Ik dacht dat Haskell zo beknopt was!?</p>
</div>
<div class="slide">
<h1 id="beknoptheid-1-top-level-pattern-matching">Beknoptheid 1: top-level pattern matching</h1>
<pre class="haskell"><code>countCaps []     = 0
countCaps (x:xs) =
    if isUpper x
    then 1 + countCaps xs
    else countCaps xs
</code></pre>
<p>We kunnen een functie definieren als een serie vergelijkingen, die elk een <code>pattern match</code> bevatten.</p>
<p>Dit is een beknopte schrijfwijze voor <code>case</code>.</p>
</div>
<div class="slide">
<h1 id="beknoptheid-2-guards">Beknoptheid 2: guards</h1>
<pre class="haskell"><code>countCaps []     = 0
countCaps (x:xs)
   | isUpper x    = 1 + countCaps xs
   | otherwise    = countCaps xs
</code></pre>
<p>Achter elke <code>|</code> staat een <em>guard</em>.</p>
<ul>
<li><p>Als een patroon matcht, evalueren we iedere Boolean guard expressie van boven naar beneden.</p></li>
<li><p>Zodra er een succes heeft, evalueren we de rechterkant als de <code>body</code> van de functie.</p></li>
</ul>
<p>(Jazeker, pattronen in een <code>case</code> kunnen ook guards hebben.)</p>
</div>
<div class="slide">
<h1 id="v&#243;&#243;r">Vóór</h1>
<p>Zoals in de originele versie, maar nu zonder gebruik van <code>case</code>:</p>
<pre class="haskell"><code>countCaps xs =
  if null xs
  then 0 
  else if isUpper (head xs)
       then 1 + countCaps (tail xs)
       else countCaps (tail xs)
</code></pre>
</div>
<div class="slide">
<h1 id="na">Na</h1>
<p>Zowel korter als eenvoudiger te begrijpen:</p>
<pre class="haskell"><code>countCaps []     = 0
countCaps (x:xs)
   | isUpper x    = 1 + countCaps xs
   | otherwise    = countCaps xs
</code></pre>
</div>
<div class="slide">
<h1 id="een-andere-aanpak">Een andere aanpak</h1>
<p>Schrijf een nieuwe versie van <code>countCaps</code>:</p>
<ul>
<li><p>Schrijf een functie die door een lijst loopt, en die een nieuwe lijst genereert bestaande uit alleen de hoofdletters van de oorspronkelijke lijst.</p></li>
<li><p>Gebruik <code>length</code> om het aantal elementen te tellen.</p></li>
</ul>
<p>Dit zou hetzelfde resultaat moeten opleveren als je eerste functie. Toch?</p>
</div>
<div class="slide">
<h1 id="wijziging-van-de-specificatie">Wijziging van de specificatie</h1>
<p>Stel dat we het aantal kleine letters in een string willen tellen.</p>
<p>Dit lijkt bijna hetzelfde als onze functie om hoofletters te tellen.</p>
<p>Wat kunnen we doen met deze observatie?</p>
</div>
<div class="slide">
<h1 id="hogere-orde-functies">Hogere orde functies</h1>
<p><em>Hogere orde functie</em>: een functie die een andere functie accepteert als argument.</p>
<pre class="haskell"><code>filter pred [] = []
filter pred (x:xs)
  | pred x     = x : filter pred xs
  | otherwise  =     filter pred xs
</code></pre>
<p>Hoe kunnen we dit gebruiken om <code>countLowerCase</code> te definieren?</p>
</div>
<div class="slide">
<h1 id="data-in-data-uit">Data in, data uit</h1>
<p>Tot nu toe hebben we verschillende definities gezien zoals deze:</p>
<pre class="haskell"><code>countLowerCase string =
  length (filter isLower string)
</code></pre>
<p>We zien hierin een terugkerend pattroon:</p>
<ul>
<li><p>Een functie met één argument</p></li>
<li><p>krijgt als input het resultaat van ...</p></li>
<li><p>... een andere functie met één argument</p></li>
</ul>
</div>
<div class="slide">
<h1 id="functie-compositie">Functie compositie</h1>
<p>Haskell beperkt ons niet tot alleen maar alfanumerieke namen voor functies.</p>
<p>We kunnen een functie definiëren met de simpele naam &quot;<code>.</code>&quot;, die we als een operator kunnen gebruiken:</p>
<pre class="haskell"><code>(f . g) x = f (g x)
</code></pre>
<p>Wat is hier het nut van?</p>
<pre class="haskell"><code>countLowerCase = length . filter isLower
</code></pre>
</div>
<div class="slide">
<h1 id="compositie">Compositie???</h1>
<p>Enige toelichting is wel op z'n plek, om het duidelijker te maken.</p>
<p>We plaatsen de argumenten in de rechterkant va onze functie definitie:</p>
<pre class="haskell"><code>(f . g) x = f (g x)
</code></pre>
<p>Als eerste argument van &quot;<code>.</code>&quot; hadden we <code>length</code>, en <code>filter isLower</code> als het tweede:</p>
<pre class="haskell"><code>(length . filter isLower) x 
  = length (filter isLower x)
</code></pre>
</div>
<div class="slide">
<h1 id="lokale-variabelen">Lokale variabelen</h1>
<p>Binnen in een expressie kunnen we nieuwe variabelen introduceren door gebruik te maken van <code>let</code>.</p>
<pre class="haskell"><code>let x = 2
    y = 4
in x + y
</code></pre>
<ul>
<li><p>Lokale definities komen na <code>let</code>.</p></li>
<li><p>De expressie waarin we ze gebruiken komen na <code>in</code>.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="white-space">White space</h1>
<p>Haskell is gevoelig voor white space!</p>
<ul>
<li><p>Een top-level definitie start in de meest linkse kolom.</p></li>
<li><p>Volgend op het begin van een definitie, als de volgende regel inspringt, wordt die regel behandeld als vervolg van die definitie.</p></li>
<li><p>Gebruik nooit 'Tab' in je source files.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="white-space-en-lokale-variabelen">White space en lokale variabelen</h1>
<p>Als je lokale variabelen definieert, dan moeten ze allemaal beginnen in dezelfde kolom.</p>
<p>Dit is goed:</p>
<pre class="haskell"><code>let x = 2
    y = 4
in x + y
</code></pre>
<p>Maar dit niet:</p>
<pre class="haskell"><code>let x = 2
      y = 4
in x + y
</code></pre>
</div>
<div class="slide">
<h1 id="oefenen-met-compositie">Oefenen met compositie</h1>
<p>Schrijf een functie die een String accepteert en die een nieuwe String oplevert, die alleen de woorden bevat die met een klinker beginnen. Maak hierbij zoveel mogelijk gebruik van functie compositie.</p>
<ul>
<li>Voor je begint, is het verstandig om eerst met de <code>words</code> en <code>unwords</code> functies te spelen.</li>
</ul>
<p>Voorbeeld:</p>
<pre class="haskell"><code>disemvowel &quot;I think, therefore I am.&quot;
  == &quot;I I am.&quot;
</code></pre>
</div>
<div class="slide">
<h1 id="een-oplossing">Een oplossing</h1>
<p>Dit is hoe ik <code>disemvowel</code> schreef:</p>
<pre class="haskell"><code>disemvowel = 
  let isVowel c = toLower c `elem` &quot;aeiou&quot;
  in  unwords . filter (isVowel . head) . words
</code></pre>
<p>Doet dit je denken aan een Unix shell pipeline, maar dan van rechts naar links?</p>
</div>
<div class="slide">
<h1 id="oh-ja-hoe-zat-het-met-onze-probleemstelling">Oh ja, hoe zat het met onze probleemstelling?</h1>
<p>Gegeven een website. We willen er data afhalen (web-scraping) en er andere belangrijke web pagina's mee vinden.</p>
<p>Nu zijn we Haskell pro's, toch?</p>
<ul>
<li>Een web pagina downloaden</li>
</ul>
</div>
<div class="slide">
<h1 id="doen-een-web-pagina-downloaden">Doen: Een web pagina downloaden!</h1>
<p>Eigenlijk willen we gebruik maken van een library om een webpagina te kunnen downloaden.</p>
<p>Gelukkig bestaat er voor dit soort gevallen een hele handige centrale repository van open source Haskell software:</p>
<ul>
<li><p><a href="http://hackage.haskell.org/">http://hackage.haskell.org</a></p></li>
<li><p>(In de volksmond: &quot;Hackage&quot;)</p></li>
</ul>
<p>Go er nu heen!</p>
<p>Click op de <a href="http://hackage.haskell.org/packages/archive/pkg-list.html">Packages</a> link bovenin de pagina om packages te doorzoeken.</p>
<p>Helaas is het een overweldigende grote lijst, maar wie geduld heeft, kan er altijd nuttige dingen vinden.</p>
<p>Wie heeft geduld?</p>
</div>
<div class="slide">
<h1 id="bah">Bah!</h1>
<p>Bladeren door <em>duizenden</em> libraries kost veel tijd/moeite. Is er geen betere manier?</p>
<p>Gebruik het <code>cabal</code> commando!</p>
<p>Voer dit commando uit in een terminal window:</p>
<pre><code>cabal update
</code></pre>
<p>Hiermee download je de meest recente index van alle software op Hackage.</p>
<p>Met deze bijgewerkte index kunnen we zoeken:</p>
<pre><code>cabal list http
</code></pre>
<p>Je hebt nu nog wel ruim 20 packages om door te akkeren, maar het is beter dan de duizenden packages op de Packages pagina.</p>
</div>
<div class="slide">
<h1 id="even-de-zoektocht-helpen.">Even de zoektocht 'helpen'.</h1>
<p>Een goede HTTP client library heet <code>http-enumerator</code>.</p>
<p>De documentatie staat natuurlijk online:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/http-enumerator">hackage.haskell.org/package/http-enumerator</a></li>
</ul>
<p>De startpagina voor een package kan intimiderend overkomen, maar kijk maar eens onderaan, bij de sectie &quot;Modules&quot;.</p>
<p>Wat zie je?</p>
</div>
<div class="slide">
<h1 id="een-package-installeren">Een package installeren</h1>
<p>We moeten <code>http-enumerator</code> eerst installeren, voordat we er gebuik van kunnen maken.</p>
<p>Het installeren van het <code>http-enumerator</code> package gaat met behulp van een eenvoudig commando:</p>
<pre><code>cabal install http-enumerator
</code></pre>
<p>Dit commando bepaalt alle andere packages waar <code>http-enumerator</code> afhankelijk van is. Vervolgens worden al deze packages gedownload, vertaald en geïnstalleerd.</p>
<p>Dit kan wel een paar minuten duren. De compiler output verschijnt op het scherm.</p>
</div>
<div class="slide">
<h1 id="documentatie-lezen-packages-en-modules">Documentatie lezen: packages en modules</h1>
<p>Nu we aan het wachten zijn tot het <code>http-enumerator</code> package gereed is voor gebruik, kunnen we vast uitzoeken hoe we het kunnen gebruiken.</p>
<p>Herinner je de link nog naar de API documentatie, onderin de webpage van de package? Ga daar maar eens heen en bekijk de documentatie.</p>
<p>Een API pagina begint met een titel die er als volgt uit kan zien:</p>
<pre><code>Network.HTTP.Enumerator
</code></pre>
<p>Dit is de naam van een <em>module</em>.</p>
<p>Een module is een verzameling van samenhangende code.</p>
<p>Een <em>package</em> is een verzameling van samenhangende modules.</p>
</div>
<div class="slide">
<h1 id="documentatie-lezen-de-rest">Documentatie lezen: de rest</h1>
<p>Na de gebruikelijke initiele bla bla, bevat de documentatie van een module uit type signatures en beschrijvingen.</p>
<p>Dit is een heel eenvoudige type signature:</p>
<pre><code>foo :: String
</code></pre>
<p>Wat is dat nou weer?</p>
<p>De <em>naam</em> van het ding dat hier wordt gedefinieerd komt voor het <code>::</code> teken.</p>
<p>Het <em>type</em> ervan volgt na de <code>::</code>.</p>
<p>Dit betekent dat &quot;de waarde met de naam <code>foo</code> is van het type <code>String</code>&quot;.</p>
</div>
<div class="slide">
<h1 id="type-systeem-van-haskell">Type systeem van Haskell</h1>
<p>Tot nu toe hebben we ons niet druk gemaakt over typering of type signatures.</p>
<p>Elke expressie en waarde in Haskell heeft één type.</p>
<p>Deze types kunnen vrijwel altijd automatisch worden <em>afgeleid</em> door de compiler of interpreter.</p>
</div>
<div class="slide">
<h1 id="veel-voorkomende-basis-types">Veel voorkomende basis types</h1>
<ul>
<li><p><code>Bool</code></p></li>
<li><p><code>Int</code></p></li>
<li><p><code>Char</code></p></li>
<li><p><code>Double</code></p></li>
</ul>
</div>
<div class="slide">
<h1 id="de-signature-van-een-functie">De signature van een functie</h1>
<p>Hier is nog een type signature:</p>
<pre><code>words :: String -&gt; [String]
</code></pre>
<p>we zien een nieuw symbool, <code>-&gt;</code>. Die zegt &quot;dit is een functie&quot;.</p>
<p>Het type na de laatste <code>-&gt;</code> is het return type van de functie.</p>
<p>Alles ertussen zijn de types van de argumenten.</p>
<p>Dus dit is een functie die een <code>String</code> als argument heeft. En het resultaat is een... wat?</p>
</div>
<div class="slide">
<h1 id="lijst-notatie">Lijst notatie</h1>
<p>De notatie <code>[a]</code> betekent &quot;een lijst van waarden, elk met een of ander type <code>a</code>&quot;.</p>
<p>Dus <code>[String]</code> betekent &quot;een lijst van waarden, elk met type <code>String</code>&quot;.</p>
</div>
<div class="slide">
<h1 id="type-synoniemen">Type synoniemen</h1>
<p>Wat is een <code>String</code> eigenlijk?</p>
<ul>
<li>Het is niks bijzonders, maar gewoon een <em>synoniem</em> voor <code>[Char]</code>, oftewel &quot;een lijst van <code>Char</code>&quot;.</li>
</ul>
<p>We kunnen zelf ook synoniemen definiëren.</p>
<pre class="haskell"><code>type Euros = Int
</code></pre>
<p>Een type synoniem kan handig zijn om de bedoeling van een bestaand type te documenteren.</p>
</div>
<div class="slide">
<h1 id="words">Words</h1>
<pre><code>words :: String -&gt; [String]
</code></pre>
<p>We zien nu dat deze functie een String als argument accepteert, en een lijst van Strings teruggeeft.</p>
<p>Als we dit zo zien, kan je dan raden wat <code>words</code> zou kunnen doen?</p>
</div>
<div class="slide">
<h1 id="nog-een-signature">Nog een signature</h1>
<p>Wat kan je hierover vertellen?</p>
<pre><code>mystery :: [String] -&gt; String
</code></pre>
<p>Welk gedrag zou deze functie kunnen hebben?</p>
</div>
<div class="slide">
<h1 id="documentatie-uit-de-echte-wereld">Documentatie uit de <em>echte</em> wereld</h1>
<p>Hier is het allereerste signature uit <code>http-enumerator</code>:</p>
<pre><code>simpleHttp :: MonadIO m =&gt; String -&gt; m ByteString
</code></pre>
<p>Dit is ingewikkelder! Hoe lezen we dit nu weer?</p>
<p>Tussen <code>'::'</code> en <code>'=&gt;'</code> zien we <em>constraints</em> over het gebruik van <code>simpleHttp</code> - Dit kunnen we nu wel even laten voor wat het is.</p>
<ul>
<li><em>Belangrijk</em>: Meestal kan je zonder gevaar dingen negeren die je (nog) niet begrijpt.</li>
</ul>
<p>We zullen die gekke kleine letter <code>m</code> nu ook maar even laten voor wat het is.</p>
<p>Wat kunnen we nu zeggen over deze functie?</p>
</div>
<div class="slide">
<h1 id="bytestring">ByteString</h1>
<p>Een <code>ByteString</code> is een blob van binaire data.</p>
<p>In tegenstelling tot <code>String</code>, wordt het niet als een lijst, maar als een packed array gerepresenteerd.</p>
<p>het bevat binaire <em>bytes</em>, geen tekst!</p>
<ul>
<li>maak geen gebruik van <code>ByteString</code> om datamanipulatie op tekst te doen.</li>
</ul>
</div>
<div class="slide">
<h1 id="speelkwartier-met-ghci">Speelkwartier met ghci!</h1>
<p>Heeft iedereen <code>http-enumerator</code> inmiddels geïnstalleerd?</p>
<p>Start <code>ghci</code>, en laten we eens wat spelen met de module:</p>
<pre><code>import Network.HTTP.Enumerator
</code></pre>
<p>Merk op dat de prompt verandert zodra we het hebben getypt:</p>
<pre><code>Prelude Network.HTTP.Enumerator&gt;
</code></pre>
<p>We weten hierdoor dat de module geladen en beschikbaar is voor gebruik.</p>
</div>
<div class="slide">
<h1 id="wacht-wie-gebruikt-windows">Wacht! Wie gebruikt Windows?</h1>
<p>Onder Windows moeten we eerst Winsock initiëren voordat we netwerken kunnen gebruiken.</p>
<p>First, let's load the lowest-level networking module:</p>
<pre><code>import Network.Socket
</code></pre>
<p>En zo initiëren we Winsock:</p>
<pre><code>withSocketsDo (return ())
</code></pre>
<p>(Onder Unix kan dit geen kwaad.)</p>
</div>
<div class="slide">
<h1 id="nu-we-dat-hobbeltje-genomen-hebben-...">Nu we dat hobbeltje genomen hebben ...</h1>
<p>Eindelijk - we gaan nu een webpagina ophalen!</p>
<pre><code>simpleHttp &quot;http://example.com/&quot;
</code></pre>
<p>Kreeg je een hoop HTML in je terminal window te zien? Yeah!</p>
</div>
<div class="slide">
<h1 id="van-binary-naar-tekst">Van binary naar tekst</h1>
<p>We hebben nu een <code>ByteString</code>, die we om moeten zetten naar tekst, om er mee te kunnen manipuleren.</p>
<p>Voor het gemak nemen we even aan, dat alle web pagina's UTF-8 gecodeerd zijn.</p>
</div>
<div class="slide">
<h1 id="pure-code">Pure code</h1>
<p>Tot nu toe is alle code die we hebben geschreven &quot;Puur&quot;.</p>
<ul>
<li><p>Het gedrag van al onze functies waren alleen afhankelijk van de input.</p></li>
<li><p>Al onze data is onveranderlijk.</p></li>
<li><p>Er is dus geen manier om een globale variabele of het gedrag van een functie aan te passen</p></li>
</ul>
</div>
<div class="slide">
<h1 id="niet-pure-code">niet-pure code</h1>
<p>En toch ... Op een of andere manier hebben we een webpagina gedownload!</p>
<ul>
<li>Webpagina's zijn duidelijk <em>niet</em> puur.</li>
</ul>
<p>Hoe kan dit dan?</p>
<pre class="haskell"><code>length (simpleHttp &quot;http://x.org/&quot;)
</code></pre>
<p>HELAAS.</p>
<p>Het type systeem van Haskell maakt onderscheid tussen code die puur moet zijn en code dat zij-effecten mag hebben (&quot;niet-pure&quot; code).</p>
</div>
<div class="slide">
<h1 id="wat-nu">Wat nu?</h1>
<p>Laten we eerst eens kijken naar een eenvoudiger voorbeeld dan <code>simpleHttp</code>.</p>
<p>Typ dit in <code>ghci</code>:</p>
<pre><code>:type readFile
</code></pre>
<p>We krijgen nu het type van <code>readFile</code> te zien.</p>
</div>
<div class="slide">
<h1 id="io">IO</h1>
<p>Het <code>:type</code> commando toont nu iets als dit:</p>
<pre class="haskell"><code>readFile :: FilePath -&gt; IO String
</code></pre>
<p>Zie je het <code>IO</code> in het resulterend type?</p>
<p>Dat betekent &quot;deze functie kan zij-effecten hebben&quot;.</p>
<p>niet-pure functies, met <code>IO</code> in het resulterend type, worden vaak <em>acties</em> genoemd.</p>
<ul>
<li>Dit helpt om ze te onderscheiden van pure functies.</li>
</ul>
</div>
<div class="slide">
<h1 id="mengen-van-io-met-ander-spul">Mengen van IO met ander spul</h1>
<p>Het type-systeem 'weet' welke functies <code>IO</code> doen en zorgt ervoor dat we hier op een eerlijke manier mee omgaan.</p>
<p>We kunnen echter op een natuurlijke manier pure code mengen met code met zijeffecten:</p>
<pre class="haskell"><code>charCount fileName = do
  contents &lt;- readFile fileName
  return (length contents)
</code></pre>
</div>
<div class="slide">
<h1 id="do-notatie">&quot;do&quot; notatie</h1>
<p>Cruciaal in wat we net zagen was het <code>do</code> keyword aan het begin van de functie definitie.</p>
<p>Het introduceert een serie van <code>IO</code> acties. Een per regel.</p>
</div>
<div class="slide">
<h1 id="opvangen-van-het-resultaat-van-niet-pure-code">Opvangen van het resultaat van niet-pure code</h1>
<p>Om het resultaat van een <code>IO</code> actie op te vangen, gebruiken we <code>&lt;-</code> in plaats van <code>=</code>.</p>
<pre class="haskell"><code>contents &lt;- readFile fileName
</code></pre>
<p>Het resultaat (<code>contents</code>) is puur - Het heeft <em>geen</em> <code>IO</code> type.</p>
<p>Hiermee voeden we pure code met data uit niet-pure code.</p>
</div>
<div class="slide">
<h1 id="de-return-actie">De &quot;return&quot; actie</h1>
<p>Dit is <em>niet</em> het <code>return</code> type zoals je gewend bent!</p>
<p>Het neemt een <em>pure</em> waarde (zonder <code>IO</code> in zijn type), en <em>wikkelt</em> het in het <code>IO</code> type.</p>
<p>Pure code kan niet-pure code nooit aanroepen. Het kan wel data opleveren aan de niet-pure wereld door gebruik te maken van <code>return</code>.</p>
</div>
<div class="slide">
<h1 id="haskell-programs-and-io">Haskell programs and IO</h1>
<p>Elk Haskell programma heeft als entry point een functie met als naam <code>main</code>.</p>
<p>Het type van <code>main</code> is altijd:</p>
<pre class="haskell"><code>main :: IO ()
</code></pre>
<p><code>()</code> heet &quot;unit&quot;, en betekent zo ongeveer hetzelfde als <code>void</code> in C or Java.</p>
<p>Dit betekent dat <em>alle</em> haskell programma's niet-puur zijn!</p>
</div>
<div class="slide">
<h1 id="binary-naar-tekst">Binary naar tekst</h1>
<p>Herinner je nog dat we probeerden vals te spelen?</p>
<p>We hadden dit:</p>
<pre class="haskell"><code>simpleHttp :: String -&gt; IO ByteString
</code></pre>
<p>In plaats hiervan hebben we iets nodig met als resultaat <code>IO String</code>.</p>
<p>Hoe moet dat er uit zien?</p>
</div>
<div class="slide">
<h1 id="utf-8-conversie">UTF-8 conversie</h1>
<p>Om de conversie te doen, gaan we gebruik maken van het package <code>utf8-string</code>.</p>
<pre><code>cabal install utf8-string
</code></pre>
<p>Dit package bevat een module met de naam <code>Data.ByteString.Lazy.UTF8</code>.</p>
<pre class="haskell"><code>import Data.ByteString.Lazy.UTF8
</code></pre>
<p>Hierin is een functie gedefiniëerd met de naam <code>toString</code>:</p>
<pre class="haskell"><code>toString :: ByteString -&gt; String
</code></pre>
</div>
<div class="slide">
<h1 id="utf-8-conversie-oefening">UTF-8 conversie oefening</h1>
<p>Gebruik <code>toString</code> om een actie te schrijven die een URL downloadt en het resultaat converteert naar een <code>String</code>.</p>
<p>Schrijf het type op van de actie.</p>
<ul>
<li><p>Haskell definities hebben gewoonlijk geen type signature nodig.</p></li>
<li><p>Ondanks dit is het een goede gewoonte om ze als <em>documentatie</em> op te schrijven bij top-level definities.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="downloaden-en-opslaan-van-een-web-pagina">Downloaden en opslaan van een web pagina</h1>
<p>Gebruik je <code>download</code> functie om een lokale kopie op te slaan van een webpagina.</p>
<pre class="haskell"><code>saveAs :: String -&gt; Int -&gt; IO ()
</code></pre>
<p>Laten we voor het gemak de lokale files opslaan met namen die nummers bevatten:</p>
<pre class="haskell"><code>makeFileName :: Int -&gt; FilePath
makeFileName k = &quot;download-&quot; ++ show k ++ &quot;.html&quot;
</code></pre>
<p>Om een lokale kopie van een bestand op te slaan, heb je de actie <code>writeFile</code> nodig.</p>
</div>
<div class="slide">
<h1 id="spitten-in-html">Spitten in HTML</h1>
<p>Twee waarheden:</p>
<ul>
<li><p>De meeste HTML in het wild is een zooitje.</p></li>
<li><p>Zelfs het parsen van nette HTML is ingewikkeld.</p></li>
</ul>
<p>Laten we voor de verandering maar weer eens een library gaan gebruiken!</p>
<pre><code>cabal install tagsoup
</code></pre>
<p>De <code>tagsoup</code> package kan willekeurig rommelige HTML aan.</p>
<p>Het levert ons een lijst met events, vergelijkbaar met een SAX parser.</p>
</div>
<div class="slide">
<h1 id="omgaan-met-problemen">Omgaan met problemen</h1>
<p>Probeer dit:</p>
<pre class="haskell"><code>head [1]
</code></pre>
<p>Probeer nu dit:</p>
<pre class="haskell"><code>head []
</code></pre>
</div>
<div class="slide">
<h1 id="oei">Oei</h1>
<p>Als we een lege lijst aanleveren, levert de <code>head</code> functie een foutmelding.</p>
<p>Stel dat we een versie van <code>head</code> nodig hebben die <em>geen</em> foutmelding geeft.</p>
<pre class="haskell"><code>safeHead :: [a] -&gt; ????
</code></pre>
<p>Wat zou de <code>????</code> moeten zijn?</p>
<p>Laten we wat proberen.</p>
<pre class="haskell"><code>safeHead (x:xs) = Some x
safeHead []     = None
</code></pre>
</div>
<div class="slide">
<h1 id="some-none">Some? None?</h1>
<ul>
<li><p>We gebruiken een constructor met de naam <code>Some</code> om het idee te vangen: &quot;We hebben een resultaat&quot;.</p></li>
<li><p>De constructor <code>None</code> geeft aan: &quot;We hebben hier geen resultaat&quot;.</p></li>
</ul>
<p>Om deze constructors in het leven te roepen, definiëren we een nieuw type.</p>
<pre class="haskell"><code>data Perhaps a = Some a
               | None
</code></pre>
<p>Het <code>|</code> teken scheidt de constructors. We lezen het als volgt:</p>
<ul>
<li><p>Het <code>Perhaps</code> type kent twee constructors:</p></li>
<li><p><code>Some</code> gevolgd door één argument</p></li>
<li><p>of <code>None</code> zonder argumenten</p></li>
</ul>
</div>
<div class="slide">
<h1 id="maybe">Maybe</h1>
<p>Eigenlijk heeft Haskell al een <code>Perhaps</code> type.</p>
<pre class="haskell"><code>data Maybe a = Just a
             | Nothing
</code></pre>
<p>De <code>a</code> is een <em>type parameter</em>, met als betekenis dat als we dit type opschrijven, dat we dan een ander moeten toevoegen als parameter:</p>
<ul>
<li><p><code>Maybe Int</code></p></li>
<li><p><code>Maybe String</code></p></li>
</ul>
</div>
<div class="slide">
<h1 id="gebruik-maken-van-constructors">Gebruik maken van constructors</h1>
<p>Als we een <code>Maybe Int</code> willen samenstellen door gebruik te maken van de <code>Just</code> constructor, dan moeten we een <code>Int</code> meegeven.</p>
<pre class="haskell"><code>Just 1  :: Maybe Int
Nothing :: Maybe Int
</code></pre>
<p>Dit gaat niet werken, want de types komen niet overeen:</p>
<pre class="haskell"><code>Just [1] :: Maybe String
</code></pre>
</div>
<div class="slide">
<h1 id="pattern-matching-met-constructors">Pattern matching met constructors</h1>
<p>We kunnen pattern matchen met constructors van <code>Maybe</code> op dezelfde manier als dat we dat hebben gedaan voor lijsten.</p>
<pre class="haskell"><code>case foo of
  Just x  -&gt; x
  Nothing -&gt; bar
</code></pre>
</div>
<div class="slide">
<h1 id="tags">Tags</h1>
<p>Het <code>tagsoup</code> package definieert het volgende type:</p>
<pre class="haskell"><code>data Tag = TagOpen String [Attribute]
         | TagClose String
         | TagText String
         | TagComment String
         | TagWarning String
         | TagPosition Row Column
</code></pre>
<p>Wat denk je dat deze constructors kunnen betekenen?</p>
</div>
<div class="slide">
<h1 id="pattern-matching-over-een-tag">Pattern matching over een Tag</h1>
<p>Stel dat we een predikaat willen schrijven die aangeeft of een <code>Tag</code> een opening tag is.</p>
<ul>
<li><p>Wat zou het type van deze functie zijn?</p></li>
<li><p>Hoe zou de bode van de functie er uit zien?</p></li>
</ul>
</div>
<div class="slide">
<h1 id="om-het-even">Om het even!</h1>
<p>Onze eerste body zag er als volgt uit:</p>
<pre class="haskell"><code>isOpenTag (TagOpen x y)     = True
isOpenTag (TagClose x)      = False
isOpenTag (TagText x)       = False
isOpenTag (TagComment x)    = False
isOpenTag (TagWarning x)    = False
isOpenTag (TagPosition x y) = False
</code></pre>
<p>Beknopt, maar lelijk.</p>
<ul>
<li><p>We zijn maar in precies één constructor geïnteresseerd.</p></li>
<li><p>We gebruiken de gedeclareerde variabelen <code>x</code> or <code>y</code> helemaal niet.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="het-wild-card-patroon">Het wild card patroon</h1>
<p>We kunnen met het &quot;<code>_</code>&quot; teken opschrijven dat het ons niet uitmaakt wat een patroon of variabele precies is.</p>
<pre class="haskell"><code>isOpenTag (TagOpen _ _) = True
isOpenTag  _            = False
</code></pre>
<p>Het wild card patroon matcht altijd.</p>
<ul>
<li><p>Aangezien we toch geen gebruik maken van <code>x</code> of <code>y</code>, kunnen we dat expliciet aangeven door gebruik te maken van <code>_</code>.</p></li>
<li><p>Aangezien elke constructor behalve <code>TagOpen</code> ons niets interesseert, kunnen we ze allemaal laten matchen met <code>_</code>.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="even-een-vraag-tussendoor">Even een vraag tussendoor</h1>
<p>Waarom schrijven we de functie niet op deze manier?</p>
<pre class="haskell"><code>isOpenTag  _            = False
isOpenTag (TagOpen _ _) = True
</code></pre>
</div>
<div class="slide">
<h1 id="extractie-van-de-links-van-een-webpagina">Extractie van de links van een webpagina</h1>
<p>Stel dat we al een pagina geladen hebben.</p>
<ul>
<li><p>Bekijk de <code>tagsoup</code> documentatie in de module <code>Text.HTML.TagSoup</code> .</p></li>
<li><p>Zoek een functie die een webpagina parsed in een serie tags.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="die-kunnen-we-mooi-gebruiken">Die kunnen we mooi gebruiken!</h1>
<pre class="haskell"><code>processPage url = do
  page &lt;- download url
  return (parseTags page)
</code></pre>
</div>
<div class="slide">
<h1 id="tags-opschonen">Tags opschonen</h1>
<p>De geparsede tags kunnen verschillende soorten tag namen hebben.</p>
<pre><code>&lt;A HREF=&quot;...&quot;&gt;
</code></pre>
<pre><code>&lt;a hrEF=&quot;...&quot;&gt;
</code></pre>
<ul>
<li>Zoek een <code>tagsoup</code> functie die tag namen en attributen omzet in kleine letters.</li>
</ul>
</div>
<div class="slide">
<h1 id="tags-in-normaalvorm">Tags in normaalvorm</h1>
<p>Laten we onze functie gebruiken om het resultaat van <code>parseTags</code> op te schonen.</p>
<pre class="haskell"><code>processPage url = do
  page &lt;- download url
  return
    (canonicalizeTags
      (parseTags page))
</code></pre>
</div>
<div class="slide">
<h1 id="extractie-van-links">Extractie van links</h1>
<p>We zijn alleen geïnteresseerd in open tags die links bevatten, dus <code>&lt;a&gt;</code> tags.</p>
<ul>
<li><p>Hoe zouden we het type functie schrijven die aangeeft of een <code>Tag</code> een open tag is met de juiste naam?</p></li>
<li><p>Hoe zouden we die functie gebruiken om alleen de open tags over te houden van een lijst van geparsede tags?</p></li>
</ul>
</div>
<div class="slide">
<h1 id="poeh-hee">Poeh hee!</h1>
<p>Deze cascade begint belachelijke vormen te krijgen.</p>
<pre class="haskell"><code>processPage url = do
  page &lt;- download url
  return
    (filter (isTagOpenName &quot;a&quot;)
      (canonicalizeTags
        (parseTags page)))
</code></pre>
<p>Twee observaties:</p>
<ul>
<li><p>Onze actie is nu voor het merendeel pure code.</p></li>
<li><p>Het lijkt wel een pijplijn.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="een-herschrijf-oefening">Een herschrijf oefening</h1>
<p>Verdeel de functie in pure en niet-pure delen.</p>
<p>Schrijf het pure gedeelte met gebruikmaking van functie compositie.</p>
<pre class="haskell"><code>processPage url = do
  page &lt;- download url
  return
    (filter (isTagOpenName &quot;a&quot;)
      (canonicalizeTags
        (parseTags page)))
</code></pre>
</div>
<div class="slide">
<h1 id="mijn-oplossing">Mijn oplossing</h1>
<pre class="haskell"><code>processPage url = do
  page &lt;- download url
  return (process page)

process =
    filter (isTagOpenName &quot;a&quot;) .
    canonicalizeTags .
    parseTags
</code></pre>
</div>
<div class="slide">
<h1 id="we-willen-nog-meer-kwijt">We willen nog meer kwijt</h1>
<p>Laten we de <code>nofollow</code> links ook weglaten.</p>
<p>We willen het <code>&quot;rel&quot;</code> attribuut van een tag.</p>
<ul>
<li>Zoek een functie die een attribuut van een tag teruggeeft.</li>
</ul>
</div>
<div class="slide">
<h1 id="geen-following">Geen following</h1>
<pre class="haskell"><code>nofollow tag = fromAttrib &quot;rel&quot; tag == &quot;nofollow&quot;
</code></pre>
<pre class="haskell"><code>process =
    filter (not . nofollow) .
    filter (isTagOpenName &quot;a&quot;) .
    canonicalizeTags .
    parseTags
</code></pre>
</div>
<div class="slide">
<h1 id="we-hebben-een-lijst-met-a-tags">We hebben een lijst met &lt;a&gt; tags</h1>
<p>Hoe zouden we het <code>&quot;href&quot;</code> attribuute ophalen van elk element uit de lijst?</p>
</div>
<div class="slide">
<h1 id="allen-niet-lege-a-href-tags">Allen niet-lege &lt;a href&gt; tags</h1>
<pre class="haskell"><code>process =
    filter (not . null) .
    map (fromAttrib &quot;href&quot;) .
    filter (not . nofollow) .
    filter (isTagOpenName &quot;a&quot;) .
    canonicalizeTags .
    parseTags
</code></pre>
</div>
<div class="slide">
<h1 id="urls-in-normaalvorm">URLs in normaalvorm</h1>
<p>Links kunnen absoluut, relatief of onzinnige rommel zijn. We willen alleen maar absolute links die er geldig uitzien.</p>
<p>Om netjes een absolute link te maken moeten we de absolute URL kennen van de pagina waar we naar kijken.</p>
<pre class="haskell"><code>canonicalizeLink :: String -&gt; String -&gt; Maybe String
</code></pre>
</div>
<div class="slide">
<h1 id="werken-met-uris">Werken met URIs</h1>
<p>Het package <code>Network.URI</code> bevat een paar functies die hier goed van pas komen.</p>
<pre class="haskell"><code>parseURI :: String -&gt; Maybe URI
parseURIReference :: String -&gt; Maybe URI
uriToString id &quot;&quot; :: URI -&gt; String
nonStrictRelativeTo :: URI -&gt; URI -&gt; Maybe URI
</code></pre>
</div>
<div class="slide">
<h1 id="een-draak-van-een-inspringer">Een draak van een inspringer</h1>
<p>Dit is niet meer om te lezen!</p>
<pre class="haskell"><code>import Network.URI

canon :: String -&gt; String -&gt; Maybe String
canon referer path =
  case parseURI referer of
    Nothing -&gt; Nothing
    Just r  -&gt;
      case parseURIReference path of
        Nothing -&gt; Nothing
        Just p  -&gt;
          case nonStrictRelativeTo p r of
            Nothing -&gt; Nothing
            Just u -&gt;
             Just (uriToString id u &quot;&quot;)
</code></pre>
<p>Dat kan vast beter.</p>
</div>
<div class="slide">
<h1 id="traplopen">Traplopen</h1>
<p>Is het je opgevallen dat die functie een serie is van met <code>case</code> inspecties van <code>Maybe</code> waarden?</p>
<p>Stel je voor dat we een functie zouden hebben die een gewone waarde als input heeft, en die een <code>Maybe</code> waarde teruggeeft.</p>
<pre class="haskell"><code>a -&gt; Maybe b
</code></pre>
<p>En stel je voor dat we een beknopte syntax hebben om een anonieme functie te schrijven.</p>
<pre class="haskell"><code>\a -&gt; &quot;hoi mam! &quot; ++ a
</code></pre>
<p>De <code>\</code> noemen we &quot;lambda&quot;.</p>
</div>
<div class="slide">
<h1 id="observatie">Observatie</h1>
<p>De inspectie met <code>case</code> is nogal breedsprakig. Stel dat we een functie zouden hebben die de inspectie deed, en een andere functie zou aanroepen als de waarde een <code>Just</code> was.</p>
<pre class="haskell"><code>bind :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b
bind  Nothing      _     = Nothing
bind (Just value) action = action value
</code></pre>
</div>
<div class="slide">
<h1 id="het-gebruik-van-bind">Het gebruik van bind</h1>
<p>Hoe kunnen we dit gebruiken?</p>
<pre class="haskell"><code>canon1 referer path =
  parseURI referer                `bind`
   \r -&gt; parseURIReference path   `bind`
    \p -&gt; nonStrictRelativeTo p r `bind`
     \u -&gt; Just (uriToString id u &quot;&quot;)
</code></pre>
<p>Als we een functienaam omsluiten in &quot;`&quot;-tekens, dan kunnen we de functie als infix operator gebruiken.</p>
</div>
<div class="slide">
<h1 id="een-andere-layout-van-dezelfde-code">Een andere layout van dezelfde code</h1>
<pre class="haskell"><code>canon referer path =
  parseURI referer         `bind` \r -&gt;
  parseURIReference path   `bind` \p -&gt;
  nonStrictRelativeTo p r  `bind` \u -&gt;
  Just (uriToString id u &quot;&quot;)
</code></pre>
</div>
<div class="slide">
<h1 id="een-ingebouwde-naam-voor-bind">Een ingebouwde naam voor bind</h1>
<p>De <code>&gt;&gt;=</code> operator is een generieke versie van onze <code>bind</code> functie.</p>
<pre class="haskell"><code>canon referer path =
  parseURI referer &gt;&gt;= \r -&gt;
  parseURIReference path &gt;&gt;= \p -&gt;
  nonStrictRelativeTo p r &gt;&gt;= \u -&gt;
  Just (uriToString id u &quot;&quot;)
</code></pre>
</div>
<div class="slide">
<h1 id="gebruik-maken-van-vereenvoudigde-schrijfwijze">Gebruik maken van vereenvoudigde schrijfwijze</h1>
<p>Hier is wat nettere syntax, die je vast bekend voorkomt.</p>
<pre class="haskell"><code>canonicalize :: String -&gt; String -&gt; Maybe String

canonicalize referer path = do
  r &lt;- parseURI referer
  p &lt;- parseURIReference path
  u &lt;- nonStrictRelativeTo p r
  return (uriToString id u &quot;&quot;)
</code></pre>
</div>
<div class="slide">
<h1 id="bijna-klaar">Bijna klaar</h1>
<pre class="haskell"><code>process url =
   map (canonicalize url) .
   filter (not . null) .
   map (fromAttrib &quot;href&quot;) .
   filter (\t -&gt; fromAttrib &quot;rel&quot; t /= &quot;nofollow&quot;) .
   filter (isTagOpenName &quot;a&quot;) .
   canonicalizeTags .
   parseTags
</code></pre>
<p>Da's nou onhandig: wat is het type van deze functie?</p>
</div>
<div class="slide">
<h1 id="van-maybe-a-naar-a">Van [Maybe a] naar [a]</h1>
<p>Ga naar deze website:</p>
<ul>
<li><a href="http://haskell.org/hoogle">haskell.org/hoogle</a></li>
</ul>
<p>Typ dit in de search box:</p>
<pre class="haskell"><code>[Maybe a] -&gt; [a]
</code></pre>
<p>Wat zien we als eerste resultaat?</p>
</div>
<div class="slide">
<h1 id="klaar">Klaar!</h1>
<pre class="haskell"><code>import Data.Maybe
import Network.URI

links url =
  catMaybes .
  map (canonicalize url) .
  filter (not . null) .
  map (fromAttrib &quot;href&quot;) .
  filter (\t -&gt; fromAttrib &quot;rel&quot; t /= &quot;nofollow&quot;) .
  filter (isTagOpenName &quot;a&quot;) .
  canonicalizeTags .
  parseTags
</code></pre>
</div>
<div class="slide">
<h1 id="van-links-naar-spideren">Van links naar spideren</h1>
<p>Als we de links van een webpagina af kunnen halen, kunnen we eenvoudig een spider schrijven om die links te volgen.</p>
<p>Om het eenvoudig te houden, zetten we een limiet op het aantal pagina's dat we willen downloaden.</p>
<p>Welke informatie willen we genereren?</p>
<p>Wat willen we onderweg bijhouden?</p>
</div>
<div class="slide">
<h1 id="wat-we-willen-bijhouden">Wat we willen bijhouden</h1>
<p>De status die we willen bijhouden:</p>
<ul>
<li><p>Het aantal pagina's dat we hebben gedownload</p></li>
<li><p>Een verzameling pagina's waar we links naartoe hebben gezien, maar die we (nog) niet hebben gedownload</p></li>
<li><p>Een verzameling pagina's met hun uitgaande links</p></li>
</ul>
</div>
<div class="slide">
<h1 id="bijhouden-wat-we-gezien-hebben">Bijhouden wat we gezien hebben</h1>
<p>Voor een willekeurige pagina, willen we de pagina zelf bewaren en alle pagina's waar het naar verwijst.</p>
<p>Een mogelijkheid om deze twee te associeren is een <em>tuple</em>:</p>
<pre class="haskell"><code>(&quot;http://x.org/&quot;, [&quot;http://microsoft.com/&quot;])
</code></pre>
<p>Tuples zijn nuttig als we verschillende soorten data hebben zonder dat we het gedoe willen van het definieren van een nieuw type.</p>
<p>Nu we het toch over een nieuw type hebben, zo definieer je er een:</p>
<pre class="haskell"><code>data Link = Link String [String]

-- Let's define some accessors, too.
linkFrom (Link url _) = url
linkTo (Link _ links) = links
</code></pre>
</div>
<div class="slide">
<h1 id="dubbelingen-voork&#243;men">Dubbelingen voorkómen</h1>
<p>We willen een URL niet twee keer bezoeken.</p>
<p>Hoe voorkomen we dat?</p>
<pre class="haskell"><code>visited url = elem url . map linkTo
</code></pre>
<p>Deze functie heeft een probleem - zie je welk probleem?</p>
</div>
<div class="slide">
<h1 id="betere-performance">Betere performance</h1>
<p>We willen een structuur met een snelle opzoek operatie.</p>
<p>Wat zou je in jouw programmeertaal gebruiken?</p>
</div>
<div class="slide">
<h1 id="maps-and-importing">Maps and importing</h1>
<p>In Haskell bestaan muteerbare hash tables, maar die gebruiken we niet.</p>
<p>in plaats hiervan gebruiken we liever <em>onveranderlijke</em> key-value maps.</p>
<p>We moeten de nodige trucks uithalen bij het importeren, want de <code>Data.Map</code> module definieert veel namen die anders zouden overlappen met ingebouwde namen.</p>
<p>Dit betekent &quot;importeer alleen de naam <code>Map</code> van de module <code>Data.Map</code>&quot;:</p>
<pre class="haskell"><code>import Data.Map (Map)
</code></pre>
<p>En dit betekent &quot;importeer alles van <code>Data.Map</code>, maar elk van deze namen moet voorafgegaan worden door <code>Map.</code>&quot;:</p>
<pre class="haskell"><code>import qualified Data.Map as Map
</code></pre>
</div>
<div class="slide">
<h1 id="wat-is-het-nut-van-een-onveranderlijke-data-structuur">Wat is het nut van een onveranderlijke data structuur?</h1>
<p>Is iedereen bekend hoe je een key-value paar aan een hash tabel toevoegt?</p>
<p>En dat lijkt een fundamentele operatie.</p>
<p>Wat doen we met maps?</p>
<ul>
<li>Maak een <em>nieuwe</em> map die identiek is aan de map die we aanleveren, met het gevraagde element toegevoegd.</li>
</ul>
<p>Hoe kan dat nou werken? Is het efficient?</p>
</div>
<div class="slide">
<h1 id="een-hand-vol-dollars">Een hand vol dollars</h1>
<p>Hier is een verbazingwekkend handige ingebouwde operator:</p>
<pre class="haskell"><code>f $ x = f x
</code></pre>
<p>Waarom is dit nuttig? Omdat we hierdoor haakjes kunnen weglaten.</p>
<p>zonder $:</p>
<pre class="haskell"><code>explode k = error (&quot;failed on &quot; ++ show k)
</code></pre>
<p>met $:</p>
<pre class="haskell"><code>explode k = error $ &quot;failed on &quot; ++ show k
</code></pre>
</div>
<div class="slide">
<h1 id="partiele-toepassing">Partiele toepassing</h1>
<p>Dit is onhandig om op te schrijven:</p>
<pre class="haskell"><code>increment k = 1 + k
</code></pre>
<p>Bijna net zo erg:</p>
<pre class="haskell"><code>\k -&gt; 1 + k
</code></pre>
<p>Veel handiger, en identiek:</p>
<pre class="haskell"><code>(1+)
</code></pre>
<p>Dit is valide:</p>
<pre class="haskell"><code>increment = (1+)
</code></pre>
</div>
<div class="slide">
<h1 id="spideren-in-al-zijn-glans">Spideren, in al zijn glans</h1>
<pre class="haskell"><code>spider :: Int -&gt; URL -&gt; IO (Map URL [URL])
spider count url0 = go 0 Map.empty (Set.singleton url0)
  where
    go k seen queue0
        | k &gt;= count = return seen
        | otherwise  =
      case Set.minView queue0 of
        Nothing -&gt; return seen
        Just (url, queue) -&gt; do
          page &lt;- download url
          let ls       = links url page
              newSeen  = Map.insert url ls seen
              notSeen  = Set.fromList .
                         filter (`Map.notMember` newSeen) $ ls
              newQueue = queue `Set.union` notSeen
          go (k+1) newSeen newQueue
</code></pre>
</div>
<div class="slide">
<h1 id="stand-van-zaken">Stand van zaken?</h1>
<p>We kunnen nu:</p>
<ul>
<li><p>Een webpagina downloaden</p></li>
<li><p>De links ervan extraheren</p></li>
<li><p>van daar uit verder <code>spideren</code>, zonder doublures</p></li>
</ul>
<p>Wat blijft over?</p>
<ul>
<li><p>We zouden meerdere pagina's tegelijkertijd kunnen spideren</p></li>
<li><p>Of we zouden kunnen berekenen welke pagina's &quot;belangrijk&quot; zijn</p></li>
</ul>
</div>
<div class="slide">
<h1 id="fin">Fin</h1>
<p>In het hoogst onwaarschijnlijke geval dat we hier aankomen voordat we uit de tijd zijn gelopen, gaam we verder in een we-zien-wel-wat-voor-avontuur sessie.</p>
<p>Bedankt dat je tot nu toe niet bent afgehaakt!</p>
</div>
<div class="slide">
<h1 id="copy-these-slides-if-you-want">Copy these slides (if you want)</h1>
<pre><code>git clone https://github.com/hanjoosten/strange-loop-2011
</code></pre>
<p>% Functioneel programmeren met Haskell % Han Joosten % 7 maart 2012</p>
</div>
<div class="slide">
<h1 id="welkom-1">Welkom!</h1>
<pre class="haskell"><code>main = putStrLn &quot;hallo!&quot;
</code></pre>
<ul>
<li><p>Mijn naam is Han Joosten</p></li>
<li><p>Ik ben Requirements Engineer bij TS Noord</p></li>
<li><p>Begonnen met Haskell ca. 2006</p></li>
<li><p>Ik help mee bij een open source project</p>
<ul>
<li><a href="http://ampersand.sourceforge.net">ampersand.sourceforge.net</a></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="achtergrond-in-functioneel-programmeren-1">Achtergrond in (functioneel) programmeren</h1>
<p>ik ben in aanraking gekomen met functionele talen op de universiteit</p>
<pre><code>* Twentel, Miranda, Lisp
</code></pre>
<p>Diverse specificatie talen:</p>
<pre><code>* Lotos, ASF+SDF, Typol, LaTeX
</code></pre>
<p>Na mijn afstuderen in 1990 heb ik geprogrammeerd in iteratieve talen</p>
<pre><code>* Pascal, C, Perl, Rexx, Cool:Gen (integrated Case tool)
</code></pre>
<ul>
<li><p>Mijn interesse voor Haskell werd gewekt rond 2006</p></li>
<li><p>Haskell is een volwassen allround programmeertaal</p></li>
<li><p>Haskell community is heel behulpzaam</p></li>
</ul>
</div>
<div class="slide">
<h1 id="over-deze-presentatie-1">Over deze presentatie</h1>
<ul>
<li><p>Reden: Omdat ik enthousiast ben over Functioneel Programmeren</p></li>
<li><p>Doel: Enthousiasmeren van jullie</p></li>
<li><p>Over deze sheets: gepikt van Bryan O'Sullivan</p></li>
</ul>
</div>
<div class="slide">
<h1 id="wat-kan-je-verwachten-1-1">Wat kan je verwachten 1</h1>
<ul>
<li><p>Haskell is een behoorlijk uitgebreide taal</p></li>
<li><p>Omdat er veel onbekend is voor nieuwkomers, kan je er van uit gaan dat je ver van je comfort-zone zal geraken</p></li>
<li><p>Ik ga je <em>interessante</em> dingen leren, maar niet <em>alles</em></p></li>
</ul>
</div>
<div class="slide">
<h1 id="wat-kan-je-verwachten-2-1">Wat kan je verwachten 2</h1>
<ul>
<li><p>Dit is een <em>hands-on</em> workshop: je gaat zelf code schrijven!</p></li>
<li><p>Na ongeveer een uur is er een korte pauze</p></li>
<li><p>Schroom niet! Stel gerust vragen!</p></li>
</ul>
</div>
<div class="slide">
<h1 id="je-gereedschap-1">Je gereedschap</h1>
<ul>
<li><p>Je hebt het Haskell Platform al geïnstalleerd als het goed is.</p>
<ul>
<li><a href="http://hackage.haskell.org/platform/">hackage.haskell.org/platform</a></li>
</ul></li>
<li><p>We hebben nu een super gereedschapskist</p>
<ul>
<li><p>De GHC compiler (<code>ghc</code>)</p></li>
<li><p>De GHCi interpreter (<code>ghci</code>)</p></li>
<li><p>De Cabal package manager (<code>cabal</code>)</p></li>
<li><p>Enkele handige libraries en tools</p></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="wat-hebben-we-nog-meer-nodig-1">Wat hebben we nog meer nodig?</h1>
<ul>
<li><p>Een text editor</p></li>
<li><p>Een terminal window</p></li>
</ul>
</div>
<div class="slide">
<h1 id="probleemstelling-1">Probleemstelling</h1>
<p>Gegeven een website. We willen er data afhalen (web-scraping) en er andere belangrijke web pagina's mee vinden.</p>
<p>Er valt dan ook veel uit te zoeken!</p>
<ol style="list-style-type: decimal">
<li><p>Haskell leren</p></li>
<li><p>Een web pagina downloaden</p></li>
<li><p>De links van een pagina halen, zodat we meer pagina's kunnen vinden om te downloaden</p></li>
<li><p>Als we zo ver zijn, bepalen we de pagina's die relevant zijn</p></li>
<li><p>en ook nog een beetje snel?</p></li>
</ol>
</div>
<div class="slide">
<h1 id="aan-de-slag-1">Aan de slag!</h1>
<p>Maak een file <code>Hello.hs</code> met de volgende inhoud:</p>
<pre class="haskell"><code>main = putStrLn &quot;hello, world!&quot;
</code></pre>
<p>De extentie <code>.hs</code> is de standaard voor Haskell source files.</p>
<p>De naam van een bestand begint met een hoofdletter en iedereen gebruikt <code>CamelCase</code>.</p>
</div>
<div class="slide">
<h1 id="vertalen-1">Vertalen</h1>
<p>Dit commando zoekt naar <code>Hello.hs</code> in de huidige directory, en vertaalt het:</p>
<pre><code>ghc --make Hello
</code></pre>
<p>Het gegenereerde programma heet <code>Hello</code> (<code>Hello.exe</code> op Windows).</p>
<ul>
<li>De <code>--make</code> optie zorgt er voor dat GHC de afhankelijkheden met andere bestanden en packages automatisch afhandelt.</li>
</ul>
</div>
<div class="slide">
<h1 id="even-controleren-1">Even controleren</h1>
<p>Is het iedereen gelukt om hun <code>Hello</code> programma te genereren en uit te voeren?</p>
</div>
<div class="slide">
<h1 id="en-nu-wat-handiger-1">En nu wat handiger</h1>
<p>Het is prettig om snelle, goede code te hebben.</p>
<p>maar als <em>ik</em> programmeer, dan:</p>
<ul>
<li><p>moet ik vaak nog veel uitzoeken.</p></li>
<li><p>ik maak best veel fouten.</p></li>
</ul>
<p>In deze omstandigheden werkt een echte compiler vertragend.</p>
<p>Er is daarom een interactieve interpreter, <code>ghci</code>.</p>
</div>
<div class="slide">
<h1 id="aan-de-slag-met-ghci-1">Aan de slag met GHCi</h1>
<p>Simpel genoeg:</p>
<pre><code>ghci
</code></pre>
<p>Er verschijnt wat opstart-tekst, gevolgd door de prompt:</p>
<pre><code>GHCi, version 7.0.3: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Loading package ffi-1.0 ... linking ... done.
Prelude&gt;
</code></pre>
<p>Deze standaard prompt vertelt ons welke modules er beschikbaar zijn om mee te spelen.</p>
</div>
<div class="slide">
<h1 id="spelen-met-ghci-1">Spelen met GHCi</h1>
<p>De <code>ghci</code> interpreter evalueert interactief expressies.</p>
<p>Probeer nu zelf:</p>
<pre class="haskell"><code>2 + 2
</code></pre>
<pre class="haskell"><code>123456781234567812345678 * 87654321876543
</code></pre>
<pre class="haskell"><code>&quot;foo&quot; ++ &quot;bar&quot;
</code></pre>
<p>(De <code>++</code> is de &quot;append&quot; operator.)</p>
</div>
<div class="slide">
<h1 id="interpreter-commandos-1">Interpreter commando's</h1>
<p>Alle interpreter commando's beginnen met een &quot;<code>:</code>&quot; teken.</p>
<p>Laten we ons programma in <code>ghci</code> laden:</p>
<pre><code>:load Hello.hs
</code></pre>
<p>De <code>ghci</code> prompt verandert:</p>
<pre><code>*Main&gt;
</code></pre>
</div>
<div class="slide">
<h1 id="onze-code-uitvoeren-met-ghci-1">Onze code uitvoeren met ghci</h1>
<p>We hebben een functie met de naam <code>main</code> gedefinieerd. Voer het nu uit:</p>
<pre><code>main
</code></pre>
<p>Is het gelukt?</p>
<p>En wat zou dit doen?</p>
<pre class="haskell"><code>putStrLn &quot;hoi mam!&quot;
</code></pre>
</div>
<div class="slide">
<h1 id="enkele-van-de-nuttigste-commandos-1">Enkele van de nuttigste commando's</h1>
<p>Onthoud dat alle <code>ghci</code> commando's met een &quot;<code>:</code>&quot; beginnen.</p>
<ul>
<li><p><code>:help</code> toont welke commando's we tot onze beschikking hebben.</p></li>
<li><p><code>:reload</code> laden van het bestand dat het laatst is ge<code>:load</code>.</p></li>
<li><p><code>:edit</code> opent de tekst editor met het bestand dat het laatst is ge<code>:load</code>. (echter <em>niet</em> automatische <code>:reload</code>.)</p></li>
<li><p><code>:quit</code> beëindigt <code>GHCi</code>.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="enkele-ghci-efficiency-tips-1">Enkele ghci efficiency tips</h1>
<p>We kunnen commando's afkorten:</p>
<ul>
<li><p><code>:e</code> is synoniem voor <code>:edit</code></p></li>
<li><p><code>:r</code> is <code>:reload</code></p></li>
</ul>
<p>We hebben ook historie en command line editing.</p>
<ul>
<li><p>Op Unix, vergelijkbaar met <code>readline</code>.</p></li>
<li><p>Op Windows, zelfde als <code>cmd.exe</code>.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="gewenning-aan-de-cyclus-1">Gewenning aan de cyclus</h1>
<p>Gebruik <code>:edit</code> of je tekst editor om de &quot;hello&quot; tekst aan te passen.</p>
<p>Gebruik <code>:reload</code> om je bestand opnieuw te laden.</p>
<p>Test je nieuwe definitie van <code>main</code>.</p>
<ul>
<li>Oefening: Gebruik de &quot;pijl omhoog&quot; toets om door je commando historie te gaan totdat je terug komt op de laatste keer dat je <code>main</code> typte.</li>
</ul>
</div>
<div class="slide">
<h1 id="lijsten-en-strings-1">Lijsten en Strings</h1>
<pre class="haskell"><code>[1,2,3,4]
</code></pre>
<pre class="haskell"><code>['h','e','l','l','o']
</code></pre>
<p>Dubbele haakjes zijn alleen maar een verkorte schrijfwijze voor de langere vorm:</p>
<pre class="haskell"><code>&quot;hello&quot;
</code></pre>
<p>Wat zou dit als resultaat opleveren?</p>
<pre class="haskell"><code>&quot;foo&quot; == ['f','o','o']
</code></pre>
</div>
<div class="slide">
<h1 id="functies-aanroepen-1-1">Functies aanroepen: 1</h1>
<p>We gebruiken spaties om de functie van zijn argumenten te scheiden:</p>
<pre class="haskell"><code>head &quot;foo&quot;
</code></pre>
<pre class="haskell"><code>head [1,2,3]
</code></pre>
<pre class="haskell"><code>tail [1,2,3]
</code></pre>
</div>
<div class="slide">
<h1 id="functies-aanroepen-2-1">Functies aanroepen: 2</h1>
<p>Bij meerdere argumenten, worden alle argumenten onderling gescheiden door spaties:</p>
<pre class="haskell"><code>min 3 4
</code></pre>
<p>Als een argument zelf een samengestelde expressie is, moeten er haken omheen:</p>
<pre class="haskell"><code>compare (3+5) (2+7)
</code></pre>
<pre class="haskell"><code>max (min 3 4) 5
</code></pre>
</div>
<div class="slide">
<h1 id="zelf-doen-1-1">Zelf doen: 1</h1>
<p>Gebruik <code>ghci</code> als een rekenmachine.</p>
<p>De <code>**</code> operator is voor machtsverheffen.</p>
<ul>
<li>Als ik 5 FT's investeer met 3% samengestelde rente per jaar, hoeveel FT's heb ik dan na 10 jaar?</li>
</ul>
</div>
<div class="slide">
<h1 id="zelf-doen-2-1">Zelf doen: 2</h1>
<p>De notatie <code>['a'..'z']</code> genereert een lijst van start tot eind, inclusief.</p>
<p>De <code>sum</code> functie sommeert alle elementen in een lijst.</p>
<ul>
<li>Wat is de som van de getallen tussen 9 en 250, inclusief, <em>minus</em> 2?</li>
</ul>
</div>
<div class="slide">
<h1 id="zelf-doen-3-1">Zelf doen: 3</h1>
<p>De <code>show</code> functie toont een waarde als een String. Probeer maar!</p>
<pre class="haskell"><code>show (1 == 2)
</code></pre>
<p>De <code>length</code> functie geeft ons het aantal elementen in een lijst.</p>
<pre class="haskell"><code>length [1,2,3]
</code></pre>
<ul>
<li>Uit hoeveel cijfers bestaat het product van alle getallen tussen 0xBE en 0xEF, inclusief?</li>
</ul>
</div>
<div class="slide">
<h1 id="zelf-functies-defini&#235;ren-1">Zelf functies definiëren</h1>
<p>Zelf functies definiëren is best eenvoudig.</p>
<p>Open je tekst editor, maak een nieuw bestand met de <code>.hs</code> extentie, en begin te schrijven:</p>
<pre class="haskell"><code>isOdd x  =  (rem x 2) == 1
</code></pre>
<ul>
<li><p>We beginnen met de naam van de functie.</p></li>
<li><p>Vervolgens komen de namen van de parameter(s) die we willen, gescheiden door spaties.</p></li>
<li><p>Dan komt een enkel <code>=</code> teken, waarachter de <em>body</em> van de functie volgt.</p></li>
</ul>
<p>Laad je bestand in <code>ghci</code> en probeer <code>myOdd</code> maar eens uit.</p>
</div>
<div class="slide">
<h1 id="smaakmakers-1">Smaakmakers</h1>
<p>Nu kunnen we heel eenvoudige functies maken, maar we missen belangrijke ingredienten voor het echte werk.</p>
<p>Dus, waar wachten we op!</p>
</div>
<div class="slide">
<h1 id="conditionele-uitvoering-1">Conditionele uitvoering</h1>
<p>Q: Hoe ziet de bekende <code>if</code> er uit in Haskell?</p>
<p>A: Bekend!</p>
<pre class="haskell"><code>ggd a b = if b == 0
          then a
          else ggd b (rem a b)
</code></pre>
<p>We hebben de volgende elementen:</p>
<ul>
<li><p>Een Boolean expressie</p></li>
<li><p><code>then</code> een expressie die het resultaat is als de Boolean <code>True</code> is</p></li>
<li><p><code>else</code> een expressie die het resultaat is als de Boolean <code>False</code> is</p></li>
</ul>
</div>
<div class="slide">
<h1 id="eindelijk-een-klein-beetje-over-types-1">Eindelijk! Een klein beetje over types</h1>
<p>De twee mogelijke resultaat expressies van een <code>if</code> expressie moeten hetzelfde type hebben.</p>
<p>Als <code>then</code> een <code>String</code> oplevert, dan moet <code>else</code> dat ook doen!</p>
<p>Het volgende voorbeeld is natuurlijk onzin:</p>
<pre class="haskell"><code>if True
then 3.14
else &quot;wombat&quot;
</code></pre>
<p>Dit soort onzin-typering is in Haskell verboden.</p>
</div>
<div class="slide">
<h1 id="wat-nog-meer-over-else-1">Wat nog meer over else?</h1>
<p>In imperatieve talen kunnen we meestal het <code>else</code> deel na de <code>if</code> weglaten.</p>
<p>Maar niet in Haskell.</p>
<p>Waarom kan dit wel bij imperatieve talen, en niet in Haskell?</p>
</div>
<div class="slide">
<h1 id="een-bijna-triviale-oefening-1">Een bijna triviale oefening</h1>
<p>Schrijf een functie met als resultaat het argument met daarachter <code>&quot;, world&quot;</code> geplakt, als dat argument <code>&quot;hello&quot;</code> is, of alleen maar het onveranderde argument in andere gevallen.</p>
<ul>
<li>Oh ja, De &quot;append&quot;-functie luistert naar de naam <code>++</code>.</li>
</ul>
</div>
<div class="slide">
<h1 id="lijsten-in-haskell-1">Lijsten in Haskell</h1>
<p>We weten al hoe een lijst er in Haskell uitziet:</p>
<pre class="haskell"><code>[1,2,3]
</code></pre>
<p>En natuurlijk de verkorte schrijfwijze voor Strings:</p>
<pre class="haskell"><code>&quot;foo&quot; == ['f','o','o']
</code></pre>
<p>Maar is dit alles wat er valt te weten?</p>
</div>
<div class="slide">
<h1 id="lijst-constructors-1">Lijst constructors</h1>
<p>Stel dat we een lijst van de gront af aan willen opbouwen.</p>
<ul>
<li><p>We schrijven de <em>lege lijst</em> als <code>[]</code>.</p></li>
<li><p>Gegeven een bestaande lijst, kunnen we een ander element aan het <em>begin</em> van de lijst toevoegen met behulp van de <code>:</code> operator.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="typ-dit-in-ghci-1">Typ dit in ghci</h1>
<p>Voeg een element toe aan een lege lijst:</p>
<pre class="haskell"><code>1 : []
</code></pre>
</div>
<div class="slide">
<h1 id="en-nu-verder-vanaf-lijsten-met-&#233;&#233;n-element-1">En nu verder vanaf lijsten met één element</h1>
<p>Hoe breiden we zo'n lijst uit?</p>
<pre class="haskell"><code>2 : (1 : [])
</code></pre>
<p>Je hebt vaste wel geraden dat <code>[2,1]</code> een verkorte schrijfwijze is voor <code>2:(1:[])</code>. En dat is inderdaad zo!</p>
<p>Wat is het resultaat van deze expressie?</p>
<pre class="haskell"><code>5 : 8 : [] == [5,8]
</code></pre>
</div>
<div class="slide">
<h1 id="constructors-1">Constructors</h1>
<p>We refereren aan <code>[]</code> en <code>:</code> als <em>constructors</em>, omdat we ze gebruiken om lijsten mee te constureren.</p>
<p>Als je een lijst maakt, moet de Haskell runtime onthouden welke constructors je hebt gebruikt, en waar precies.</p>
<p>Dus de waarde <code>[5,8]</code> wordt gerepresenteerd als:</p>
<ul>
<li><p>Een <code>:</code> constructor, met <code>5</code> als zijn eerste argument, en als tweede ...</p></li>
<li><p>Nog een <code>:</code> constructor, deze keer met <code>8</code> als zijn eerste argument, en nu als tweede ...</p></li>
<li><p>Een <code>[]</code> constructor.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="wat-zagen-we-zojuist-1">Wat zagen we zojuist?</h1>
<p>Afhankelijk van je achtergrond, dacht je waarschijnlijk iets als:</p>
<ul>
<li><p>&quot;Hee! Haskell lijsten lijken op enkelvoudig gelinkte lijsten!&quot;</p></li>
<li><p>&quot;Hee! Dat lijkt op de <code>cons</code> cellen van Lisp!&quot;</p></li>
</ul>
<p>Inderdaad.</p>
</div>
<div class="slide">
<h1 id="waarom-zouden-we-ons-druk-maken-om-constructors-1">Waarom zouden we ons druk maken om constructors?</h1>
<p>Haskell moet natuurlijk onthouden hoe een lijst is opgebouwd.</p>
<p>Het laat <em>ons</em> ook een lijst inspecteren, zodat we kunnen nagaan welke contstructors er gebruikt zijn.</p>
<p>Hoe doen we dat?</p>
<pre class="haskell"><code>import Data.Char

isCapitalized name
  = case name of
      (first:rest) -&gt; isUpper first
      []           -&gt; False
</code></pre>
</div>
<div class="slide">
<h1 id="de-case-expressie-1">De case-expressie</h1>
<p>De <code>case</code> expressie laat ons een structuur <em>inspecteren</em>.</p>
<pre class="haskell"><code>isCapitalized name
  = case name of
      []           -&gt; False
      (first:rest) -&gt; isUpper first
</code></pre>
<ul>
<li>Tussen <code>case</code> en <code>of</code> staat de te inspecteren expressie.</li>
<li>Als de structuur overeenkomt met de lege-lijst constructor <code>[]</code>, dan is de structuur <code>name</code> die we inspecteren leeg. Dus geen hoofdletter.</li>
</ul>
<p>Als de gebruikte constructor de &quot;aan de voorkant toevoegen&quot; <code>:</code> operator is, dan wordt het interessanter.</p>
<ul>
<li>Wat er ook maar als eerste argument gebruikt is voor de <code>:</code> constructor wordt gebonden aan de naam <code>first</code>.</li>
<li>Het tweede argument van de <code>:</code> constructor (dus alles in de lijst na het eerste element) wordt gebonden aan de naam <code>rest</code>.</li>
<li>De expressie volgend op <code>-&gt;</code> wordt ge-evalueerd met deze waarden.</li>
</ul>
</div>
<div class="slide">
<h1 id="pattern-matching-1">Pattern matching</h1>
<p>Wat de <code>case</code> expressie doet, noemen we <em>pattern matching</em>.</p>
<ul>
<li><p>Patronen worden gecontroleerd van boven naar beneden.</p></li>
<li><p>Zodra een een patroon 'matcht', wordt het rechter deel (het deel achter de <code>-&gt;</code>) gebruikt als het resultaat van de hele <code>case</code> expressie.</p></li>
<li><p>Als geen enkel patroon 'matcht', ontstaat een exceptie.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="een-voorbeeld-1">Een voorbeeld</h1>
<p>Laten we stap voor stap kijken wat er gebeurt als we deze expressie evalueren.</p>
<pre class="haskell"><code>isCapitalized &quot;Ann&quot;
</code></pre>
</div>
<div class="slide">
<h1 id="whew-een-paar-oefeningen-1">Whew! Een paar oefeningen!</h1>
<p>Eindelijk! We kunnen nu iets ingewikkelder functies schrijven.</p>
<p>Nu je het begin van een lijst kan inspecteren, zou je een <em>hele</em> lijst recursief kunnen afhandelen.</p>
<p>Schrijf eerst een functie met de naam <code>myLength</code> die het aantal elementen in een lijst bepaalt.</p>
<p>Vervolgens schrijf je een functie met de naam <code>countCaps</code> die het aantal hoofdletters in een String bepaalt.</p>
<pre class="haskell"><code>countCaps &quot;Monkey Butter&quot; == 2
</code></pre>
</div>
<div class="slide">
<h1 id="het-tellen-van-hoofdletters-1">Het tellen van Hoofdletters</h1>
<p>Jôh, die countCaps functie was knap lastig. Of niet?</p>
<p>Hier is mijn definitie, gebruik makend van alleen de dingen die we tot nu toe hebben geleerd:</p>
<pre class="haskell"><code>countCaps string =
  case string of
    []     -&gt; 0
    (x:xs) -&gt; if isUpper x
              then 1 + countCaps xs
              else countCaps xs
</code></pre>
</div>
<div class="slide">
<h1 id="huh.-1">Huh.</h1>
<p>Ik dacht dat Haskell zo beknopt was!?</p>
</div>
<div class="slide">
<h1 id="beknoptheid-1-top-level-pattern-matching-1">Beknoptheid 1: top-level pattern matching</h1>
<pre class="haskell"><code>countCaps []     = 0
countCaps (x:xs) =
    if isUpper x
    then 1 + countCaps xs
    else countCaps xs
</code></pre>
<p>We kunnen een functie definieren als een serie vergelijkingen, die elk een <code>pattern match</code> bevatten.</p>
<p>Dit is een beknopte schrijfwijze voor <code>case</code>.</p>
</div>
<div class="slide">
<h1 id="beknoptheid-2-guards-1">Beknoptheid 2: guards</h1>
<pre class="haskell"><code>countCaps []     = 0
countCaps (x:xs)
   | isUpper x    = 1 + countCaps xs
   | otherwise    = countCaps xs
</code></pre>
<p>Achter elke <code>|</code> staat een <em>guard</em>.</p>
<ul>
<li><p>Als een patroon matcht, evalueren we iedere Boolean guard expressie van boven naar beneden.</p></li>
<li><p>Zodra er een succes heeft, evalueren we de rechterkant als de <code>body</code> van de functie.</p></li>
</ul>
<p>(Jazeker, pattronen in een <code>case</code> kunnen ook guards hebben.)</p>
</div>
<div class="slide">
<h1 id="v&#243;&#243;r-1">Vóór</h1>
<p>Zoals in de originele versie, maar nu zonder gebruik van <code>case</code>:</p>
<pre class="haskell"><code>countCaps xs =
  if null xs
  then 0 
  else if isUpper (head xs)
       then 1 + countCaps (tail xs)
       else countCaps (tail xs)
</code></pre>
</div>
<div class="slide">
<h1 id="na-1">Na</h1>
<p>Zowel korter als eenvoudiger te begrijpen:</p>
<pre class="haskell"><code>countCaps []     = 0
countCaps (x:xs)
   | isUpper x    = 1 + countCaps xs
   | otherwise    = countCaps xs
</code></pre>
</div>
<div class="slide">
<h1 id="een-andere-aanpak-1">Een andere aanpak</h1>
<p>Schrijf een nieuwe versie van <code>countCaps</code>:</p>
<ul>
<li><p>Schrijf een functie die door een lijst loopt, en die een nieuwe lijst genereert bestaande uit alleen de hoofdletters van de oorspronkelijke lijst.</p></li>
<li><p>Gebruik <code>length</code> om het aantal elementen te tellen.</p></li>
</ul>
<p>Dit zou hetzelfde resultaat moeten opleveren als je eerste functie. Toch?</p>
</div>
<div class="slide">
<h1 id="wijziging-van-de-specificatie-1">Wijziging van de specificatie</h1>
<p>Stel dat we het aantal kleine letters in een string willen tellen.</p>
<p>Dit lijkt bijna hetzelfde als onze functie om hoofletters te tellen.</p>
<p>Wat kunnen we doen met deze observatie?</p>
</div>
<div class="slide">
<h1 id="hogere-orde-functies-1">Hogere orde functies</h1>
<p><em>Hogere orde functie</em>: een functie die een andere functie accepteert als argument.</p>
<pre class="haskell"><code>filter pred [] = []
filter pred (x:xs)
  | pred x     = x : filter pred xs
  | otherwise  =     filter pred xs
</code></pre>
<p>Hoe kunnen we dit gebruiken om <code>countLowerCase</code> te definieren?</p>
</div>
<div class="slide">
<h1 id="data-in-data-uit-1">Data in, data uit</h1>
<p>Tot nu toe hebben we verschillende definities gezien zoals deze:</p>
<pre class="haskell"><code>countLowerCase string =
  length (filter isLower string)
</code></pre>
<p>We zien hierin een terugkerend pattroon:</p>
<ul>
<li><p>Een functie met één argument</p></li>
<li><p>krijgt als input het resultaat van ...</p></li>
<li><p>... een andere functie met één argument</p></li>
</ul>
</div>
<div class="slide">
<h1 id="functie-compositie-1">Functie compositie</h1>
<p>Haskell beperkt ons niet tot alleen maar alfanumerieke namen voor functies.</p>
<p>We kunnen een functie definiëren met de simpele naam &quot;<code>.</code>&quot;, die we als een operator kunnen gebruiken:</p>
<pre class="haskell"><code>(f . g) x = f (g x)
</code></pre>
<p>Wat is hier het nut van?</p>
<pre class="haskell"><code>countLowerCase = length . filter isLower
</code></pre>
</div>
<div class="slide">
<h1 id="compositie-1">Compositie???</h1>
<p>Enige toelichting is wel op z'n plek, om het duidelijker te maken.</p>
<p>We plaatsen de argumenten in de rechterkant va onze functie definitie:</p>
<pre class="haskell"><code>(f . g) x = f (g x)
</code></pre>
<p>Als eerste argument van &quot;<code>.</code>&quot; hadden we <code>length</code>, en <code>filter isLower</code> als het tweede:</p>
<pre class="haskell"><code>(length . filter isLower) x 
  = length (filter isLower x)
</code></pre>
</div>
<div class="slide">
<h1 id="lokale-variabelen-1">Lokale variabelen</h1>
<p>Binnen in een expressie kunnen we nieuwe variabelen introduceren door gebruik te maken van <code>let</code>.</p>
<pre class="haskell"><code>let x = 2
    y = 4
in x + y
</code></pre>
<ul>
<li><p>Lokale definities komen na <code>let</code>.</p></li>
<li><p>De expressie waarin we ze gebruiken komen na <code>in</code>.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="white-space-1">White space</h1>
<p>Haskell is gevoelig voor white space!</p>
<ul>
<li><p>Een top-level definitie start in de meest linkse kolom.</p></li>
<li><p>Volgend op het begin van een definitie, als de volgende regel inspringt, wordt die regel behandeld als vervolg van die definitie.</p></li>
<li><p>Gebruik nooit 'Tab' in je source files.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="white-space-en-lokale-variabelen-1">White space en lokale variabelen</h1>
<p>Als je lokale variabelen definieert, dan moeten ze allemaal beginnen in dezelfde kolom.</p>
<p>Dit is goed:</p>
<pre class="haskell"><code>let x = 2
    y = 4
in x + y
</code></pre>
<p>Maar dit niet:</p>
<pre class="haskell"><code>let x = 2
      y = 4
in x + y
</code></pre>
</div>
<div class="slide">
<h1 id="oefenen-met-compositie-1">Oefenen met compositie</h1>
<p>Schrijf een functie die een String accepteert en die een nieuwe String oplevert, die alleen de woorden bevat die met een klinker beginnen. Maak hierbij zoveel mogelijk gebruik van functie compositie.</p>
<ul>
<li>Voor je begint, is het verstandig om eerst met de <code>words</code> en <code>unwords</code> functies te spelen.</li>
</ul>
<p>Voorbeeld:</p>
<pre class="haskell"><code>disemvowel &quot;I think, therefore I am.&quot;
  == &quot;I I am.&quot;
</code></pre>
</div>
<div class="slide">
<h1 id="een-oplossing-1">Een oplossing</h1>
<p>Dit is hoe ik <code>disemvowel</code> schreef:</p>
<pre class="haskell"><code>disemvowel = 
  let isVowel c = toLower c `elem` &quot;aeiou&quot;
  in  unwords . filter (isVowel . head) . words
</code></pre>
<p>Doet dit je denken aan een Unix shell pipeline, maar dan van rechts naar links?</p>
</div>
<div class="slide">
<h1 id="oh-ja-hoe-zat-het-met-onze-probleemstelling-1">Oh ja, hoe zat het met onze probleemstelling?</h1>
<p>Gegeven een website. We willen er data afhalen (web-scraping) en er andere belangrijke web pagina's mee vinden.</p>
<p>Nu zijn we Haskell pro's, toch?</p>
<ul>
<li>Een web pagina downloaden</li>
</ul>
</div>
<div class="slide">
<h1 id="doen-een-web-pagina-downloaden-1">Doen: Een web pagina downloaden!</h1>
<p>Eigenlijk willen we gebruik maken van een library om een webpagina te kunnen downloaden.</p>
<p>Gelukkig bestaat er voor dit soort gevallen een hele handige centrale repository van open source Haskell software:</p>
<ul>
<li><p><a href="http://hackage.haskell.org/">http://hackage.haskell.org</a></p></li>
<li><p>(In de volksmond: &quot;Hackage&quot;)</p></li>
</ul>
<p>Go er nu heen!</p>
<p>Click op de <a href="http://hackage.haskell.org/packages/archive/pkg-list.html">Packages</a> link bovenin de pagina om packages te doorzoeken.</p>
<p>Helaas is het een overweldigende grote lijst, maar wie geduld heeft, kan er altijd nuttige dingen vinden.</p>
<p>Wie heeft geduld?</p>
</div>
<div class="slide">
<h1 id="bah-1">Bah!</h1>
<p>Bladeren door <em>duizenden</em> libraries kost veel tijd/moeite. Is er geen betere manier?</p>
<p>Gebruik het <code>cabal</code> commando!</p>
<p>Voer dit commando uit in een terminal window:</p>
<pre><code>cabal update
</code></pre>
<p>Hiermee download je de meest recente index van alle software op Hackage.</p>
<p>Met deze bijgewerkte index kunnen we zoeken:</p>
<pre><code>cabal list http
</code></pre>
<p>Je hebt nu nog wel ruim 20 packages om door te akkeren, maar het is beter dan de duizenden packages op de Packages pagina.</p>
</div>
<div class="slide">
<h1 id="even-de-zoektocht-helpen.-1">Even de zoektocht 'helpen'.</h1>
<p>Een goede HTTP client library heet <code>http-enumerator</code>.</p>
<p>De documentatie staat natuurlijk online:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/http-enumerator">hackage.haskell.org/package/http-enumerator</a></li>
</ul>
<p>De startpagina voor een package kan intimiderend overkomen, maar kijk maar eens onderaan, bij de sectie &quot;Modules&quot;.</p>
<p>Wat zie je?</p>
</div>
<div class="slide">
<h1 id="een-package-installeren-1">Een package installeren</h1>
<p>We moeten <code>http-enumerator</code> eerst installeren, voordat we er gebuik van kunnen maken.</p>
<p>Het installeren van het <code>http-enumerator</code> package gaat met behulp van een eenvoudig commando:</p>
<pre><code>cabal install http-enumerator
</code></pre>
<p>Dit commando bepaalt alle andere packages waar <code>http-enumerator</code> afhankelijk van is. Vervolgens worden al deze packages gedownload, vertaald en geïnstalleerd.</p>
<p>Dit kan wel een paar minuten duren. De compiler output verschijnt op het scherm.</p>
</div>
<div class="slide">
<h1 id="documentatie-lezen-packages-en-modules-1">Documentatie lezen: packages en modules</h1>
<p>Nu we aan het wachten zijn tot het <code>http-enumerator</code> package gereed is voor gebruik, kunnen we vast uitzoeken hoe we het kunnen gebruiken.</p>
<p>Herinner je de link nog naar de API documentatie, onderin de webpage van de package? Ga daar maar eens heen en bekijk de documentatie.</p>
<p>Een API pagina begint met een titel die er als volgt uit kan zien:</p>
<pre><code>Network.HTTP.Enumerator
</code></pre>
<p>Dit is de naam van een <em>module</em>.</p>
<p>Een module is een verzameling van samenhangende code.</p>
<p>Een <em>package</em> is een verzameling van samenhangende modules.</p>
</div>
<div class="slide">
<h1 id="documentatie-lezen-de-rest-1">Documentatie lezen: de rest</h1>
<p>Na de gebruikelijke initiele bla bla, bevat de documentatie van een module uit type signatures en beschrijvingen.</p>
<p>Dit is een heel eenvoudige type signature:</p>
<pre><code>foo :: String
</code></pre>
<p>Wat is dat nou weer?</p>
<p>De <em>naam</em> van het ding dat hier wordt gedefinieerd komt voor het <code>::</code> teken.</p>
<p>Het <em>type</em> ervan volgt na de <code>::</code>.</p>
<p>Dit betekent dat &quot;de waarde met de naam <code>foo</code> is van het type <code>String</code>&quot;.</p>
</div>
<div class="slide">
<h1 id="type-systeem-van-haskell-1">Type systeem van Haskell</h1>
<p>Tot nu toe hebben we ons niet druk gemaakt over typering of type signatures.</p>
<p>Elke expressie en waarde in Haskell heeft één type.</p>
<p>Deze types kunnen vrijwel altijd automatisch worden <em>afgeleid</em> door de compiler of interpreter.</p>
</div>
<div class="slide">
<h1 id="veel-voorkomende-basis-types-1">Veel voorkomende basis types</h1>
<ul>
<li><p><code>Bool</code></p></li>
<li><p><code>Int</code></p></li>
<li><p><code>Char</code></p></li>
<li><p><code>Double</code></p></li>
</ul>
</div>
<div class="slide">
<h1 id="de-signature-van-een-functie-1">De signature van een functie</h1>
<p>Hier is nog een type signature:</p>
<pre><code>words :: String -&gt; [String]
</code></pre>
<p>we zien een nieuw symbool, <code>-&gt;</code>. Die zegt &quot;dit is een functie&quot;.</p>
<p>Het type na de laatste <code>-&gt;</code> is het return type van de functie.</p>
<p>Alles ertussen zijn de types van de argumenten.</p>
<p>Dus dit is een functie die een <code>String</code> als argument heeft. En het resultaat is een... wat?</p>
</div>
<div class="slide">
<h1 id="lijst-notatie-1">Lijst notatie</h1>
<p>De notatie <code>[a]</code> betekent &quot;een lijst van waarden, elk met een of ander type <code>a</code>&quot;.</p>
<p>Dus <code>[String]</code> betekent &quot;een lijst van waarden, elk met type <code>String</code>&quot;.</p>
</div>
<div class="slide">
<h1 id="type-synoniemen-1">Type synoniemen</h1>
<p>Wat is een <code>String</code> eigenlijk?</p>
<ul>
<li>Het is niks bijzonders, maar gewoon een <em>synoniem</em> voor <code>[Char]</code>, oftewel &quot;een lijst van <code>Char</code>&quot;.</li>
</ul>
<p>We kunnen zelf ook synoniemen definiëren.</p>
<pre class="haskell"><code>type Euros = Int
</code></pre>
<p>Een type synoniem kan handig zijn om de bedoeling van een bestaand type te documenteren.</p>
</div>
<div class="slide">
<h1 id="words-1">Words</h1>
<pre><code>words :: String -&gt; [String]
</code></pre>
<p>We zien nu dat deze functie een String als argument accepteert, en een lijst van Strings teruggeeft.</p>
<p>Als we dit zo zien, kan je dan raden wat <code>words</code> zou kunnen doen?</p>
</div>
<div class="slide">
<h1 id="nog-een-signature-1">Nog een signature</h1>
<p>Wat kan je hierover vertellen?</p>
<pre><code>mystery :: [String] -&gt; String
</code></pre>
<p>Welk gedrag zou deze functie kunnen hebben?</p>
</div>
<div class="slide">
<h1 id="documentatie-uit-de-echte-wereld-1">Documentatie uit de <em>echte</em> wereld</h1>
<p>Hier is het allereerste signature uit <code>http-enumerator</code>:</p>
<pre><code>simpleHttp :: MonadIO m =&gt; String -&gt; m ByteString
</code></pre>
<p>Dit is ingewikkelder! Hoe lezen we dit nu weer?</p>
<p>Tussen <code>'::'</code> en <code>'=&gt;'</code> zien we <em>constraints</em> over het gebruik van <code>simpleHttp</code> - Dit kunnen we nu wel even laten voor wat het is.</p>
<ul>
<li><em>Belangrijk</em>: Meestal kan je zonder gevaar dingen negeren die je (nog) niet begrijpt.</li>
</ul>
<p>We zullen die gekke kleine letter <code>m</code> nu ook maar even laten voor wat het is.</p>
<p>Wat kunnen we nu zeggen over deze functie?</p>
</div>
<div class="slide">
<h1 id="bytestring-1">ByteString</h1>
<p>Een <code>ByteString</code> is een blob van binaire data.</p>
<p>In tegenstelling tot <code>String</code>, wordt het niet als een lijst, maar als een packed array gerepresenteerd.</p>
<p>het bevat binaire <em>bytes</em>, geen tekst!</p>
<ul>
<li>maak geen gebruik van <code>ByteString</code> om datamanipulatie op tekst te doen.</li>
</ul>
</div>
<div class="slide">
<h1 id="speelkwartier-met-ghci-1">Speelkwartier met ghci!</h1>
<p>Heeft iedereen <code>http-enumerator</code> inmiddels geïnstalleerd?</p>
<p>Start <code>ghci</code>, en laten we eens wat spelen met de module:</p>
<pre><code>import Network.HTTP.Enumerator
</code></pre>
<p>Merk op dat de prompt verandert zodra we het hebben getypt:</p>
<pre><code>Prelude Network.HTTP.Enumerator&gt;
</code></pre>
<p>We weten hierdoor dat de module geladen en beschikbaar is voor gebruik.</p>
</div>
<div class="slide">
<h1 id="wacht-wie-gebruikt-windows-1">Wacht! Wie gebruikt Windows?</h1>
<p>Onder Windows moeten we eerst Winsock initiëren voordat we netwerken kunnen gebruiken.</p>
<p>First, let's load the lowest-level networking module:</p>
<pre><code>import Network.Socket
</code></pre>
<p>En zo initiëren we Winsock:</p>
<pre><code>withSocketsDo (return ())
</code></pre>
<p>(Onder Unix kan dit geen kwaad.)</p>
</div>
<div class="slide">
<h1 id="nu-we-dat-hobbeltje-genomen-hebben-...-1">Nu we dat hobbeltje genomen hebben ...</h1>
<p>Eindelijk - we gaan nu een webpagina ophalen!</p>
<pre><code>simpleHttp &quot;http://example.com/&quot;
</code></pre>
<p>Kreeg je een hoop HTML in je terminal window te zien? Yeah!</p>
</div>
<div class="slide">
<h1 id="van-binary-naar-tekst-1">Van binary naar tekst</h1>
<p>We hebben nu een <code>ByteString</code>, die we om moeten zetten naar tekst, om er mee te kunnen manipuleren.</p>
<p>Voor het gemak nemen we even aan, dat alle web pagina's UTF-8 gecodeerd zijn.</p>
</div>
<div class="slide">
<h1 id="pure-code-1">Pure code</h1>
<p>Tot nu toe is alle code die we hebben geschreven &quot;Puur&quot;.</p>
<ul>
<li><p>Het gedrag van al onze functies waren alleen afhankelijk van de input.</p></li>
<li><p>Al onze data is onveranderlijk.</p></li>
<li><p>Er is dus geen manier om een globale variabele of het gedrag van een functie aan te passen</p></li>
</ul>
</div>
<div class="slide">
<h1 id="niet-pure-code-1">niet-pure code</h1>
<p>En toch ... Op een of andere manier hebben we een webpagina gedownload!</p>
<ul>
<li>Webpagina's zijn duidelijk <em>niet</em> puur.</li>
</ul>
<p>Hoe kan dit dan?</p>
<pre class="haskell"><code>length (simpleHttp &quot;http://x.org/&quot;)
</code></pre>
<p>HELAAS.</p>
<p>Het type systeem van Haskell maakt onderscheid tussen code die puur moet zijn en code dat zij-effecten mag hebben (&quot;niet-pure&quot; code).</p>
</div>
<div class="slide">
<h1 id="wat-nu-1">Wat nu?</h1>
<p>Laten we eerst eens kijken naar een eenvoudiger voorbeeld dan <code>simpleHttp</code>.</p>
<p>Typ dit in <code>ghci</code>:</p>
<pre><code>:type readFile
</code></pre>
<p>We krijgen nu het type van <code>readFile</code> te zien.</p>
</div>
<div class="slide">
<h1 id="io-1">IO</h1>
<p>Het <code>:type</code> commando toont nu iets als dit:</p>
<pre class="haskell"><code>readFile :: FilePath -&gt; IO String
</code></pre>
<p>Zie je het <code>IO</code> in het resulterend type?</p>
<p>Dat betekent &quot;deze functie kan zij-effecten hebben&quot;.</p>
<p>niet-pure functies, met <code>IO</code> in het resulterend type, worden vaak <em>acties</em> genoemd.</p>
<ul>
<li>Dit helpt om ze te onderscheiden van pure functies.</li>
</ul>
</div>
<div class="slide">
<h1 id="mengen-van-io-met-ander-spul-1">Mengen van IO met ander spul</h1>
<p>Het type-systeem 'weet' welke functies <code>IO</code> doen en zorgt ervoor dat we hier op een eerlijke manier mee omgaan.</p>
<p>We kunnen echter op een natuurlijke manier pure code mengen met code met zijeffecten:</p>
<pre class="haskell"><code>charCount fileName = do
  contents &lt;- readFile fileName
  return (length contents)
</code></pre>
</div>
<div class="slide">
<h1 id="do-notatie-1">&quot;do&quot; notatie</h1>
<p>Cruciaal in wat we net zagen was het <code>do</code> keyword aan het begin van de functie definitie.</p>
<p>Het introduceert een serie van <code>IO</code> acties. Een per regel.</p>
</div>
<div class="slide">
<h1 id="opvangen-van-het-resultaat-van-niet-pure-code-1">Opvangen van het resultaat van niet-pure code</h1>
<p>Om het resultaat van een <code>IO</code> actie op te vangen, gebruiken we <code>&lt;-</code> in plaats van <code>=</code>.</p>
<pre class="haskell"><code>contents &lt;- readFile fileName
</code></pre>
<p>Het resultaat (<code>contents</code>) is puur - Het heeft <em>geen</em> <code>IO</code> type.</p>
<p>Hiermee voeden we pure code met data uit niet-pure code.</p>
</div>
<div class="slide">
<h1 id="de-return-actie-1">De &quot;return&quot; actie</h1>
<p>Dit is <em>niet</em> het <code>return</code> type zoals je gewend bent!</p>
<p>Het neemt een <em>pure</em> waarde (zonder <code>IO</code> in zijn type), en <em>wikkelt</em> het in het <code>IO</code> type.</p>
<p>Pure code kan niet-pure code nooit aanroepen. Het kan wel data opleveren aan de niet-pure wereld door gebruik te maken van <code>return</code>.</p>
</div>
<div class="slide">
<h1 id="haskell-programs-and-io-1">Haskell programs and IO</h1>
<p>Elk Haskell programma heeft als entry point een functie met als naam <code>main</code>.</p>
<p>Het type van <code>main</code> is altijd:</p>
<pre class="haskell"><code>main :: IO ()
</code></pre>
<p><code>()</code> heet &quot;unit&quot;, en betekent zo ongeveer hetzelfde als <code>void</code> in C or Java.</p>
<p>Dit betekent dat <em>alle</em> haskell programma's niet-puur zijn!</p>
</div>
<div class="slide">
<h1 id="binary-naar-tekst-1">Binary naar tekst</h1>
<p>Herinner je nog dat we probeerden vals te spelen?</p>
<p>We hadden dit:</p>
<pre class="haskell"><code>simpleHttp :: String -&gt; IO ByteString
</code></pre>
<p>In plaats hiervan hebben we iets nodig met als resultaat <code>IO String</code>.</p>
<p>Hoe moet dat er uit zien?</p>
</div>
<div class="slide">
<h1 id="utf-8-conversie-1">UTF-8 conversie</h1>
<p>Om de conversie te doen, gaan we gebruik maken van het package <code>utf8-string</code>.</p>
<pre><code>cabal install utf8-string
</code></pre>
<p>Dit package bevat een module met de naam <code>Data.ByteString.Lazy.UTF8</code>.</p>
<pre class="haskell"><code>import Data.ByteString.Lazy.UTF8
</code></pre>
<p>Hierin is een functie gedefiniëerd met de naam <code>toString</code>:</p>
<pre class="haskell"><code>toString :: ByteString -&gt; String
</code></pre>
</div>
<div class="slide">
<h1 id="utf-8-conversie-oefening-1">UTF-8 conversie oefening</h1>
<p>Gebruik <code>toString</code> om een actie te schrijven die een URL downloadt en het resultaat converteert naar een <code>String</code>.</p>
<p>Schrijf het type op van de actie.</p>
<ul>
<li><p>Haskell definities hebben gewoonlijk geen type signature nodig.</p></li>
<li><p>Ondanks dit is het een goede gewoonte om ze als <em>documentatie</em> op te schrijven bij top-level definities.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="downloaden-en-opslaan-van-een-web-pagina-1">Downloaden en opslaan van een web pagina</h1>
<p>Gebruik je <code>download</code> functie om een lokale kopie op te slaan van een webpagina.</p>
<pre class="haskell"><code>saveAs :: String -&gt; Int -&gt; IO ()
</code></pre>
<p>Laten we voor het gemak de lokale files opslaan met namen die nummers bevatten:</p>
<pre class="haskell"><code>makeFileName :: Int -&gt; FilePath
makeFileName k = &quot;download-&quot; ++ show k ++ &quot;.html&quot;
</code></pre>
<p>Om een lokale kopie van een bestand op te slaan, heb je de actie <code>writeFile</code> nodig.</p>
</div>
<div class="slide">
<h1 id="spitten-in-html-1">Spitten in HTML</h1>
<p>Twee waarheden:</p>
<ul>
<li><p>De meeste HTML in het wild is een zooitje.</p></li>
<li><p>Zelfs het parsen van nette HTML is ingewikkeld.</p></li>
</ul>
<p>Laten we voor de verandering maar weer eens een library gaan gebruiken!</p>
<pre><code>cabal install tagsoup
</code></pre>
<p>De <code>tagsoup</code> package kan willekeurig rommelige HTML aan.</p>
<p>Het levert ons een lijst met events, vergelijkbaar met een SAX parser.</p>
</div>
<div class="slide">
<h1 id="omgaan-met-problemen-1">Omgaan met problemen</h1>
<p>Probeer dit:</p>
<pre class="haskell"><code>head [1]
</code></pre>
<p>Probeer nu dit:</p>
<pre class="haskell"><code>head []
</code></pre>
</div>
<div class="slide">
<h1 id="oei-1">Oei</h1>
<p>Als we een lege lijst aanleveren, levert de <code>head</code> functie een foutmelding.</p>
<p>Stel dat we een versie van <code>head</code> nodig hebben die <em>geen</em> foutmelding geeft.</p>
<pre class="haskell"><code>safeHead :: [a] -&gt; ????
</code></pre>
<p>Wat zou de <code>????</code> moeten zijn?</p>
<p>Laten we wat proberen.</p>
<pre class="haskell"><code>safeHead (x:xs) = Some x
safeHead []     = None
</code></pre>
</div>
<div class="slide">
<h1 id="some-none-1">Some? None?</h1>
<ul>
<li><p>We gebruiken een constructor met de naam <code>Some</code> om het idee te vangen: &quot;We hebben een resultaat&quot;.</p></li>
<li><p>De constructor <code>None</code> geeft aan: &quot;We hebben hier geen resultaat&quot;.</p></li>
</ul>
<p>Om deze constructors in het leven te roepen, definiëren we een nieuw type.</p>
<pre class="haskell"><code>data Perhaps a = Some a
               | None
</code></pre>
<p>Het <code>|</code> teken scheidt de constructors. We lezen het als volgt:</p>
<ul>
<li><p>Het <code>Perhaps</code> type kent twee constructors:</p></li>
<li><p><code>Some</code> gevolgd door één argument</p></li>
<li><p>of <code>None</code> zonder argumenten</p></li>
</ul>
</div>
<div class="slide">
<h1 id="maybe-1">Maybe</h1>
<p>Eigenlijk heeft Haskell al een <code>Perhaps</code> type.</p>
<pre class="haskell"><code>data Maybe a = Just a
             | Nothing
</code></pre>
<p>De <code>a</code> is een <em>type parameter</em>, met als betekenis dat als we dit type opschrijven, dat we dan een ander moeten toevoegen als parameter:</p>
<ul>
<li><p><code>Maybe Int</code></p></li>
<li><p><code>Maybe String</code></p></li>
</ul>
</div>
<div class="slide">
<h1 id="gebruik-maken-van-constructors-1">Gebruik maken van constructors</h1>
<p>Als we een <code>Maybe Int</code> willen samenstellen door gebruik te maken van de <code>Just</code> constructor, dan moeten we een <code>Int</code> meegeven.</p>
<pre class="haskell"><code>Just 1  :: Maybe Int
Nothing :: Maybe Int
</code></pre>
<p>Dit gaat niet werken, want de types komen niet overeen:</p>
<pre class="haskell"><code>Just [1] :: Maybe String
</code></pre>
</div>
<div class="slide">
<h1 id="pattern-matching-met-constructors-1">Pattern matching met constructors</h1>
<p>We kunnen pattern matchen met constructors van <code>Maybe</code> op dezelfde manier als dat we dat hebben gedaan voor lijsten.</p>
<pre class="haskell"><code>case foo of
  Just x  -&gt; x
  Nothing -&gt; bar
</code></pre>
</div>
<div class="slide">
<h1 id="tags-1">Tags</h1>
<p>Het <code>tagsoup</code> package definieert het volgende type:</p>
<pre class="haskell"><code>data Tag = TagOpen String [Attribute]
         | TagClose String
         | TagText String
         | TagComment String
         | TagWarning String
         | TagPosition Row Column
</code></pre>
<p>Wat denk je dat deze constructors kunnen betekenen?</p>
</div>
<div class="slide">
<h1 id="pattern-matching-over-een-tag-1">Pattern matching over een Tag</h1>
<p>Stel dat we een predikaat willen schrijven die aangeeft of een <code>Tag</code> een opening tag is.</p>
<ul>
<li><p>Wat zou het type van deze functie zijn?</p></li>
<li><p>Hoe zou de bode van de functie er uit zien?</p></li>
</ul>
</div>
<div class="slide">
<h1 id="om-het-even-1">Om het even!</h1>
<p>Onze eerste body zag er als volgt uit:</p>
<pre class="haskell"><code>isOpenTag (TagOpen x y)     = True
isOpenTag (TagClose x)      = False
isOpenTag (TagText x)       = False
isOpenTag (TagComment x)    = False
isOpenTag (TagWarning x)    = False
isOpenTag (TagPosition x y) = False
</code></pre>
<p>Beknopt, maar lelijk.</p>
<ul>
<li><p>We zijn maar in precies één constructor geïnteresseerd.</p></li>
<li><p>We gebruiken de gedeclareerde variabelen <code>x</code> or <code>y</code> helemaal niet.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="het-wild-card-patroon-1">Het wild card patroon</h1>
<p>We kunnen met het &quot;<code>_</code>&quot; teken opschrijven dat het ons niet uitmaakt wat een patroon of variabele precies is.</p>
<pre class="haskell"><code>isOpenTag (TagOpen _ _) = True
isOpenTag  _            = False
</code></pre>
<p>Het wild card patroon matcht altijd.</p>
<ul>
<li><p>Aangezien we toch geen gebruik maken van <code>x</code> of <code>y</code>, kunnen we dat expliciet aangeven door gebruik te maken van <code>_</code>.</p></li>
<li><p>Aangezien elke constructor behalve <code>TagOpen</code> ons niets interesseert, kunnen we ze allemaal laten matchen met <code>_</code>.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="even-een-vraag-tussendoor-1">Even een vraag tussendoor</h1>
<p>Waarom schrijven we de functie niet op deze manier?</p>
<pre class="haskell"><code>isOpenTag  _            = False
isOpenTag (TagOpen _ _) = True
</code></pre>
</div>
<div class="slide">
<h1 id="extractie-van-de-links-van-een-webpagina-1">Extractie van de links van een webpagina</h1>
<p>Stel dat we al een pagina geladen hebben.</p>
<ul>
<li><p>Bekijk de <code>tagsoup</code> documentatie in de module <code>Text.HTML.TagSoup</code> .</p></li>
<li><p>Zoek een functie die een webpagina parsed in een serie tags.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="die-kunnen-we-mooi-gebruiken-1">Die kunnen we mooi gebruiken!</h1>
<pre class="haskell"><code>processPage url = do
  page &lt;- download url
  return (parseTags page)
</code></pre>
</div>
<div class="slide">
<h1 id="tags-opschonen-1">Tags opschonen</h1>
<p>De geparsede tags kunnen verschillende soorten tag namen hebben.</p>
<pre><code>&lt;A HREF=&quot;...&quot;&gt;
</code></pre>
<pre><code>&lt;a hrEF=&quot;...&quot;&gt;
</code></pre>
<ul>
<li>Zoek een <code>tagsoup</code> functie die tag namen en attributen omzet in kleine letters.</li>
</ul>
</div>
<div class="slide">
<h1 id="tags-in-normaalvorm-1">Tags in normaalvorm</h1>
<p>Laten we onze functie gebruiken om het resultaat van <code>parseTags</code> op te schonen.</p>
<pre class="haskell"><code>processPage url = do
  page &lt;- download url
  return
    (canonicalizeTags
      (parseTags page))
</code></pre>
</div>
<div class="slide">
<h1 id="extractie-van-links-1">Extractie van links</h1>
<p>We zijn alleen geïnteresseerd in open tags die links bevatten, dus <code>&lt;a&gt;</code> tags.</p>
<ul>
<li><p>Hoe zouden we het type functie schrijven die aangeeft of een <code>Tag</code> een open tag is met de juiste naam?</p></li>
<li><p>Hoe zouden we die functie gebruiken om alleen de open tags over te houden van een lijst van geparsede tags?</p></li>
</ul>
</div>
<div class="slide">
<h1 id="poeh-hee-1">Poeh hee!</h1>
<p>Deze cascade begint belachelijke vormen te krijgen.</p>
<pre class="haskell"><code>processPage url = do
  page &lt;- download url
  return
    (filter (isTagOpenName &quot;a&quot;)
      (canonicalizeTags
        (parseTags page)))
</code></pre>
<p>Twee observaties:</p>
<ul>
<li><p>Onze actie is nu voor het merendeel pure code.</p></li>
<li><p>Het lijkt wel een pijplijn.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="een-herschrijf-oefening-1">Een herschrijf oefening</h1>
<p>Verdeel de functie in pure en niet-pure delen.</p>
<p>Schrijf het pure gedeelte met gebruikmaking van functie compositie.</p>
<pre class="haskell"><code>processPage url = do
  page &lt;- download url
  return
    (filter (isTagOpenName &quot;a&quot;)
      (canonicalizeTags
        (parseTags page)))
</code></pre>
</div>
<div class="slide">
<h1 id="mijn-oplossing-1">Mijn oplossing</h1>
<pre class="haskell"><code>processPage url = do
  page &lt;- download url
  return (process page)

process =
    filter (isTagOpenName &quot;a&quot;) .
    canonicalizeTags .
    parseTags
</code></pre>
</div>
<div class="slide">
<h1 id="we-willen-nog-meer-kwijt-1">We willen nog meer kwijt</h1>
<p>Laten we de <code>nofollow</code> links ook weglaten.</p>
<p>We willen het <code>&quot;rel&quot;</code> attribuut van een tag.</p>
<ul>
<li>Zoek een functie die een attribuut van een tag teruggeeft.</li>
</ul>
</div>
<div class="slide">
<h1 id="geen-following-1">Geen following</h1>
<pre class="haskell"><code>nofollow tag = fromAttrib &quot;rel&quot; tag == &quot;nofollow&quot;
</code></pre>
<pre class="haskell"><code>process =
    filter (not . nofollow) .
    filter (isTagOpenName &quot;a&quot;) .
    canonicalizeTags .
    parseTags
</code></pre>
</div>
<div class="slide">
<h1 id="we-hebben-een-lijst-met-a-tags-1">We hebben een lijst met &lt;a&gt; tags</h1>
<p>Hoe zouden we het <code>&quot;href&quot;</code> attribuute ophalen van elk element uit de lijst?</p>
</div>
<div class="slide">
<h1 id="allen-niet-lege-a-href-tags-1">Allen niet-lege &lt;a href&gt; tags</h1>
<pre class="haskell"><code>process =
    filter (not . null) .
    map (fromAttrib &quot;href&quot;) .
    filter (not . nofollow) .
    filter (isTagOpenName &quot;a&quot;) .
    canonicalizeTags .
    parseTags
</code></pre>
</div>
<div class="slide">
<h1 id="urls-in-normaalvorm-1">URLs in normaalvorm</h1>
<p>Links kunnen absoluut, relatief of onzinnige rommel zijn. We willen alleen maar absolute links die er geldig uitzien.</p>
<p>Om netjes een absolute link te maken moeten we de absolute URL kennen van de pagina waar we naar kijken.</p>
<pre class="haskell"><code>canonicalizeLink :: String -&gt; String -&gt; Maybe String
</code></pre>
</div>
<div class="slide">
<h1 id="werken-met-uris-1">Werken met URIs</h1>
<p>Het package <code>Network.URI</code> bevat een paar functies die hier goed van pas komen.</p>
<pre class="haskell"><code>parseURI :: String -&gt; Maybe URI
parseURIReference :: String -&gt; Maybe URI
uriToString id &quot;&quot; :: URI -&gt; String
nonStrictRelativeTo :: URI -&gt; URI -&gt; Maybe URI
</code></pre>
</div>
<div class="slide">
<h1 id="een-draak-van-een-inspringer-1">Een draak van een inspringer</h1>
<p>Dit is niet meer om te lezen!</p>
<pre class="haskell"><code>import Network.URI

canon :: String -&gt; String -&gt; Maybe String
canon referer path =
  case parseURI referer of
    Nothing -&gt; Nothing
    Just r  -&gt;
      case parseURIReference path of
        Nothing -&gt; Nothing
        Just p  -&gt;
          case nonStrictRelativeTo p r of
            Nothing -&gt; Nothing
            Just u -&gt;
             Just (uriToString id u &quot;&quot;)
</code></pre>
<p>Dat kan vast beter.</p>
</div>
<div class="slide">
<h1 id="traplopen-1">Traplopen</h1>
<p>Is het je opgevallen dat die functie een serie is van met <code>case</code> inspecties van <code>Maybe</code> waarden?</p>
<p>Stel je voor dat we een functie zouden hebben die een gewone waarde als input heeft, en die een <code>Maybe</code> waarde teruggeeft.</p>
<pre class="haskell"><code>a -&gt; Maybe b
</code></pre>
<p>En stel je voor dat we een beknopte syntax hebben om een anonieme functie te schrijven.</p>
<pre class="haskell"><code>\a -&gt; &quot;hoi mam! &quot; ++ a
</code></pre>
<p>De <code>\</code> noemen we &quot;lambda&quot;.</p>
</div>
<div class="slide">
<h1 id="observatie-1">Observatie</h1>
<p>De inspectie met <code>case</code> is nogal breedsprakig. Stel dat we een functie zouden hebben die de inspectie deed, en een andere functie zou aanroepen als de waarde een <code>Just</code> was.</p>
<pre class="haskell"><code>bind :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b
bind  Nothing      _     = Nothing
bind (Just value) action = action value
</code></pre>
</div>
<div class="slide">
<h1 id="het-gebruik-van-bind-1">Het gebruik van bind</h1>
<p>Hoe kunnen we dit gebruiken?</p>
<pre class="haskell"><code>canon1 referer path =
  parseURI referer                `bind`
   \r -&gt; parseURIReference path   `bind`
    \p -&gt; nonStrictRelativeTo p r `bind`
     \u -&gt; Just (uriToString id u &quot;&quot;)
</code></pre>
<p>Als we een functienaam omsluiten in &quot;`&quot;-tekens, dan kunnen we de functie als infix operator gebruiken.</p>
</div>
<div class="slide">
<h1 id="een-andere-layout-van-dezelfde-code-1">Een andere layout van dezelfde code</h1>
<pre class="haskell"><code>canon referer path =
  parseURI referer         `bind` \r -&gt;
  parseURIReference path   `bind` \p -&gt;
  nonStrictRelativeTo p r  `bind` \u -&gt;
  Just (uriToString id u &quot;&quot;)
</code></pre>
</div>
<div class="slide">
<h1 id="een-ingebouwde-naam-voor-bind-1">Een ingebouwde naam voor bind</h1>
<p>De <code>&gt;&gt;=</code> operator is een generieke versie van onze <code>bind</code> functie.</p>
<pre class="haskell"><code>canon referer path =
  parseURI referer &gt;&gt;= \r -&gt;
  parseURIReference path &gt;&gt;= \p -&gt;
  nonStrictRelativeTo p r &gt;&gt;= \u -&gt;
  Just (uriToString id u &quot;&quot;)
</code></pre>
</div>
<div class="slide">
<h1 id="gebruik-maken-van-vereenvoudigde-schrijfwijze-1">Gebruik maken van vereenvoudigde schrijfwijze</h1>
<p>Hier is wat nettere syntax, die je vast bekend voorkomt.</p>
<pre class="haskell"><code>canonicalize :: String -&gt; String -&gt; Maybe String

canonicalize referer path = do
  r &lt;- parseURI referer
  p &lt;- parseURIReference path
  u &lt;- nonStrictRelativeTo p r
  return (uriToString id u &quot;&quot;)
</code></pre>
</div>
<div class="slide">
<h1 id="bijna-klaar-1">Bijna klaar</h1>
<pre class="haskell"><code>process url =
   map (canonicalize url) .
   filter (not . null) .
   map (fromAttrib &quot;href&quot;) .
   filter (\t -&gt; fromAttrib &quot;rel&quot; t /= &quot;nofollow&quot;) .
   filter (isTagOpenName &quot;a&quot;) .
   canonicalizeTags .
   parseTags
</code></pre>
<p>Da's nou onhandig: wat is het type van deze functie?</p>
</div>
<div class="slide">
<h1 id="van-maybe-a-naar-a-1">Van [Maybe a] naar [a]</h1>
<p>Ga naar deze website:</p>
<ul>
<li><a href="http://haskell.org/hoogle">haskell.org/hoogle</a></li>
</ul>
<p>Typ dit in de search box:</p>
<pre class="haskell"><code>[Maybe a] -&gt; [a]
</code></pre>
<p>Wat zien we als eerste resultaat?</p>
</div>
<div class="slide">
<h1 id="klaar-1">Klaar!</h1>
<pre class="haskell"><code>import Data.Maybe
import Network.URI

links url =
  catMaybes .
  map (canonicalize url) .
  filter (not . null) .
  map (fromAttrib &quot;href&quot;) .
  filter (\t -&gt; fromAttrib &quot;rel&quot; t /= &quot;nofollow&quot;) .
  filter (isTagOpenName &quot;a&quot;) .
  canonicalizeTags .
  parseTags
</code></pre>
</div>
<div class="slide">
<h1 id="van-links-naar-spideren-1">Van links naar spideren</h1>
<p>Als we de links van een webpagina af kunnen halen, kunnen we eenvoudig een spider schrijven om die links te volgen.</p>
<p>Om het eenvoudig te houden, zetten we een limiet op het aantal pagina's dat we willen downloaden.</p>
<p>Welke informatie willen we genereren?</p>
<p>Wat willen we onderweg bijhouden?</p>
</div>
<div class="slide">
<h1 id="wat-we-willen-bijhouden-1">Wat we willen bijhouden</h1>
<p>De status die we willen bijhouden:</p>
<ul>
<li><p>Het aantal pagina's dat we hebben gedownload</p></li>
<li><p>Een verzameling pagina's waar we links naartoe hebben gezien, maar die we (nog) niet hebben gedownload</p></li>
<li><p>Een verzameling pagina's met hun uitgaande links</p></li>
</ul>
</div>
<div class="slide">
<h1 id="bijhouden-wat-we-gezien-hebben-1">Bijhouden wat we gezien hebben</h1>
<p>Voor een willekeurige pagina, willen we de pagina zelf bewaren en alle pagina's waar het naar verwijst.</p>
<p>Een mogelijkheid om deze twee te associeren is een <em>tuple</em>:</p>
<pre class="haskell"><code>(&quot;http://x.org/&quot;, [&quot;http://microsoft.com/&quot;])
</code></pre>
<p>Tuples zijn nuttig als we verschillende soorten data hebben zonder dat we het gedoe willen van het definieren van een nieuw type.</p>
<p>Nu we het toch over een nieuw type hebben, zo definieer je er een:</p>
<pre class="haskell"><code>data Link = Link String [String]

-- Let's define some accessors, too.
linkFrom (Link url _) = url
linkTo (Link _ links) = links
</code></pre>
</div>
<div class="slide">
<h1 id="dubbelingen-voork&#243;men-1">Dubbelingen voorkómen</h1>
<p>We willen een URL niet twee keer bezoeken.</p>
<p>Hoe voorkomen we dat?</p>
<pre class="haskell"><code>visited url = elem url . map linkTo
</code></pre>
<p>Deze functie heeft een probleem - zie je welk probleem?</p>
</div>
<div class="slide">
<h1 id="betere-performance-1">Betere performance</h1>
<p>We willen een structuur met een snelle opzoek operatie.</p>
<p>Wat zou je in jouw programmeertaal gebruiken?</p>
</div>
<div class="slide">
<h1 id="maps-and-importing-1">Maps and importing</h1>
<p>In Haskell bestaan muteerbare hash tables, maar die gebruiken we niet.</p>
<p>in plaats hiervan gebruiken we liever <em>onveranderlijke</em> key-value maps.</p>
<p>We moeten de nodige trucks uithalen bij het importeren, want de <code>Data.Map</code> module definieert veel namen die anders zouden overlappen met ingebouwde namen.</p>
<p>Dit betekent &quot;importeer alleen de naam <code>Map</code> van de module <code>Data.Map</code>&quot;:</p>
<pre class="haskell"><code>import Data.Map (Map)
</code></pre>
<p>En dit betekent &quot;importeer alles van <code>Data.Map</code>, maar elk van deze namen moet voorafgegaan worden door <code>Map.</code>&quot;:</p>
<pre class="haskell"><code>import qualified Data.Map as Map
</code></pre>
</div>
<div class="slide">
<h1 id="wat-is-het-nut-van-een-onveranderlijke-data-structuur-1">Wat is het nut van een onveranderlijke data structuur?</h1>
<p>Is iedereen bekend hoe je een key-value paar aan een hash tabel toevoegt?</p>
<p>En dat lijkt een fundamentele operatie.</p>
<p>Wat doen we met maps?</p>
<ul>
<li>Maak een <em>nieuwe</em> map die identiek is aan de map die we aanleveren, met het gevraagde element toegevoegd.</li>
</ul>
<p>Hoe kan dat nou werken? Is het efficient?</p>
</div>
<div class="slide">
<h1 id="een-hand-vol-dollars-1">Een hand vol dollars</h1>
<p>Hier is een verbazingwekkend handige ingebouwde operator:</p>
<pre class="haskell"><code>f $ x = f x
</code></pre>
<p>Waarom is dit nuttig? Omdat we hierdoor haakjes kunnen weglaten.</p>
<p>zonder $:</p>
<pre class="haskell"><code>explode k = error (&quot;failed on &quot; ++ show k)
</code></pre>
<p>met $:</p>
<pre class="haskell"><code>explode k = error $ &quot;failed on &quot; ++ show k
</code></pre>
</div>
<div class="slide">
<h1 id="partiele-toepassing-1">Partiele toepassing</h1>
<p>Dit is onhandig om op te schrijven:</p>
<pre class="haskell"><code>increment k = 1 + k
</code></pre>
<p>Bijna net zo erg:</p>
<pre class="haskell"><code>\k -&gt; 1 + k
</code></pre>
<p>Veel handiger, en identiek:</p>
<pre class="haskell"><code>(1+)
</code></pre>
<p>Dit is valide:</p>
<pre class="haskell"><code>increment = (1+)
</code></pre>
</div>
<div class="slide">
<h1 id="spideren-in-al-zijn-glans-1">Spideren, in al zijn glans</h1>
<pre class="haskell"><code>spider :: Int -&gt; URL -&gt; IO (Map URL [URL])
spider count url0 = go 0 Map.empty (Set.singleton url0)
  where
    go k seen queue0
        | k &gt;= count = return seen
        | otherwise  =
      case Set.minView queue0 of
        Nothing -&gt; return seen
        Just (url, queue) -&gt; do
          page &lt;- download url
          let ls       = links url page
              newSeen  = Map.insert url ls seen
              notSeen  = Set.fromList .
                         filter (`Map.notMember` newSeen) $ ls
              newQueue = queue `Set.union` notSeen
          go (k+1) newSeen newQueue
</code></pre>
</div>
<div class="slide">
<h1 id="stand-van-zaken-1">Stand van zaken?</h1>
<p>We kunnen nu:</p>
<ul>
<li><p>Een webpagina downloaden</p></li>
<li><p>De links ervan extraheren</p></li>
<li><p>van daar uit verder <code>spideren</code>, zonder doublures</p></li>
</ul>
<p>Wat blijft over?</p>
<ul>
<li><p>We zouden meerdere pagina's tegelijkertijd kunnen spideren</p></li>
<li><p>Of we zouden kunnen berekenen welke pagina's &quot;belangrijk&quot; zijn</p></li>
</ul>
</div>
<div class="slide">
<h1 id="fin-1">Fin</h1>
<p>In het hoogst onwaarschijnlijke geval dat we hier aankomen voordat we uit de tijd zijn gelopen, gaam we verder in een we-zien-wel-wat-voor-avontuur sessie.</p>
<p>Bedankt dat je tot nu toe niet bent afgehaakt!</p>
</div>
<div class="slide">
<h1 id="copy-these-slides-if-you-want-1">Copy these slides (if you want)</h1>
<pre><code>git clone https://github.com/hanjoosten/strange-loop-2011
</code></pre>
</div>
</body>
</html>
