<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Bryan O'Sullivan" />
  <meta name="date" content="2011-09-18" />
  <style type="text/css">
/*<![CDATA[*/
/* slidy.css

   Copyright (c) 2005-2010 W3C (MIT, ERCIM, Keio), All Rights Reserved.
   W3C liability, trademark, document use and software licensing
   rules apply, see:

   http://www.w3.org/Consortium/Legal/copyright-documents
   http://www.w3.org/Consortium/Legal/copyright-software
*/
body
{
  margin: 0 0 0 0;
  padding: 0 0 0 0;
  width: 100%;
  height: 100%;
  color: black;
  background-color: white;
  font-family: "Gill Sans MT", "Gill Sans", GillSans, sans-serif;
  font-size: 14pt;
}

div.toolbar {
  position: fixed; z-index: 200;
  top: auto; bottom: 0; left: 0; right: 0;
  height: 1.2em; text-align: right;
  padding-left: 1em;
  padding-right: 1em; 
  font-size: 60%;
  color: red;
  background-color: rgb(240,240,240);
  border-top: solid 1px rgb(180,180,180);
}

div.toolbar span.copyright {
  color: black;
  margin-left: 0.5em;
}

div.initial_prompt {
  position: absolute;
  z-index: 1000;
  bottom: 1.2em;
  width: 100%;
  background-color: rgb(200,200,200);
  opacity: 0.35;
  background-color: rgb(200,200,200, 0.35);
  cursor: pointer;
}

div.initial_prompt p.help {
  text-align: center;
}

div.initial_prompt p.close {
  text-align: right;
  font-style: italic;
}

div.slidy_toc {
  position: absolute;
  z-index: 300;
  width: 60%;
  max-width: 30em;
  height: 30em;
  overflow: auto;
  top: auto;
  right: auto;
  left: 4em;
  bottom: 4em;
  padding: 1em;
  background: rgb(240,240,240);
  border-style: solid;
  border-width: 2px;
  font-size: 60%;
}

div.slidy_toc .toc_heading {
  text-align: center;
  width: 100%;
  margin: 0;
  margin-bottom: 1em;
  border-bottom-style: solid;
  border-bottom-color: rgb(180,180,180);
  border-bottom-width: 1px;
}

div.slide {
  z-index: 20;
  margin: 0 0 0 0;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 20px;
  padding-right: 20px;
  border-width: 0;
  clear: both;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  line-height: 120%;
  background-color: transparent;
}

div.background {
  display: none;
}

div.handout {
  margin-left: 20px;
  margin-right: 20px;
}

div.slide.titlepage {
  text-align: center;
}

div.slide.titlepage h1 {
  padding-top: 10%;
  margin-right: 0;
}

div.slide h1 {
  padding-left: 0;
  padding-right: 20pt;
  padding-top: 4pt;
  padding-bottom: 4pt;
  margin-top: 0;
  margin-left: 0;
  margin-right: 60pt;
  margin-bottom: 0.5em;
  display: block; 
  font-size: 160%;
  line-height: 1.2em;
  background: transparent;
}

div.toc {
  position: absolute;
  top: auto;
  bottom: 4em;
  left: 4em;
  right: auto;
  width: 60%;
  max-width: 30em;
  height: 30em;
  border: solid thin black;
  padding: 1em;
  background: rgb(240,240,240);
  color: black;
  z-index: 300;
  overflow: auto;
  display: block;
  visibility: visible;
}

div.toc-heading {
  width: 100%;
  border-bottom: solid 1px rgb(180,180,180);
  margin-bottom: 1em;
  text-align: center;
}

pre {
 font-size: 80%;
 font-weight: bold;
 line-height: 120%;
 padding-top: 0.2em;
 padding-bottom: 0.2em;
 padding-left: 1em;
 padding-right: 1em;
 border-style: solid;
 border-left-width: 1em;
 border-top-width: thin;
 border-right-width: thin;
 border-bottom-width: thin;
 border-color: #95ABD0;
 color: #00428C;
 background-color: #E4E5E7;
}

li pre { margin-left: 0; }

blockquote { font-style: italic }

img { background-color: transparent }

p.copyright { font-size: smaller }

.center { text-align: center }
.footnote { font-size: smaller; margin-left: 2em; }

a img { border-width: 0; border-style: none }

a:visited { color: navy }
a:link { color: navy }
a:hover { color: red; text-decoration: underline }
a:active { color: red; text-decoration: underline }

a {text-decoration: none}
.navbar a:link {color: white}
.navbar a:visited {color: yellow}
.navbar a:active {color: red}
.navbar a:hover {color: red}

ul { list-style-type: square; }
ul ul { list-style-type: disc; }
ul ul ul { list-style-type: circle; }
ul ul ul ul { list-style-type: disc; }
li { margin-left: 0.5em; margin-top: 0.5em; }
li li { font-size: 85%; font-style: italic }
li li li { font-size: 85%; font-style: normal }

div dt
{
  margin-left: 0;
  margin-top: 1em;
  margin-bottom: 0.5em;
  font-weight: bold;
}
div dd
{
  margin-left: 2em;
  margin-bottom: 0.5em;
}


p,pre,ul,ol,blockquote,h2,h3,h4,h5,h6,dl,table {
  margin-left: 1em;
  margin-right: 1em;
}

p.subhead { font-weight: bold; margin-top: 2em; }

.smaller { font-size: smaller }
.bigger { font-size: 130% }

td,th { padding: 0.2em }

ul {
  margin: 0.5em 1.5em 0.5em 1.5em;
  padding: 0;
}

ol {
  margin: 0.5em 1.5em 0.5em 1.5em;
  padding: 0;
}

ul { list-style-type: square; }
ul ul { list-style-type: disc; }
ul ul ul { list-style-type: circle; }
ul ul ul ul { list-style-type: disc; }

ul li { 
  list-style: square;
  margin: 0.1em 0em 0.6em 0;
  padding: 0 0 0 0;
  line-height: 140%;
}

ol li { 
  margin: 0.1em 0em 0.6em 1.5em;
  padding: 0 0 0 0px;
  line-height: 140%;
  list-style-type: decimal;
}

li ul li { 
  font-size: 85%; 
  font-style: italic;
  list-style-type: disc;
  background: transparent;
  padding: 0 0 0 0;
}
li li ul li { 
  font-size: 85%; 
  font-style: normal;
  list-style-type: circle;
  background: transparent;
  padding: 0 0 0 0;
}
li li li ul li {
  list-style-type: disc;
  background: transparent;
  padding: 0 0 0 0;
}

li ol li {
  list-style-type: decimal;
}


li li ol li {
  list-style-type: decimal;
}

/*
 setting class="outline on ol or ul makes it behave as an
 ouline list where blocklevel content in li elements is
 hidden by default and can be expanded or collapsed with
 mouse click. Set class="expand" on li to override default
*/

ol.outline li:hover { cursor: pointer }
ol.outline li.nofold:hover { cursor: default }

ul.outline li:hover { cursor: pointer }
ul.outline li.nofold:hover { cursor: default }

ol.outline { list-style:decimal; }
ol.outline ol { list-style-type:lower-alpha }

ol.outline li.nofold {
  padding: 0 0 0 20px;
  background: transparent url(../graphics/nofold-dim.gif) no-repeat 0px 0.5em;
}
ol.outline li.unfolded {
  padding: 0 0 0 20px;
  background: transparent url(../graphics/fold-dim.gif) no-repeat 0px 0.5em;
}
ol.outline li.folded {
  padding: 0 0 0 20px;
  background: transparent url(../graphics/unfold-dim.gif) no-repeat 0px 0.5em;
}
ol.outline li.unfolded:hover {
  padding: 0 0 0 20px;
  background: transparent url(../graphics/fold.gif) no-repeat 0px 0.5em;
}
ol.outline li.folded:hover {
  padding: 0 0 0 20px;
  background: transparent url(../graphics/unfold.gif) no-repeat 0px 0.5em;
}

ul.outline li.nofold {
  padding: 0 0 0 20px;
  background: transparent url(../graphics/nofold-dim.gif) no-repeat 0px 0.5em;
}
ul.outline li.unfolded {
  padding: 0 0 0 20px;
  background: transparent url(../graphics/fold-dim.gif) no-repeat 0px 0.5em;
}
ul.outline li.folded {
  padding: 0 0 0 20px;
  background: transparent url(../graphics/unfold-dim.gif) no-repeat 0px 0.5em;
}
ul.outline li.unfolded:hover {
  padding: 0 0 0 20px;
  background: transparent url(../graphics/fold.gif) no-repeat 0px 0.5em;
}
ul.outline li.folded:hover {
  padding: 0 0 0 20px;
  background: transparent url(../graphics/unfold.gif) no-repeat 0px 0.5em;
}

/* for slides with class "title" in table of contents */
a.titleslide { font-weight: bold; font-style: italic }

/*
 hide images for work around for save as bug
 where browsers fail to save images used by CSS
*/
img.hidden { display: none; visibility: hidden }
div.initial_prompt { display: none; visibility: hidden }

  div.slide {
     visibility: visible;
     position: inherit;
  }
  div.handout {
     border-top-style: solid;
     border-top-width: thin;
     border-top-color: black;
  }

@media screen {
  .hidden { display: none; visibility: visible }

  div.slide.hidden { display: block; visibility: visible }
  div.handout.hidden { display: block; visibility: visible }
  div.background { display: none; visibility: hidden }
  body.single_slide div.initial_prompt { display: block; visibility: visible }
  body.single_slide div.background { display: block; visibility: visible }
  body.single_slide div.background.hidden { display: none; visibility: hidden }
  body.single_slide .invisible { visibility: hidden }
  body.single_slide .hidden { display: none; visibility: hidden }
  body.single_slide div.slide { position: absolute }
  body.single_slide div.handout { display: none; visibility: hidden }
}

@media print {
  .hidden { display: block; visibility: visible }

  div.slide pre { font-size: 60%; padding-left: 0.5em; }
  div.toolbar { display: none; visibility: hidden; }
  div.slidy_toc { display: none; visibility: hidden; }
  div.background { display: none; visibility: hidden; }
  div.slide { page-break-before: always }
  /* :first-child isn't reliable for print media */
  div.slide.first-slide { page-break-before: avoid }
}

/*]]>*/
  </style>
<script type="text/javascript" charset="utf-8">
/*<![CDATA[*/
var w3c_slidy={ns_pos:(typeof window.pageYOffset!="undefined"),khtml:((navigator.userAgent).indexOf("KHTML")>=0?true:false),opera:((navigator.userAgent).indexOf("Opera")>=0?true:false),ipad:((navigator.userAgent).indexOf("iPad")>=0?true:false),iphone:((navigator.userAgent).indexOf("iPhone")>=0?true:false),ie:(typeof document.all!="undefined"&&!this.opera),ie6:(!this.ns_pos&&navigator.userAgent.indexOf("MSIE 6")!=-1),ie7:(!this.ns_pos&&navigator.userAgent.indexOf("MSIE 7")!=-1),ie8:(!this.ns_pos&&navigator.userAgent.indexOf("MSIE 8")!=-1),ie9:(!this.ns_pos&&navigator.userAgent.indexOf("MSIE 9")!=-1),keyboardless:(this.ipad||this.iphone),is_xhtml:/xml/.test(document.contentType),slide_number:0,slide_number_element:null,slides:[],notes:[],backgrounds:[],toolbar:null,title:null,last_shown:null,eos:null,toc:null,outline:null,selected_text_len:0,view_all:0,want_toolbar:true,mouse_click_enabled:true,scroll_hack:0,disable_slide_click:false,lang:"en",help_anchor:null,help_page:"http://www.w3.org/Talks/Tools/Slidy2/help/help.html",help_text:"Navigate with mouse click, space bar, Cursor Left/Right, or Pg Up and Pg Dn. Use S and B to change font size.",size_index:0,size_adjustment:0,sizes:new Array("10pt","12pt","14pt","16pt","18pt","20pt","22pt","24pt","26pt","28pt","30pt","32pt"),last_width:0,last_height:0,objects:[],set_up:function(){var a=function(){w3c_slidy.init()};if(typeof window.addEventListener!="undefined"){window.addEventListener("load",a,false)}else{window.attachEvent("onload",a)}},hide_slides:function(){if(document.body&&!w3c_slidy.initialized){document.body.style.visibility="hidden"}else{setTimeout(w3c_slidy.hide_slides,50)}},ie_hack:function(){window.resizeBy(0,-1);window.resizeBy(0,1)},init:function(){document.body.style.visibility="visible";this.init_localization();this.add_toolbar();this.wrap_implicit_slides();this.collect_slides();this.collect_notes();this.collect_backgrounds();this.objects=document.body.getElementsByTagName("object");this.patch_anchors();this.slide_number=this.find_slide_number(location.href);window.offscreenbuffering=true;this.size_adjustment=this.find_size_adjust();this.time_left=this.find_duration();this.hide_image_toolbar();this.init_outliner();this.title=document.title;this.is_xhtml=(document.body.tagName=="BODY"?false:true);if(this.slides.length>0){var a=this.slides[this.slide_number];if(this.slide_number>0){this.set_visibility_all_incremental("visible");this.last_shown=this.previous_incremental_item(null);this.set_eos_status(true)}else{this.last_shown=null;this.set_visibility_all_incremental("hidden");this.set_eos_status(!this.next_incremental_item(this.last_shown))}this.set_location();this.add_class(this.slides[0],"first-slide");w3c_slidy.show_slide(a)}this.toc=this.table_of_contents();this.add_initial_prompt();if(!this.keyboardless){this.add_listener(document.body,"click",this.mouse_button_click)}this.add_listener(document,"keydown",this.key_down);this.add_listener(document,"keypress",this.key_press);this.add_listener(window,"resize",this.resized);this.add_listener(window,"scroll",this.scrolled);this.add_listener(window,"unload",this.unloaded);this.single_slide_view();this.resized();if(this.ie7){setTimeout(w3c_slidy.ie_hack,100)}this.show_toolbar();setInterval(function(){w3c_slidy.check_location()},200);w3c_slidy.initialized=true},table_of_contents:function(){var c=this.create_element("div");this.add_class(c,"slidy_toc hidden");var k=this.create_element("div");this.add_class(k,"toc-heading");k.innerHTML=this.localize("Table of Contents");c.appendChild(k);var f=null;for(var d=0;d<this.slides.length;++d){var g=this.has_class(this.slides[d],"title");var e=document.createTextNode((d+1)+". ");c.appendChild(e);var h=this.create_element("a");h.setAttribute("href","#("+(d+1)+")");if(g){this.add_class(h,"titleslide")}var b=document.createTextNode(this.slide_name(d));h.appendChild(b);h.onclick=w3c_slidy.toc_click;h.onkeydown=w3c_slidy.toc_key_down;h.previous=f;if(f){f.next=h}c.appendChild(h);if(d==0){c.first=h}if(d<this.slides.length-1){var j=this.create_element("br");c.appendChild(j)}f=h}c.focus=function(){if(this.first){this.first.focus()}};c.onmouseup=w3c_slidy.mouse_button_up;c.onclick=function(a){a||(a=window.event);if(w3c_slidy.selected_text_len<=0){w3c_slidy.hide_table_of_contents(true)}w3c_slidy.stop_propagation(a);if(a.cancel!=undefined){a.cancel=true}if(a.returnValue!=undefined){a.returnValue=false}return false};document.body.insertBefore(c,document.body.firstChild);return c},is_shown_toc:function(){return !w3c_slidy.has_class(w3c_slidy.toc,"hidden")},show_table_of_contents:function(){w3c_slidy.remove_class(w3c_slidy.toc,"hidden");var a=w3c_slidy.toc;a.focus();if(w3c_slidy.ie7&&w3c_slidy.slide_number==0){setTimeout(w3c_slidy.ie_hack,100)}},hide_table_of_contents:function(a){w3c_slidy.add_class(w3c_slidy.toc,"hidden");if(a&&!w3c_slidy.opera){w3c_slidy.help_anchor.focus()}},toggle_table_of_contents:function(){if(w3c_slidy.is_shown_toc()){w3c_slidy.hide_table_of_contents(true)}else{w3c_slidy.show_table_of_contents()}},toc_click:function(d){if(!d){d=window.event}var c=w3c_slidy.get_target(d);if(c&&c.nodeType==1){var b=c.getAttribute("href");if(b){var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=w3c_slidy.find_slide_number(b);a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.last_shown=null;w3c_slidy.set_location();w3c_slidy.set_visibility_all_incremental("hidden");w3c_slidy.set_eos_status(!w3c_slidy.next_incremental_item(w3c_slidy.last_shown));w3c_slidy.show_slide(a);try{if(!w3c_slidy.opera){w3c_slidy.help_anchor.focus()}}catch(d){}}}w3c_slidy.hide_table_of_contents(true);if(w3c_slidy.ie7){w3c_slidy.ie_hack()}w3c_slidy.stop_propagation(d);return w3c_slidy.cancel(d)},toc_key_down:function(d){var b;if(!d){var d=window.event}if(window.event){b=window.event.keyCode}else{if(d.which){b=d.which}else{return true}}if(!b){return true}if(d.ctrlKey||d.altKey){return true}if(b==13){var c=this.getAttribute("href");if(c){var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=w3c_slidy.find_slide_number(c);a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.last_shown=null;w3c_slidy.set_location();w3c_slidy.set_visibility_all_incremental("hidden");w3c_slidy.set_eos_status(!w3c_slidy.next_incremental_item(w3c_slidy.last_shown));w3c_slidy.show_slide(a);try{if(!w3c_slidy.opera){w3c_slidy.help_anchor.focus()}}catch(f){}}w3c_slidy.hide_table_of_contents(true);if(self.ie7){w3c_slidy.ie_hack()}return w3c_slidy.cancel(d)}if(b==40&&this.next){this.next.focus();return w3c_slidy.cancel(d)}if(b==38&&this.previous){this.previous.focus();return w3c_slidy.cancel(d)}return true},before_print:function(){this.show_all_slides();this.hide_toolbar();alert("before print")},after_print:function(){if(!this.view_all){this.single_slide_view();this.show_toolbar()}alert("after print")},print_slides:function(){this.before_print();window.print();this.after_print()},toggle_view:function(){if(this.view_all){this.single_slide_view();this.show_toolbar();this.view_all=0}else{this.show_all_slides();this.hide_toolbar();this.view_all=1}},show_all_slides:function(){this.remove_class(document.body,"single_slide");this.set_visibility_all_incremental("visible")},single_slide_view:function(){this.add_class(document.body,"single_slide");this.set_visibility_all_incremental("visible");this.last_shown=this.previous_incremental_item(null)},hide_image_toolbar:function(){if(!this.ns_pos){var a=document.getElementsByTagName("IMG");for(var b=0;b<a.length;++b){a[b].setAttribute("galleryimg","no")}}},unloaded:function(a){},is_KHTML:function(){var a=navigator.userAgent;return(a.indexOf("KHTML")>=0?true:false)},slide_name:function(c){var b=null;var a=this.slides[c];var d=this.find_heading(a);if(d){b=this.extract_text(d)}if(!b){b=this.title+"("+(c+1)+")"}b.replace(/\&/g,"&amp;");b.replace(/\</g,"&lt;");b.replace(/\>/g,"&gt;");return b},find_heading:function(a){if(!a||a.nodeType!=1){return null}if(a.nodeName=="H1"||a.nodeName=="h1"){return a}var b=a.firstChild;while(b){a=this.find_heading(b);if(a){return a}b=b.nextSibling}return null},extract_text:function(a){if(!a){return""}if(a.nodeType==3){return a.nodeValue}if(a.nodeType==1){a=a.firstChild;var b="";while(a){b=b+this.extract_text(a);a=a.nextSibling}return b}return""},find_copyright:function(){var a,c;var d=document.getElementsByTagName("meta");for(var b=0;b<d.length;++b){a=d[b].getAttribute("name");c=d[b].getAttribute("content");if(a=="copyright"){return c}}return null},find_size_adjust:function(){var a,c,e;var d=document.getElementsByTagName("meta");for(var b=0;b<d.length;++b){a=d[b].getAttribute("name");c=d[b].getAttribute("content");if(a=="font-size-adjustment"){return 1*c}}return 1},find_duration:function(){var a,c,e;var d=document.getElementsByTagName("meta");for(var b=0;b<d.length;++b){a=d[b].getAttribute("name");c=d[b].getAttribute("content");if(a=="duration"){return 60000*c}}return null},replace_by_non_breaking_space:function(b){for(var a=0;a<b.length;++a){b[a]=160}},init_outliner:function(){var a=document.getElementsByTagName("li");for(var b=0;b<a.length;++b){var c=a[b];if(!this.has_class(c.parentNode,"outline")){continue}c.onclick=this.outline_click;if(this.foldable(c)){c.foldable=true;c.onfocus=function(){w3c_slidy.outline=this};c.onblur=function(){w3c_slidy.outline=null};if(!c.getAttribute("tabindex")){c.setAttribute("tabindex","0")}if(this.has_class(c,"expand")){this.unfold(c)}else{this.fold(c)}}else{this.add_class(c,"nofold");c.visible=true;c.foldable=false}}},foldable:function(b){if(!b||b.nodeType!=1){return false}var a=b.firstChild;while(a){if(a.nodeType==1&&this.is_block(a)){return true}a=a.nextSibling}return false},fold:function(b){if(b){this.remove_class(b,"unfolded");this.add_class(b,"folded")}var a=b?b.firstChild:null;while(a){if(a.nodeType==1&&this.is_block(a)){w3c_slidy.add_class(a,"hidden")}a=a.nextSibling}b.visible=false},unfold:function(b){if(b){this.add_class(b,"unfolded");this.remove_class(b,"folded")}var a=b?b.firstChild:null;while(a){if(a.nodeType==1&&this.is_block(a)){w3c_slidy.remove_class(a,"hidden")}a=a.nextSibling}b.visible=true},outline_click:function(c){if(!c){c=window.event}var a=false;var b=w3c_slidy.get_target(c);while(b&&b.visible==undefined){b=b.parentNode}if(!b){return true}if(c.which){a=(c.which==3)}else{if(c.button){a=(c.button==2)}}if(!a&&b.visible!=undefined){if(b.foldable){if(b.visible){w3c_slidy.fold(b)}else{w3c_slidy.unfold(b)}}w3c_slidy.stop_propagation(c);c.cancel=true;c.returnValue=false}return false},add_initial_prompt:function(){var a=this.create_element("div");a.setAttribute("class","initial_prompt");var b=this.create_element("p");a.appendChild(b);b.setAttribute("class","help");if(this.keyboardless){b.innerHTML="Tap footer to move to next slide"}else{b.innerHTML="Space or Right Arrow to move to next slide, click help below for more details"}this.add_listener(a,"click",function(c){document.body.removeChild(a);w3c_slidy.stop_propagation(c);if(c.cancel!=undefined){c.cancel=true}if(c.returnValue!=undefined){c.returnValue=false}return false});document.body.appendChild(a);this.initial_prompt=a;setTimeout(function(){document.body.removeChild(a)},5000)},add_toolbar:function(){var a,i;this.toolbar=this.create_element("div");this.toolbar.setAttribute("class","toolbar");if(this.ns_pos||!this.ie6){var k=this.create_element("div");k.setAttribute("style","float: right; text-align: right");a=this.create_element("span");a.innerHTML=this.localize("slide")+" n/m";k.appendChild(a);this.toolbar.appendChild(k);var e=this.create_element("div");e.setAttribute("style","text-align: left");this.eos=this.create_element("span");this.eos.innerHTML="* ";e.appendChild(this.eos);var g=this.create_element("a");g.setAttribute("href",this.help_page);g.setAttribute("title",this.localize(this.help_text));g.innerHTML=this.localize("help?");e.appendChild(g);this.help_anchor=g;var d=document.createTextNode(" ");e.appendChild(d);var f=this.create_element("a");f.setAttribute("href","javascript:w3c_slidy.toggle_table_of_contents()");f.setAttribute("title",this.localize("table of contents"));f.innerHTML=this.localize("contents?");e.appendChild(f);var b=document.createTextNode(" ");e.appendChild(b);var h=this.find_copyright();if(h){var j=this.create_element("span");j.className="copyright";j.innerHTML=h;e.appendChild(j)}this.toolbar.setAttribute("tabindex","0");this.toolbar.appendChild(e)}else{this.toolbar.style.position=(this.ie7?"fixed":"absolute");this.toolbar.style.zIndex="200";this.toolbar.style.width="99.9%";this.toolbar.style.height="1.2em";this.toolbar.style.top="auto";this.toolbar.style.bottom="0";this.toolbar.style.left="0";this.toolbar.style.right="0";this.toolbar.style.textAlign="left";this.toolbar.style.fontSize="60%";this.toolbar.style.color="red";this.toolbar.borderWidth=0;this.toolbar.className="toolbar";this.toolbar.style.background="rgb(240,240,240)";var c=this.create_element("span");c.innerHTML="&nbsp;&nbsp;*&nbsp;";this.toolbar.appendChild(c);this.eos=c;var g=this.create_element("a");g.setAttribute("href",this.help_page);g.setAttribute("title",this.localize(this.help_text));g.innerHTML=this.localize("help?");this.toolbar.appendChild(g);this.help_anchor=g;var d=document.createTextNode(" ");this.toolbar.appendChild(d);var f=this.create_element("a");f.setAttribute("href","javascript:toggleTableOfContents()");f.setAttribute("title",this.localize("table of contents".localize));f.innerHTML=this.localize("contents?");this.toolbar.appendChild(f);var b=document.createTextNode(" ");this.toolbar.appendChild(b);var h=this.find_copyright();if(h){var j=this.create_element("span");j.innerHTML=h;j.style.color="black";j.style.marginLeft="0.5em";this.toolbar.appendChild(j)}a=this.create_element("div");a.style.position="absolute";a.style.width="auto";a.style.height="1.2em";a.style.top="auto";a.style.bottom=0;a.style.right="0";a.style.textAlign="right";a.style.color="red";a.style.background="rgb(240,240,240)";a.innerHTML=this.localize("slide")+" n/m";this.toolbar.appendChild(a)}this.toolbar.onclick=function(m){if(!m){m=window.event}var l=m.target;if(!l&&m.srcElement){l=m.srcElement}if(l&&l.nodeType==3){l=l.parentNode}w3c_slidy.stop_propagation(m);if(l&&l.nodeName.toLowerCase()!="a"){w3c_slidy.mouse_button_click(m)}};this.slide_number_element=a;this.set_eos_status(false);document.body.appendChild(this.toolbar)},wrap_implicit_slides:function(){var a,d,c,b,f;var e=document.getElementsByTagName("h1");if(!e){return}for(a=0;a<e.length;++a){d=e[a];if(d.parentNode!=document.body){continue}c=d.nextSibling;f=document.createElement("div");this.add_class(f,"slide");document.body.replaceChild(f,d);f.appendChild(d);while(c){if(c.nodeType==1&&(c.nodeName=="H1"||c.nodeName=="h1"||c.nodeName=="DIV"||c.nodeName=="div")){break}b=c.nextSibling;c=document.body.removeChild(c);f.appendChild(c);c=b}}},collect_slides:function(){var e=new Array();var d=document.body.getElementsByTagName("div");for(var c=0;c<d.length;++c){div=d.item(c);if(this.has_class(div,"slide")){e[e.length]=div;this.add_class(div,"hidden");var b=document.createElement("br");div.appendChild(b);var a=document.createElement("br");div.appendChild(a)}else{if(this.has_class(div,"background")){div.style.display="block"}}}this.slides=e},collect_notes:function(){var b=new Array();var c=document.body.getElementsByTagName("div");for(var a=0;a<c.length;++a){div=c.item(a);if(this.has_class(div,"handout")){b[b.length]=div;this.add_class(div,"hidden")}}this.notes=b},collect_backgrounds:function(){var c=new Array();var b=document.body.getElementsByTagName("div");for(var a=0;a<b.length;++a){div=b.item(a);if(this.has_class(div,"background")){c[c.length]=div;this.add_class(div,"hidden")}}this.backgrounds=c},patch_anchors:function(){var a=w3c_slidy;var c=function(g){if(a.page_address(this.href)==a.page_address(location.href)){var f=a.find_slide_number(this.href);if(f!=a.slide_number){var e=a.slides[a.slide_number];a.hide_slide(e);a.slide_number=f;e=a.slides[a.slide_number];a.show_slide(e);a.set_location()}}else{w3c_slidy.stop_propagation(g)}this.blur();a.disable_slide_click=true};var d=document.body.getElementsByTagName("a");for(var b=0;b<d.length;++b){if(window.addEventListener){d[b].addEventListener("click",c,false)}else{d[b].attachEvent("onclick",c)}}},show_slide_number:function(){var a=w3c_slidy.get_timer();w3c_slidy.slide_number_element.innerHTML=a+w3c_slidy.localize("slide")+" "+(w3c_slidy.slide_number+1)+"/"+w3c_slidy.slides.length},check_location:function(){var b=location.hash;if(w3c_slidy.slide_number>0&&(b==""||b=="#")){w3c_slidy.goto_slide(0)}else{if(b.length>2&&b!="#("+(w3c_slidy.slide_number+1)+")"){var a=parseInt(location.hash.substr(2));if(!isNaN(a)){w3c_slidy.goto_slide(a-1)}}}if(w3c_slidy.time_left&&w3c_slidy.slide_number>0){w3c_slidy.show_slide_number();if(w3c_slidy.time_left>0){w3c_slidy.time_left-=200}}},get_timer:function(){var c="";if(w3c_slidy.time_left){var b,a;a=Math.floor(w3c_slidy.time_left/1000);b=Math.floor(a/60);a=a%60;c=(b?b+"m":"")+a+"s "}return c},set_location:function(){var a=w3c_slidy.page_address(location.href);var b="#("+(w3c_slidy.slide_number+1)+")";if(w3c_slidy.slide_number>=0){a=a+b}if(w3c_slidy.ie&&(w3c_slidy.ie6||w3c_slidy.ie7)){w3c_slidy.push_hash(b)}if(a!=location.href){location.href=a}if(this.khtml){b="("+(w3c_slidy.slide_number+1)+")"}if(!this.ie&&location.hash!=b&&location.hash!=""){location.hash=b}document.title=w3c_slidy.title+" ("+(w3c_slidy.slide_number+1)+")";w3c_slidy.show_slide_number()},page_address:function(b){var a=b.indexOf("#");if(a<0){a=b.indexOf("%23")}if(a<0){return b}return b.substr(0,a)},on_frame_loaded:function(b){location.hash=b;var a=w3c_slidy.page_address(location.href);location.href=a+b},push_hash:function(b){if(b==""){b="#(1)"}window.location.hash=b;var a=document.getElementById("historyFrame").contentWindow.document;a.open("javascript:'<html></html>'");a.write('<html><head><script type="text/javascript">window.parent.w3c_slidy.on_frame_loaded(\''+(b)+"');\74/script></head><body>hello mum</body></html>");a.close()},find_slide_number:function(e){var c=e.indexOf("#");if(c<0){return 0}var b=unescape(e.substr(c+1));var f=document.getElementById(b);if(!f){var d=/\((\d)+\)/;if(b.match(d)){var a=parseInt(b.substring(1,b.length-1));if(a>this.slides.length){a=1}if(--a<0){a=0}return a}d=/\[(\d)+\]/;if(b.match(d)){var a=parseInt(b.substring(1,b.length-1));if(a>this.slides.length){a=1}if(--a<0){a=0}return a}return 0}while(true){if(f.nodeName.toLowerCase()=="div"&&this.has_class(f,"slide")){break}f=f.parentNode;if(!f){return 0}}for(c=0;c<slides.length;++c){if(slides[c]==f){return c}}return 0},previous_slide:function(b){if(!w3c_slidy.view_all){var a;if((b||w3c_slidy.slide_number==0)&&w3c_slidy.last_shown!=null){w3c_slidy.last_shown=w3c_slidy.hide_previous_item(w3c_slidy.last_shown);w3c_slidy.set_eos_status(false)}else{if(w3c_slidy.slide_number>0){a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=w3c_slidy.slide_number-1;a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.set_visibility_all_incremental("visible");w3c_slidy.last_shown=w3c_slidy.previous_incremental_item(null);w3c_slidy.set_eos_status(true);w3c_slidy.show_slide(a)}}w3c_slidy.set_location();if(!w3c_slidy.ns_pos){w3c_slidy.refresh_toolbar(200)}}},next_slide:function(c){if(!w3c_slidy.view_all){var a,b=w3c_slidy.last_shown;if(c||w3c_slidy.slide_number==w3c_slidy.slides.length-1){w3c_slidy.last_shown=w3c_slidy.reveal_next_item(w3c_slidy.last_shown)}if((!c||w3c_slidy.last_shown==null)&&w3c_slidy.slide_number<w3c_slidy.slides.length-1){a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=w3c_slidy.slide_number+1;a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.last_shown=null;w3c_slidy.set_visibility_all_incremental("hidden");w3c_slidy.show_slide(a)}else{if(!w3c_slidy.last_shown){if(b&&c){w3c_slidy.last_shown=b}}}w3c_slidy.set_location();w3c_slidy.set_eos_status(!w3c_slidy.next_incremental_item(w3c_slidy.last_shown));if(!w3c_slidy.ns_pos){w3c_slidy.refresh_toolbar(200)}}},first_slide:function(){if(!w3c_slidy.view_all){var a;if(w3c_slidy.slide_number!=0){a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=0;a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.last_shown=null;w3c_slidy.set_visibility_all_incremental("hidden");w3c_slidy.show_slide(a)}w3c_slidy.set_eos_status(!w3c_slidy.next_incremental_item(w3c_slidy.last_shown));w3c_slidy.set_location()}},last_slide:function(){if(!w3c_slidy.view_all){var a;w3c_slidy.last_shown=null;if(w3c_slidy.last_shown==null&&w3c_slidy.slide_number<w3c_slidy.slides.length-1){a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=w3c_slidy.slides.length-1;a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.set_visibility_all_incremental("visible");w3c_slidy.last_shown=w3c_slidy.previous_incremental_item(null);w3c_slidy.show_slide(a)}else{w3c_slidy.set_visibility_all_incremental("visible");w3c_slidy.last_shown=w3c_slidy.previous_incremental_item(null)}w3c_slidy.set_eos_status(true);w3c_slidy.set_location()}},set_eos_status:function(a){if(this.eos){this.eos.style.color=(a?"rgb(240,240,240)":"red")}},goto_slide:function(b){var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=b;a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.last_shown=null;w3c_slidy.set_visibility_all_incremental("hidden");w3c_slidy.set_eos_status(!w3c_slidy.next_incremental_item(w3c_slidy.last_shown));document.title=w3c_slidy.title+" ("+(w3c_slidy.slide_number+1)+")";w3c_slidy.show_slide(a);w3c_slidy.show_slide_number()},show_slide:function(a){this.sync_background(a);window.scrollTo(0,0);this.remove_class(a,"hidden")},hide_slide:function(a){this.add_class(a,"hidden")},sync_background:function(a){var e;var g;if(a.currentStyle){g=a.currentStyle.backgroundColor}else{if(document.defaultView){var f=document.defaultView.getComputedStyle(a,null);if(f){g=f.getPropertyValue("background-color")}else{g="transparent"}}else{g=="transparent"}}if(g=="transparent"||g.indexOf("rgba")>=0||g.indexOf("opacity")>=0){var c=this.get_class_list(a);for(var d=0;d<this.backgrounds.length;d++){e=this.backgrounds[d];var b=this.get_class_list(e);if(this.matching_background(c,b)){this.remove_class(e,"hidden")}else{this.add_class(e,"hidden")}}}else{this.hide_backgrounds()}},hide_backgrounds:function(){for(var a=0;a<this.backgrounds.length;a++){background=this.backgrounds[a];this.add_class(background,"hidden")}},matching_background:function(c,b){var d,e,f,a;f=/\w+/g;a=b.match(f);for(d=e=0;d<a.length;d++){if(a[d]=="hidden"){continue}if(a[d]=="background"){continue}++e}if(e==0){return true}a=c.match(f);for(d=e=0;d<a.length;d++){if(a[d]=="hidden"){continue}if(this.has_token(b,a[d])){return true}}return false},resized:function(){var c=0;if(typeof(window.innerWidth)=="number"){c=window.innerWidth}else{if(document.documentElement&&document.documentElement.clientWidth){c=document.documentElement.clientWidth}else{if(document.body&&document.body.clientWidth){c=document.body.clientWidth}}}var b=0;if(typeof(window.innerHeight)=="number"){b=window.innerHeight}else{if(document.documentElement&&document.documentElement.clientHeight){b=document.documentElement.clientHeight}else{if(document.body&&document.body.clientHeight){b=document.body.clientHeight}}}if(b&&(c/b>1.05*1024/768)){c=b*1024/768}if(c!=w3c_slidy.last_width||b!=w3c_slidy.last_height){if(c>=1100){w3c_slidy.size_index=5}else{if(c>=1000){w3c_slidy.size_index=4}else{if(c>=800){w3c_slidy.size_index=3}else{if(c>=600){w3c_slidy.size_index=2}else{if(c){w3c_slidy.size_index=0}}}}}if(0<=w3c_slidy.size_index+w3c_slidy.size_adjustment&&w3c_slidy.size_index+w3c_slidy.size_adjustment<w3c_slidy.sizes.length){w3c_slidy.size_index=w3c_slidy.size_index+w3c_slidy.size_adjustment}w3c_slidy.adjust_object_dimensions(c,b);if(document.body.style.fontSize!=w3c_slidy.sizes[w3c_slidy.size_index]){document.body.style.fontSize=w3c_slidy.sizes[w3c_slidy.size_index]}w3c_slidy.last_width=c;w3c_slidy.last_height=b;if(w3c_slidy.ns_pos){var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.show_slide(a)}w3c_slidy.refresh_toolbar(200)}},scrolled:function(){if(w3c_slidy.toolbar&&!w3c_slidy.ns_pos&&!w3c_slidy.ie7){w3c_slidy.hack_offset=w3c_slidy.scroll_x_offset();w3c_slidy.toolbar.style.display="none";if(w3c_slidy.scrollhack==0&&!w3c_slidy.view_all){setTimeout(function(){w3c_slidy.show_toolbar()},1000);w3c_slidy.scrollhack=1}}},hide_toolbar:function(){w3c_slidy.add_class(w3c_slidy.toolbar,"hidden");window.focus()},refresh_toolbar:function(a){if(!w3c_slidy.ns_pos&&!w3c_slidy.ie7){w3c_slidy.hide_toolbar();setTimeout(function(){w3c_slidy.show_toolbar()},a)}},show_toolbar:function(){if(w3c_slidy.want_toolbar){w3c_slidy.toolbar.style.display="block";if(!w3c_slidy.ns_pos){var b=w3c_slidy.scroll_x_offset();w3c_slidy.toolbar.style.left=b;w3c_slidy.toolbar.style.right=b;w3c_slidy.toolbar.style.bottom=0}w3c_slidy.remove_class(w3c_slidy.toolbar,"hidden")}w3c_slidy.scrollhack=0;try{if(!w3c_slidy.opera){w3c_slidy.help_anchor.focus()}}catch(a){}},toggle_toolbar:function(){if(!w3c_slidy.view_all){if(w3c_slidy.has_class(w3c_slidy.toolbar,"hidden")){w3c_slidy.remove_class(w3c_slidy.toolbar,"hidden");w3c_slidy.want_toolbar=1}else{w3c_slidy.add_class(w3c_slidy.toolbar,"hidden");w3c_slidy.want_toolbar=0}}},scroll_x_offset:function(){if(window.pageXOffset){return self.pageXOffset}if(document.documentElement&&document.documentElement.scrollLeft){return document.documentElement.scrollLeft}if(document.body){return document.body.scrollLeft}return 0},scroll_y_offset:function(){if(window.pageYOffset){return self.pageYOffset}if(document.documentElement&&document.documentElement.scrollTop){return document.documentElement.scrollTop}if(document.body){return document.body.scrollTop}return 0},optimize_font_size:function(){var a=w3c_slidy.slides[w3c_slidy.slide_number];var d=a.scrollHeight;var b=getWindowHeight();var c=100*d/b;alert("window utilization = "+c+"% (doc "+d+" win "+b+")")},get_doc_height:function(a){if(!a){a=document}if(a&&a.body&&a.body.offsetHeight){return a.body.offsetHeight}if(a&&a.body&&a.body.scrollHeight){return a.body.scrollHeight}alert("couldn't determine document height")},get_window_height:function(){if(typeof(window.innerHeight)=="number"){return window.innerHeight}if(document.documentElement&&document.documentElement.clientHeight){return document.documentElement.clientHeight}if(document.body&&document.body.clientHeight){return document.body.clientHeight}},document_height:function(){var a,b;a=document.body.scrollHeight;b=document.body.offsetHeight;if(a&&b){return(a>b?a:b)}return 0},smaller:function(){if(w3c_slidy.size_index>0){--w3c_slidy.size_index}w3c_slidy.toolbar.style.display="none";document.body.style.fontSize=w3c_slidy.sizes[w3c_slidy.size_index];var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.show_slide(a);setTimeout(function(){w3c_slidy.show_toolbar()},50)},bigger:function(){if(w3c_slidy.size_index<w3c_slidy.sizes.length-1){++w3c_slidy.size_index}w3c_slidy.toolbar.style.display="none";document.body.style.fontSize=w3c_slidy.sizes[w3c_slidy.size_index];var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.show_slide(a);setTimeout(function(){w3c_slidy.show_toolbar()},50)},adjust_object_dimensions:function(c,k){for(var e=0;e<w3c_slidy.objects.length;e++){var d=this.objects[e];var b=d.getAttribute("type");if(b=="image/svg+xml"||b=="application/x-shockwave-flash"){if(!d.initialWidth){d.initialWidth=d.getAttribute("width")}if(!d.initialHeight){d.initialHeight=d.getAttribute("height")}if(d.initialWidth&&d.initialWidth.charAt(d.initialWidth.length-1)=="%"){var j=parseInt(d.initialWidth.slice(0,d.initialWidth.length-1));var a=c*(j/100);d.setAttribute("width",a)}if(d.initialHeight&&d.initialHeight.charAt(d.initialHeight.length-1)=="%"){var f=parseInt(d.initialHeight.slice(0,d.initialHeight.length-1));var g=k*(f/100);d.setAttribute("height",g)}}}},key_press:function(a){if(!a){a=window.event}if(!w3c_slidy.key_wanted){return w3c_slidy.cancel(a)}return true},key_down:function(d){var c,e,a;w3c_slidy.key_wanted=true;if(!d){d=window.event}if(window.event){c=window.event.keyCode;e=window.event.srcElement}else{if(d.which){c=d.which;e=d.target}else{return true}}if(!c){return true}if(!w3c_slidy.slidy_chrome(e)&&w3c_slidy.special_element(e)){return true}if(d.ctrlKey||d.altKey||d.metaKey){return true}if(w3c_slidy.is_shown_toc()&&c!=9&&c!=16&&c!=38&&c!=40){w3c_slidy.hide_table_of_contents(true);if(c==27||c==84||c==67){return w3c_slidy.cancel(d)}}if(c==34){if(w3c_slidy.view_all){return true}w3c_slidy.next_slide(false);return w3c_slidy.cancel(d)}else{if(c==33){if(w3c_slidy.view_all){return true}w3c_slidy.previous_slide(false);return w3c_slidy.cancel(d)}else{if(c==32){w3c_slidy.next_slide(true);return w3c_slidy.cancel(d)}else{if(c==37){w3c_slidy.previous_slide(!d.shiftKey);return w3c_slidy.cancel(d)}else{if(c==36){w3c_slidy.first_slide();return w3c_slidy.cancel(d)}else{if(c==35){w3c_slidy.last_slide();return w3c_slidy.cancel(d)}else{if(c==39){w3c_slidy.next_slide(!d.shiftKey);return w3c_slidy.cancel(d)}else{if(c==13){if(w3c_slidy.outline){if(w3c_slidy.outline.visible){w3c_slidy.fold(w3c_slidy.outline)}else{w3c_slidy.unfold(w3c_slidy.outline)}return w3c_slidy.cancel(d)}}else{if(c==188){w3c_slidy.smaller();return w3c_slidy.cancel(d)}else{if(c==190){w3c_slidy.bigger();return w3c_slidy.cancel(d)}else{if(c==189||c==109){w3c_slidy.smaller();return w3c_slidy.cancel(d)}else{if(c==187||c==191||c==107){w3c_slidy.bigger();return w3c_slidy.cancel(d)}else{if(c==83){w3c_slidy.smaller();return w3c_slidy.cancel(d)}else{if(c==66){w3c_slidy.bigger();return w3c_slidy.cancel(d)}else{if(c==90){w3c_slidy.last_slide();return w3c_slidy.cancel(d)}else{if(c==70){w3c_slidy.toggle_toolbar();return w3c_slidy.cancel(d)}else{if(c==65){w3c_slidy.toggle_view();return w3c_slidy.cancel(d)}else{if(c==75){w3c_slidy.mouse_click_enabled=!w3c_slidy.mouse_click_enabled;var b=(w3c_slidy.mouse_click_enabled?"enabled":"disabled")+" mouse click advance";alert(w3c_slidy.localize(b));return w3c_slidy.cancel(d)}else{if(c==84||c==67){if(w3c_slidy.toc){w3c_slidy.toggle_table_of_contents()}return w3c_slidy.cancel(d)}else{if(c==72){window.location=w3c_slidy.help_page;return w3c_slidy.cancel(d)}}}}}}}}}}}}}}}}}}}}return true},create_element:function(a){if(this.xhtml&&(typeof document.createElementNS!="undefined")){return document.createElementNS("http://www.w3.org/1999/xhtml",a)}return document.createElement(a)},get_element_style:function(d,b,c){if(d.currentStyle){return d.currentStyle[b]}else{if(window.getComputedStyle){var a=window.getComputedStyle(d,"");return a.getPropertyValue(c)}}return""},has_token:function(e,c){if(e){var d=/\w+/g;var a=e.match(d);for(var b=0;b<a.length;b++){if(a[b]==c){return true}}}return false},get_class_list:function(a){if(typeof a.className!="undefined"){return a.className}return a.getAttribute("class")},has_class:function(b,a){if(b.nodeType!=1){return false}var c=new RegExp("(^| )"+a+"W*");if(typeof b.className!="undefined"){return c.test(b.className)}return c.test(b.getAttribute("class"))},remove_class:function(b,a){var d=new RegExp("(^| )"+a+"W*");var c="";if(typeof b.className!="undefined"){c=b.className;if(c){c=c.replace(d,"");b.className=c}}else{c=b.getAttribute("class");if(c){c=c.replace(d,"");b.setAttribute("class",c)}}},add_class:function(b,a){if(!this.has_class(b,a)){if(typeof b.className!="undefined"){b.className+=" "+a}else{var c=b.getAttribute("class");c=c?c+" "+a:a;b.setAttribute("class",c)}}},incremental_elements:null,okay_for_incremental:function(a){if(!this.incremental_elements){var b=new Array();b.p=true;b.pre=true;b.li=true;b.blockquote=true;b.dt=true;b.dd=true;b.h2=true;b.h3=true;b.h4=true;b.h5=true;b.h6=true;b.span=true;b.address=true;b.table=true;b.tr=true;b.th=true;b.td=true;b.img=true;b.object=true;this.incremental_elements=b}return this.incremental_elements[a.toLowerCase()]},next_incremental_item:function(c){var b=this.is_xhtml?"br":"BR";var a=w3c_slidy.slides[w3c_slidy.slide_number];for(;;){c=w3c_slidy.next_node(a,c);if(c==null||c.parentNode==null){break}if(c.nodeType==1){if(c.nodeName==b){continue}if(w3c_slidy.has_class(c,"incremental")&&w3c_slidy.okay_for_incremental(c.nodeName)){return c}if(w3c_slidy.has_class(c.parentNode,"incremental")&&!w3c_slidy.has_class(c,"non-incremental")){return c}}}return c},previous_incremental_item:function(c){var b=this.is_xhtml?"br":"BR";var a=w3c_slidy.slides[w3c_slidy.slide_number];for(;;){c=w3c_slidy.previous_node(a,c);if(c==null||c.parentNode==null){break}if(c.nodeType==1){if(c.nodeName==b){continue}if(w3c_slidy.has_class(c,"incremental")&&w3c_slidy.okay_for_incremental(c.nodeName)){return c}if(w3c_slidy.has_class(c.parentNode,"incremental")&&!w3c_slidy.has_class(c,"non-incremental")){return c}}}return c},set_visibility_all_incremental:function(b){var a=this.next_incremental_item(null);if(b=="hidden"){while(a){w3c_slidy.add_class(a,"invisible");a=w3c_slidy.next_incremental_item(a)}}else{while(a){w3c_slidy.remove_class(a,"invisible");a=w3c_slidy.next_incremental_item(a)}}},reveal_next_item:function(a){a=w3c_slidy.next_incremental_item(a);if(a&&a.nodeType==1){w3c_slidy.remove_class(a,"invisible")}return a},hide_previous_item:function(a){if(a&&a.nodeType==1){w3c_slidy.add_class(a,"invisible")}return this.previous_incremental_item(a)},next_node:function(a,b){if(b==null){return a.firstChild}if(b.firstChild){return b.firstChild}if(b.nextSibling){return b.nextSibling}for(;;){b=b.parentNode;if(!b||b==a){break}if(b&&b.nextSibling){return b.nextSibling}}return null},previous_node:function(a,b){if(b==null){b=a.lastChild;if(b){while(b.lastChild){b=b.lastChild}}return b}if(b.previousSibling){b=b.previousSibling;while(b.lastChild){b=b.lastChild}return b}if(b.parentNode!=a){return b.parentNode}return null},previous_sibling_element:function(a){a=a.previousSibling;while(a&&a.nodeType!=1){a=a.previousSibling}return a},next_sibling_element:function(a){a=a.nextSibling;while(a&&a.nodeType!=1){a=a.nextSibling}return a},first_child_element:function(a){var b;for(b=a.firstChild;b;b=b.nextSibling){if(b.nodeType==1){break}}return b},first_tag:function(b,a){var c;if(!this.is_xhtml){a=a.toUpperCase()}for(c=b.firstChild;c;c=c.nextSibling){if(c.nodeType==1&&c.nodeName==a){break}}return c},hide_selection:function(){if(window.getSelection){var b=window.getSelection();if(b.rangeCount>0){var a=b.getRangeAt(0);a.collapse(false)}}else{var c=document.selection.createRange();c.collapse(false)}},get_selected_text:function(){try{if(window.getSelection){return window.getSelection().toString()}if(document.getSelection){return document.getSelection().toString()}if(document.selection){return document.selection.createRange().text}}catch(a){}return""},mouse_button_up:function(a){w3c_slidy.selected_text_len=w3c_slidy.get_selected_text().length},mouse_button_click:function(g){var c=false;var b=false;var d=false;var f;if(!g){var g=window.event}if(g.target){f=g.target}else{if(g.srcElement){f=g.srcElement}}if(f.nodeType==3){f=f.parentNode}if(g.which){b=(g.which==1);d=(g.which==2);c=(g.which==3)}else{if(g.button){if(g.button==4){d=true}c=(g.button==2)}else{b=true}}if(w3c_slidy.selected_text_len>0){w3c_slidy.stop_propagation(g);g.cancel=true;g.returnValue=false;return false}w3c_slidy.hide_table_of_contents(false);var a=f.nodeName.toLowerCase();if(w3c_slidy.mouse_click_enabled&&b&&!w3c_slidy.special_element(f)&&!f.onclick){w3c_slidy.next_slide(true);w3c_slidy.stop_propagation(g);g.cancel=true;g.returnValue=false;return false}return true},special_element:function(b){var a=b.nodeName.toLowerCase();return b.onkeydown||b.onclick||a=="a"||a=="embed"||a=="object"||a=="video"||a=="audio"||a=="input"||a=="textarea"||a=="select"||a=="option"},slidy_chrome:function(a){while(a){if(a==w3c_slidy.toc||a==w3c_slidy.toolbar||w3c_slidy.has_class(a,"outline")){return true}a=a.parentNode}return false},get_key:function(b){var a;if(typeof window.event!="undefined"){a=window.event.keyCode}else{if(b.which){a=b.which}}return a},get_target:function(b){var a;if(!b){b=window.event}if(b.target){a=b.target}else{if(b.srcElement){a=b.srcElement}}if(a.nodeType!=1){a=a.parentNode}return a},is_block:function(b){var a=b.nodeName.toLowerCase();return a=="ol"||a=="ul"||a=="p"||a=="li"||a=="table"||a=="pre"||a=="h1"||a=="h2"||a=="h3"||a=="h4"||a=="h5"||a=="h6"||a=="blockquote"||a=="address"},add_listener:function(a,c,b){if(window.addEventListener){a.addEventListener(c,b,false)}else{a.attachEvent("on"+c,b)}},stop_propagation:function(a){a=a?a:window.event;a.cancelBubble=true;if(a.stopPropagation){a.stopPropagation()}return true},cancel:function(a){if(a){a.cancel=true;a.returnValue=false;if(a.preventDefault){a.preventDefault()}}w3c_slidy.key_wanted=false;return false},strings_es:{slide:"pág.","help?":"Ayuda","contents?":"Índice","table of contents":"tabla de contenidos","Table of Contents":"Tabla de Contenidos","restart presentation":"Reiniciar presentación","restart?":"Inicio"},help_es:"Utilice el ratón, barra espaciadora, teclas Izda/Dcha, o Re pág y Av pág. Use S y B para cambiar el tamaño de fuente.",strings_ca:{slide:"pàg..","help?":"Ajuda","contents?":"Índex","table of contents":"taula de continguts","Table of Contents":"Taula de Continguts","restart presentation":"Reiniciar presentació","restart?":"Inici"},help_ca:"Utilitzi el ratolí, barra espaiadora, tecles Esq./Dta. o Re pàg y Av pàg. Usi S i B per canviar grandària de font.",strings_cs:{slide:"snímek","help?":"nápověda","contents?":"obsah","table of contents":"obsah prezentace","Table of Contents":"Obsah prezentace","restart presentation":"znovu spustit prezentaci","restart?":"restart"},help_cs:"Prezentaci můžete procházet pomocí kliknutí myši, mezerníku, šipek vlevo a vpravo nebo kláves PageUp a PageDown. Písmo se dá zvětšit a zmenšit pomocí kláves B a S.",strings_nl:{slide:"pagina","help?":"Help?","contents?":"Inhoud?","table of contents":"inhoudsopgave","Table of Contents":"Inhoudsopgave","restart presentation":"herstart presentatie","restart?":"Herstart?"},help_nl:"Navigeer d.m.v. het muis, spatiebar, Links/Rechts toetsen, of PgUp en PgDn. Gebruik S en B om de karaktergrootte te veranderen.",strings_de:{slide:"Seite","help?":"Hilfe","contents?":"Übersicht","table of contents":"Inhaltsverzeichnis","Table of Contents":"Inhaltsverzeichnis","restart presentation":"Präsentation neu starten","restart?":"Neustart"},help_de:"Benutzen Sie die Maus, Leerschlag, die Cursortasten links/rechts oder Page up/Page Down zum Wechseln der Seiten und S und B für die Schriftgrösse.",strings_pl:{slide:"slajd","help?":"pomoc?","contents?":"spis treści?","table of contents":"spis treści","Table of Contents":"Spis Treści","restart presentation":"Restartuj prezentację","restart?":"restart?"},help_pl:"Zmieniaj slajdy klikając myszą, naciskając spację, strzałki lewo/prawolub PgUp / PgDn. Użyj klawiszy S i B, aby zmienić rozmiar czczionki.",strings_fr:{slide:"page","help?":"Aide","contents?":"Index","table of contents":"table des matières","Table of Contents":"Table des matières","restart presentation":"Recommencer l'exposé","restart?":"Début"},help_fr:"Naviguez avec la souris, la barre d'espace, les flèches gauche/droite ou les touches Pg Up, Pg Dn. Utilisez les touches S et B pour modifier la taille de la police.",strings_hu:{slide:"oldal","help?":"segítség","contents?":"tartalom","table of contents":"tartalomjegyzék","Table of Contents":"Tartalomjegyzék","restart presentation":"bemutató újraindítása","restart?":"újraindítás"},help_hu:"Az oldalak közti lépkedéshez kattintson az egérrel, vagy használja a szóköz, a bal, vagy a jobb nyíl, illetve a Page Down, Page Up billentyűket. Az S és a B billentyűkkel változtathatja a szöveg méretét.",strings_it:{slide:"pag.","help?":"Aiuto","contents?":"Indice","table of contents":"indice","Table of Contents":"Indice","restart presentation":"Ricominciare la presentazione","restart?":"Inizio"},help_it:"Navigare con mouse, barra spazio, frecce sinistra/destra o PgUp e PgDn. Usare S e B per cambiare la dimensione dei caratteri.",strings_el:{slide:"σελίδα","help?":"βοήθεια;","contents?":"περιεχόμενα;","table of contents":"πίνακας περιεχομένων","Table of Contents":"Πίνακας Περιεχομένων","restart presentation":"επανεκκίνηση παρουσίασης","restart?":"επανεκκίνηση;"},help_el:"Πλοηγηθείτε με το κλίκ του ποντικιού, το space, τα βέλη αριστερά/δεξιά, ή Page Up και Page Down. Χρησιμοποιήστε τα πλήκτρα S και B για να αλλάξετε το μέγεθος της γραμματοσειράς.",strings_ja:{slide:"スライド","help?":"ヘルプ","contents?":"目次","table of contents":"目次を表示","Table of Contents":"目次","restart presentation":"最初から再生","restart?":"最初から"},help_ja:"マウス左クリック ・ スペース ・ 左右キー または Page Up ・ Page Downで操作， S ・ Bでフォントサイズ変更",strings_zh:{slide:"幻灯片","help?":"帮助?","contents?":"内容?","table of contents":"目录","Table of Contents":"目录","restart presentation":"重新启动展示","restart?":"重新启动?"},help_zh:"用鼠标点击, 空格条, 左右箭头, Pg Up 和 Pg Dn 导航. 用 S, B 改变字体大小.",strings_ru:{slide:"слайд","help?":"помощь?","contents?":"содержание?","table of contents":"оглавление","Table of Contents":"Оглавление","restart presentation":"перезапустить презентацию","restart?":"перезапуск?"},help_ru:"Перемещайтесь кликая мышкой, используя клавишу пробел, стрелкивлево/вправо или Pg Up и Pg Dn. Клавиши S и B меняют размер шрифта.",strings_sv:{slide:"sida","help?":"hjälp","contents?":"innehåll","table of contents":"innehållsförteckning","Table of Contents":"Innehållsförteckning","restart presentation":"visa presentationen från början","restart?":"börja om"},help_sv:"Bläddra med ett klick med vänstra musknappen, mellanslagstangenten, vänster- och högerpiltangenterna eller tangenterna Pg Up, Pg Dn. Använd tangenterna S och B för att ändra textens storlek.",strings:{},localize:function(d){if(d==""){return d}var b,c=w3c_slidy.strings[w3c_slidy.lang];if(c){b=c[d];if(b){return b}}var a=w3c_slidy.lang.split("-");if(a.length>1){c=w3c_slidy.strings[a[0]];if(c){b=c[d];if(b){return b}}}return d},init_localization:function(){var b=w3c_slidy;var a=w3c_slidy.help_text;this.strings={es:this.strings_es,ca:this.strings_ca,cs:this.strings_cs,nl:this.strings_nl,de:this.strings_de,pl:this.strings_pl,fr:this.strings_fr,hu:this.strings_hu,it:this.strings_it,el:this.strings_el,jp:this.strings_ja,zh:this.strings_zh,ru:this.strings_ru,sv:this.strings_sv},b.strings_es[a]=b.help_es;b.strings_ca[a]=b.help_ca;b.strings_cs[a]=b.help_cs;b.strings_nl[a]=b.help_nl;b.strings_de[a]=b.help_de;b.strings_pl[a]=b.help_pl;b.strings_fr[a]=b.help_fr;b.strings_hu[a]=b.help_hu;b.strings_it[a]=b.help_it;b.strings_el[a]=b.help_el;b.strings_ja[a]=b.help_ja;b.strings_zh[a]=b.help_zh;b.strings_ru[a]=b.help_ru;b.strings_sv[a]=b.help_sv;w3c_slidy.lang=document.body.parentNode.getAttribute("lang");if(!w3c_slidy.lang){w3c_slidy.lang=document.body.parentNode.getAttribute("xml:lang")}if(!w3c_slidy.lang){w3c_slidy.lang="en"}}};if(w3c_slidy.ie6||w3c_slidy.ie7){document.write("<iframe id='historyFrame' src='javascript:\"<html></html>\"' height='1' width='1' style='position:absolute;left:-800px'></iframe>")}w3c_slidy.set_up();setTimeout(w3c_slidy.hide_slides,50);
/*]]>*/
</script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Haskell: Functional Programming, Solid Code, Big Data</h1>
  <p class="author">
Bryan O'Sullivan
  </p>
  <p class="date">2011-09-18</p>
</div>
<div class="slide">
<h1 id="welcome">Welcome!</h1>
<pre class="haskell"><code>main = putStrLn &quot;hello!&quot;
</code></pre>
<ul>
<li><p>My name is Bryan O'Sullivan</p></li>
<li><p>I started using Haskell in 1993</p></li>
<li><p>I wrote a book about it, &quot;Real World Haskell&quot;</p>
<ul>
<li><a href="http://book.realworldhaskell.org/">realworldhaskell.org</a></li>
</ul></li>
<li><p>I write lots of open source code</p>
<ul>
<li><a href="https://github.com/bos">github.com/bos</a></li>
</ul></li>
<li><p>My company invests heavily and openly in Haskell</p>
<ul>
<li><a href="https://github.com/mailrank">github.com/mailrank</a></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="copy-these-slides-if-you-want">Copy these slides (if you want)</h1>
<pre><code>git clone https://github.com/bos/strange-loop-2011
</code></pre>
</div>
<div class="slide">
<h1 id="my-haskell-background">My Haskell background</h1>
<ul>
<li><p>Began using Haskell at university</p></li>
<li><p>When I graduated in 1995, I switched to more mainstream languages</p>
<ul>
<li>C, C++, Java, Python, Perl, etc.</li>
</ul></li>
<li><p>My interest reawakened around 2005</p></li>
<li><p>I've found Haskell to be a great general-purpose language</p></li>
<li><p>The community of people is amazing</p></li>
</ul>
</div>
<div class="slide">
<h1 id="what-to-expect-1">What to expect 1</h1>
<ul>
<li><p>Haskell is a fairly big language</p></li>
<li><p>Since so much is unfamiliar to newcomers, expect to wander far from your comfort zone</p></li>
<li><p>I'm going to teach you <em>interesting</em> things, but not <em>everything</em></p></li>
</ul>
</div>
<div class="slide">
<h1 id="what-to-expect-2">What to expect 2</h1>
<ul>
<li><p>This is a <em>hands-on</em> workshop: you'll be writing code!</p></li>
<li><p>There will be a short break every 45 minutes</p></li>
<li><p>Don't be afraid to ask questions!</p></li>
</ul>
</div>
<div class="slide">
<h1 id="your-tools">Your tools</h1>
<ul>
<li><p>You've already installed the Haskell Platform, right?</p>
<ul>
<li><a href="http://hackage.haskell.org/platform/">hackage.haskell.org/platform</a></li>
</ul></li>
<li><p>This gives us a great toolchain</p>
<ul>
<li><p>The GHC compiler (<code>ghc</code>)</p></li>
<li><p>The GHCi interpreter (<code>ghci</code>)</p></li>
<li><p>The Cabal package manager (<code>cabal</code>)</p></li>
<li><p>Some handy libraries and tools</p></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="what-else-is-needed">What else is needed?</h1>
<ul>
<li><p>A text editor</p></li>
<li><p>A terminal window</p></li>
</ul>
</div>
<div class="slide">
<h1 id="problem-definition">Problem definition</h1>
<p>Given a web site, we want to scrape it and find important web pages.</p>
<p>This involves a lot of figuring stuff out!</p>
<ol style="list-style-type: decimal">
<li><p>Learn Haskell</p></li>
<li><p>Download one web page</p></li>
<li><p>Extract links from a page, so we can find more pages to download</p></li>
<li><p>Once we're done, compute which ones are important</p></li>
<li><p>Make it all fast?</p></li>
</ol>
</div>
<div class="slide">
<h1 id="lets-get-started">Let's get started!</h1>
<p>Create a file named <code>Hello.hs</code> and give it the following contents:</p>
<pre class="haskell"><code>main = putStrLn &quot;hello, world!&quot;
</code></pre>
<p>The suffix <code>.hs</code> is the standard for Haskell source files.</p>
<p>File names start with a capital letter, and everyone uses <code>CamelCase</code>.</p>
</div>
<div class="slide">
<h1 id="building-it">Building it</h1>
<p>This command will look for <code>Hello.hs</code> in the current directory, and compile it:</p>
<pre><code>ghc --make Hello
</code></pre>
<p>The generated executable will be named <code>Hello</code> (<code>Hello.exe</code> on Windows).</p>
<ul>
<li>That <code>--make</code> option up there tells GHC to automatically deal with dependencies on source files and packages.</li>
</ul>
</div>
<div class="slide">
<h1 id="checking-in">Checking in</h1>
<p>Is everyone able to build and run their <code>Hello</code> executable?</p>
</div>
<div class="slide">
<h1 id="something-a-little-more-convenient">Something a little more convenient</h1>
<p>It's nice to have fast, native code at our fingertips.</p>
<p>But when <em>I'm</em> working, I expect a few things:</p>
<ul>
<li><p>I do lots of exploration.</p></li>
<li><p>I make tons of mistakes.</p></li>
</ul>
<p>For these circumstances, a full compiler is a bit slow.</p>
<p>Instead, I often use the interactive interpreter, <code>ghci</code>.</p>
</div>
<div class="slide">
<h1 id="lets-start-ghci">Let's start GHCi</h1>
<p>Easily done:</p>
<pre><code>ghci
</code></pre>
<p>It will display a startup banner, followed by a prompt:</p>
<pre><code>Prelude&gt;
</code></pre>
<p>This default prompt tells us which modules are available to play with.</p>
</div>
<div class="slide">
<h1 id="play-around">Play around</h1>
<p>The <code>ghci</code> interpreter evaluates expressions interactively.</p>
<p>Try it out:</p>
<pre class="haskell"><code>2 + 2
</code></pre>
<pre class="haskell"><code>123456781234567812345678 * 87654321876543
</code></pre>
<pre class="haskell"><code>&quot;foo&quot; ++ &quot;bar&quot;
</code></pre>
<p>(That <code>++</code> is the &quot;append&quot; operator.)</p>
</div>
<div class="slide">
<h1 id="directives">Directives</h1>
<p>All interpreter directives start with a &quot;<code>:</code>&quot; character.</p>
<p>Let's load our source file into <code>ghci</code>:</p>
<pre><code>:load Hello.hs
</code></pre>
<p>Now the <code>ghci</code> prompt changes:</p>
<pre><code>*Main&gt;
</code></pre>
</div>
<div class="slide">
<h1 id="running-our-code-in-ghci">Running our code in ghci</h1>
<p>We defined a function named <code>main</code>, so let's invoke it:</p>
<pre><code>main
</code></pre>
<p>Did that work for you?</p>
<p>What about this?</p>
<pre class="haskell"><code>putStrLn &quot;hi mom!&quot;
</code></pre>
</div>
<div class="slide">
<h1 id="a-few-more-useful-directives">A few more useful directives</h1>
<p>Remember, all <code>ghci</code> directives start with a &quot;<code>:</code>&quot;.</p>
<ul>
<li><p><code>:help</code> tells us what directives are available.</p></li>
<li><p><code>:reload</code> reloads the file we last <code>:load</code>ed.</p></li>
<li><p><code>:edit</code> launches our text editor on the file you most recently <code>:load</code>ed. (Does <em>not</em> automatically <code>:reload</code>.)</p></li>
<li><p><code>:quit</code> exits back to the shell.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="final-ghci-efficiency-tips">Final ghci efficiency tips</h1>
<p>We can abbreviate directives:</p>
<ul>
<li><p><code>:e</code> is treated as <code>:edit</code></p></li>
<li><p><code>:r</code> is <code>:reload</code></p></li>
</ul>
<p>We also have command line history and editing.</p>
<ul>
<li><p>On Unix, compatible with <code>readline</code>.</p></li>
<li><p>On Windows, the same as <code>cmd.exe</code>.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="getting-used-to-the-cycle">Getting used to the cycle</h1>
<p>Use <code>:edit</code> or your text editor to change the &quot;hello&quot; text.</p>
<p>Use <code>:reload</code> to reload the source file.</p>
<p>Test out your redefinition of <code>main</code>.</p>
<ul>
<li>For practice, hit the &quot;up arrow&quot; key to cycle through your command history until you get back to the last time you typed <code>main</code>.</li>
</ul>
</div>
<div class="slide">
<h1 id="lists-and-strings">Lists and strings</h1>
<pre class="haskell"><code>[1,2,3,4]
</code></pre>
<pre class="haskell"><code>['h','e','l','l','o']
</code></pre>
<p>Double quotes are just syntactic sugar for the longer form:</p>
<pre class="haskell"><code>&quot;hello&quot;
</code></pre>
<p>What does this print?</p>
<pre class="haskell"><code>&quot;foo&quot; == ['f','o','o']
</code></pre>
</div>
<div class="slide">
<h1 id="calling-functions-1">Calling functions: 1</h1>
<p>We use white space to separate a function from its argument:</p>
<pre class="haskell"><code>head &quot;foo&quot;
</code></pre>
<pre class="haskell"><code>head [1,2,3]
</code></pre>
<pre class="haskell"><code>tail [1,2,3]
</code></pre>
</div>
<div class="slide">
<h1 id="calling-functions-2">Calling functions: 2</h1>
<p>If a function takes multiple arguments, we separate them with white space:</p>
<pre class="haskell"><code>min 3 4
</code></pre>
<p>If an argument is a compound expression, wrap it in parentheses:</p>
<pre class="haskell"><code>compare (3+5) (2+7)
</code></pre>
<pre class="haskell"><code>max (min 3 4) 5
</code></pre>
</div>
<div class="slide">
<h1 id="quick-exercises-1">Quick exercises: 1</h1>
<p>Use <code>ghci</code> as a calculator.</p>
<p>The <code>**</code> operator performs exponentiation.</p>
<ul>
<li>If I invest 5 quatloos at 3% compound interest per annum, how many quatloos will I have after 10 years?</li>
</ul>
</div>
<div class="slide">
<h1 id="quick-exercises-2">Quick exercises: 2</h1>
<p>The notation <code>['a'..'z']</code> generates a list from start to end, inclusive.</p>
<p>The <code>sum</code> function adds the elements of a list.</p>
<ul>
<li>What is the sum of the numbers between 9 and 250, inclusive, <em>minus</em> 2?</li>
</ul>
</div>
<div class="slide">
<h1 id="quick-exercises-3">Quick exercises: 3</h1>
<p>The <code>show</code> function renders a value as a string. Try it!</p>
<pre class="haskell"><code>show (1 == 2)
</code></pre>
<p>The <code>length</code> function tells us how many elements are in a list.</p>
<pre class="haskell"><code>length [1,2,3]
</code></pre>
<ul>
<li>How many digits are in the product of all numbers between 0xBE and 0xEF, inclusive?</li>
</ul>
</div>
<div class="slide">
<h1 id="defining-a-function">Defining a function</h1>
<p>It is pretty simple to define a new function.</p>
<p>Open up your text editor, create a new file with a <code>.hs</code> extension, and get writing!</p>
<pre class="haskell"><code>isOdd x  =  (rem x 2) == 1
</code></pre>
<ul>
<li><p>We start with the name of the function.</p></li>
<li><p>Next come the names we want to give its parameter(s), separated by white space.</p></li>
<li><p>After those come a single <code>=</code> character, with the <em>body</em> of the function following.</p></li>
</ul>
<p>Load your source file into <code>ghci</code> and give <code>myOdd</code> a try.</p>
</div>
<div class="slide">
<h1 id="making-life-more-interesting">Making life more interesting</h1>
<p>Now we can define very simple functions, but we're missing some important building blocks for more fun.</p>
<p>So let's get to it!</p>
</div>
<div class="slide">
<h1 id="conditional-execution">Conditional execution</h1>
<p>Q: What does the familiar <code>if</code> look like in Haskell?</p>
<p>A: Familiar!</p>
<pre class="haskell"><code>gcd a b = if b == 0
          then a
      else gcd b (rem a b)
</code></pre>
<p>We have the following elements:</p>
<ul>
<li><p>A Boolean expression</p></li>
<li><p><code>then</code> an expression that will be the result if the Boolean is <code>True</code></p></li>
<li><p><code>else</code> an expression that will be the result if the Boolean is <code>False</code></p></li>
</ul>
</div>
<div class="slide">
<h1 id="finally-a-tiny-bit-about-types">Finally! A tiny bit about types</h1>
<p>The two possible results of an <code>if</code> expression must have the same type.</p>
<p>If <code>then</code> evaluates to a <code>String</code>, well <code>else</code> must too!</p>
<p>For instance, this makes no sense:</p>
<pre class="haskell"><code>if True
then 3.14
else &quot;wombat&quot;
</code></pre>
<p>We are forbidden from writing ill-typed expressions like this.</p>
</div>
<div class="slide">
<h1 id="what-about-else">What about else?</h1>
<p>In imperative languages, we can usually leave out the <code>else</code> clause after an <code>if</code>.</p>
<p>Not so in Haskell.</p>
<p>Why does this make sense for imperative languages, but not Haskell?</p>
</div>
<div class="slide">
<h1 id="a-nearly-trivial-exercise">A nearly trivial exercise</h1>
<p>Write a function that appends <code>&quot;, world&quot;</code> to its argument if the argument is <code>&quot;hello&quot;</code>, or just returns its argument unmodified otherwise.</p>
<ul>
<li>Remember, the &quot;append&quot; function is an operator named <code>++</code>.</li>
</ul>
</div>
<div class="slide">
<h1 id="lists-in-haskell">Lists in Haskell</h1>
<p>We already know what a list looks like in Haskell:</p>
<pre class="haskell"><code>[1,2,3]
</code></pre>
<p>And of course there's the syntactic sugar for strings:</p>
<pre class="haskell"><code>&quot;foo&quot; == ['f','o','o']
</code></pre>
<p>But is this everything there is to know?</p>
</div>
<div class="slide">
<h1 id="list-constructors">List constructors</h1>
<p>Supposing we want to construct a list from first principles.</p>
<ul>
<li><p>We write the <em>empty list</em> as <code>[]</code>.</p></li>
<li><p>Given an existing list, we can add another element to the <em>front</em> of the list using the <code>:</code> operator.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="type-this-into-ghci">Type this into ghci</h1>
<p>Add an element to an empty list:</p>
<pre class="haskell"><code>1 : []
</code></pre>
</div>
<div class="slide">
<h1 id="from-single-element-lists-onwards">From single-element lists onwards</h1>
<p>What about extending that list?</p>
<pre class="haskell"><code>2 : (1 : [])
</code></pre>
<p>You're probably guessing now that <code>[2,1]</code> is syntactic sugar for <code>2:(1:[])</code>. And you're right!</p>
<p>What is the result of this expression?</p>
<pre class="haskell"><code>5 : 8 : [] == [5,8]
</code></pre>
</div>
<div class="slide">
<h1 id="constructors">Constructors</h1>
<p>We refer to <code>[]</code> and <code>:</code> as <em>constructors</em>, because we use them to construct lists.</p>
<p>When you create a list, the Haskell runtime has to remember which constructors you used, and where.</p>
<p>So the value <code>[5,8]</code> is represented as:</p>
<ul>
<li><p>A <code>:</code> constructor, with <code>5</code> as its first parameter, and as its second ...</p></li>
<li><p>Another <code>:</code> constructor, this time with <code>8</code> as its first parameter, and now as its second ...</p></li>
<li><p>A <code>[]</code> constructor</p></li>
</ul>
</div>
<div class="slide">
<h1 id="what-did-we-see">What did we see?</h1>
<p>Depending on your background, I bet you're thinking something like this:</p>
<ul>
<li><p>&quot;Hey! Haskell lists look like singly linked lists!&quot;</p></li>
<li><p>&quot;Hey! That looks just like lists built out of <code>cons</code> cells in Lisp!&quot;</p></li>
</ul>
<p>Right on.</p>
</div>
<div class="slide">
<h1 id="why-do-we-care-about-constructors">Why do we care about constructors?</h1>
<p>Of course Haskell has to remember what a list is constructed of.</p>
<p>It also lets <em>us</em> inspect a list, to see which constructors were used.</p>
<p>How do we do this?</p>
<pre class="haskell"><code>import Data.Char

isCapitalized name
  = case name of
      (first:rest) -&gt; isUpper first
      []           -&gt; False
</code></pre>
</div>
<div class="slide">
<h1 id="welcome-to-the-case-expression">Welcome to the case expression</h1>
<p>A <code>case</code> expression allows us to <em>inspect</em> a structure to see how it was constructed.</p>
<pre class="haskell"><code>isCapitalized name
  = case name of
      []           -&gt; False
      (first:rest) -&gt; isUpper first
</code></pre>
<ul>
<li><p>In between <code>case</code> and <code>of</code> is the expression we are inspecting.</p></li>
<li><p>If the constructor used was the empty-list constructor <code>[]</code>, then clearly the <code>name</code> we're inspecting is empty, hence not capitalized.</p></li>
</ul>
<p>If the constructor used was the &quot;add to the front&quot; <code>:</code> operator, then things get more interesting.</p>
<ul>
<li><p>Whatever was the first parameter of the <code>:</code> constructor is bound to the name <code>first</code>.</p></li>
<li><p>The second parameter of the <code>:</code> constructor (i.e. everything in the list after the first element) is bound to the name <code>rest</code>.</p></li>
<li><p>The expression following the <code>-&gt;</code> is evaluated with these values.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="pattern-matching">Pattern matching</h1>
<p>The <code>case</code> expression performs what we call <em>pattern matching</em>.</p>
<ul>
<li><p>Patterns are checked from top to bottom.</p></li>
<li><p>As soon as a match is found, its right hand side (after the <code>-&gt;</code>) is used as the result of the entire <code>case</code> expression.</p></li>
<li><p>If no match succeeds, an exception is thrown.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="a-worked-example">A worked example</h1>
<p>Let's step through the machinery of what happens if we evaluate this expression.</p>
<pre class="haskell"><code>isCapitalized &quot;Ann&quot;
</code></pre>
</div>
<div class="slide">
<h1 id="whew-a-few-exercises">Whew! A few exercises!</h1>
<p>Finally! We can write slightly more complex functions.</p>
<p>Now that you can inspect the front of a list, you should be able to process an <em>entire</em> list recursively.</p>
<p>First, please write a function named <code>myLength</code> that computes the number of elements in a list.</p>
<p>Next, write a function named <code>countCaps</code> that calculates the number of capital letters in a string.</p>
<pre class="haskell"><code>countCaps &quot;Monkey Butter&quot; == 2
</code></pre>
</div>
<div class="slide">
<h1 id="counting-capital-letters">Counting capital letters</h1>
<p>Wow, that countCaps function was a pain, right?</p>
<p>Here's my definition that uses only the machinery we've learned so far:</p>
<pre class="haskell"><code>countCaps string =
  case string of
    []     -&gt; 0
    (x:xs) -&gt; if isUpper x
              then 1 + countCaps xs
              else countCaps xs
</code></pre>
</div>
<div class="slide">
<h1 id="huh.">Huh.</h1>
<p>I thought Haskell was all about concision!?</p>
</div>
<div class="slide">
<h1 id="conciseness-1-top-level-pattern-matching">Conciseness 1: top-level pattern matching</h1>
<pre class="haskell"><code>countCaps []     = 0
countCaps (x:xs) =
    if isUpper x
    then 1 + countCaps xs
    else countCaps xs
</code></pre>
<p>We can define a function as a series of equations, each containing a pattern match.</p>
<p>This is nice syntactic sugar for <code>case</code>.</p>
</div>
<div class="slide">
<h1 id="conciseness-2-guards">Conciseness 2: guards</h1>
<pre class="haskell"><code>countCaps []     = 0
countCaps (x:xs)
   | isUpper x    = 1 + countCaps xs
   | otherwise    = countCaps xs
</code></pre>
<p>After each <code>|</code> is a <em>guard</em>.</p>
<ul>
<li><p>If a pattern matches, we evaluate each Boolean guard expression from top to bottom.</p></li>
<li><p>When one succeeds, we evaluate the RHS as the body of the function.</p></li>
</ul>
<p>(Yes, patterns in a <code>case</code> can have guards too.)</p>
</div>
<div class="slide">
<h1 id="before">Before</h1>
<p>Like the original version, but with use of <code>case</code> stripped out:</p>
<pre class="haskell"><code>countCaps xs =
  if null xs
  then 0 
  else if isUpper (head xs)
       then 1 + countCaps (tail xs)
       else countCaps (tail xs)
</code></pre>
</div>
<div class="slide">
<h1 id="after">After</h1>
<p>Both shorter and easier to follow:</p>
<pre class="haskell"><code>countCaps []     = 0
countCaps (x:xs)
   | isUpper x    = 1 + countCaps xs
   | otherwise    = countCaps xs
</code></pre>
</div>
<div class="slide">
<h1 id="another-approach">Another approach</h1>
<p>Write a new version of <code>countCaps</code> as follows:</p>
<ul>
<li><p>Write a function that goes through a list, and which generates a new list that contains only its capital letters.</p></li>
<li><p>Use <code>length</code> to count the number of elements.</p></li>
</ul>
<p>This should give the same result as your first function. Right?</p>
</div>
<div class="slide">
<h1 id="a-change-of-specification">A change of specification</h1>
<p>Suppose we want to count the number of lowercase letters in a string.</p>
<p>This seems almost the same as our function for counting uppercase letters.</p>
<p>What can we do with this observation?</p>
</div>
<div class="slide">
<h1 id="higher-order-functions">Higher order functions</h1>
<p><em>Higher order function</em>: a function that accepts another function as a parameter.</p>
<pre class="haskell"><code>filter pred [] = []
filter pred (x:xs)
  | pred x     = x : filter pred xs
  | otherwise  =     filter pred xs
</code></pre>
<p>How can we use this to define <code>countLowerCase</code>?</p>
</div>
<div class="slide">
<h1 id="data-in-data-out">Data in, data out</h1>
<p>By now, we've seen several definitions like this:</p>
<pre class="haskell"><code>countLowerCase string =
  length (filter isLower string)
</code></pre>
<p>This is a recurring pattern:</p>
<ul>
<li><p>A function of one argument</p></li>
<li><p>It's being fed the result of ...</p></li>
<li><p>... another function of one argument</p></li>
</ul>
</div>
<div class="slide">
<h1 id="function-composition">Function composition</h1>
<p>Haskell doesn't limit us to giving functions alphanumeric names.</p>
<p>Here, we define a function named simply &quot;<code>.</code>&quot;, which we can use as an operator:</p>
<pre class="haskell"><code>(f . g) x = f (g x)
</code></pre>
<p>How to use this?</p>
<pre class="haskell"><code>countLowerCase = length . filter isLower
</code></pre>
</div>
<div class="slide">
<h1 id="understanding-composition">Understanding composition</h1>
<p>If that seemed hard to follow, let's make it clearer.</p>
<p>We'll plug the arguments into the RHS of our function definition:</p>
<pre class="haskell"><code>(f . g) x = f (g x)
</code></pre>
<p>We had <code>length</code> as the first argument to &quot;<code>.</code>&quot;, and <code>filter isLower</code> as the second:</p>
<pre class="haskell"><code>(length . filter isLower) x 
  = length (filter isLower x)
</code></pre>
</div>
<div class="slide">
<h1 id="local-variables">Local variables</h1>
<p>Inside an expression, we can introduce new variables using <code>let</code>.</p>
<pre class="haskell"><code>let x = 2
    y = 4
in x + y
</code></pre>
<ul>
<li><p>Local definitions come after the <code>let</code>.</p></li>
<li><p>The expression where we use them comes after the <code>in</code>.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="white-space">White space</h1>
<p>Haskell is sensitive to white space!</p>
<ul>
<li><p>A top-level definition starts in the leftmost column.</p></li>
<li><p>After the beginning of a definition, if the next non-empty line is indented further, it is treated as a continuation of that definition.</p></li>
<li><p>Never use tabs in your source files.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="white-space-and-local-variables">White space and local variables</h1>
<p>If you're defining local variables, they must start in the same column.</p>
<p>This is good:</p>
<pre class="haskell"><code>let x = 2
    y = 4
in x + y
</code></pre>
<p>But this will lead to a compiler error:</p>
<pre class="haskell"><code>let x = 2
      y = 4
in x + y
</code></pre>
</div>
<div class="slide">
<h1 id="composition-exercise">Composition exercise</h1>
<p>Using function composition wherever you can, write a function that accepts a string and returns a new string containing only the words that begin with vowels.</p>
<ul>
<li>You'll want to play with the <code>words</code> and <code>unwords</code> functions before you start.</li>
</ul>
<p>Example:</p>
<pre class="haskell"><code>disemvowel &quot;I think, therefore I am.&quot;
  == &quot;I I am.&quot;
</code></pre>
</div>
<div class="slide">
<h1 id="my-solution">My solution</h1>
<p>Here's how I wrote <code>disemvowel</code>:</p>
<pre class="haskell"><code>disemvowel = 
  let isVowel c = toLower c `elem` &quot;aeiou&quot;
  in  unwords . filter (isVowel . head) . words
</code></pre>
<p>Does this remind you of a Unix shell pipeline, only right-to-left?</p>
</div>
<div class="slide">
<h1 id="problem-definition-once-again">Problem definition, once again</h1>
<p>Given a web site, we want to scrape it and find important web pages.</p>
<p>We're now Haskell experts, right?</p>
<ul>
<li>Download one web page</li>
</ul>
</div>
<div class="slide">
<h1 id="lets-download-a-web-page">Let's download a web page!</h1>
<p>We'd really like to rely on a library to download a web page for us.</p>
<p>At times like this, there's a very handy central repository of open source Haskell software:</p>
<ul>
<li><p><a href="http://hackage.haskell.org/">http://hackage.haskell.org</a></p></li>
<li><p>(Everyone just calls it &quot;Hackage&quot;)</p></li>
</ul>
<p>Go there now!</p>
<p>Click on the <a href="http://hackage.haskell.org/packages/archive/pkg-list.html">Packages</a> link at the top of the page to browse packages.</p>
<p>Alas, the list is overwhelmingly long, but we can find libraries for all kinds of tasks if we're patient.</p>
<p>Are we patient?</p>
</div>
<div class="slide">
<h1 id="ugh">Ugh!</h1>
<p>Scrolling through thousands of libraries is hard - surely there's a better way?</p>
<p>Enter the <code>cabal</code> command!</p>
<p>Run this command in a terminal window:</p>
<pre><code>cabal update
</code></pre>
<p>This downloads the latest index of all software on Hackage.</p>
<p>With the index updated, we can search it:</p>
<pre><code>cabal list http
</code></pre>
<p>That still gives us 20+ packages to comb through, but at least it's better than the 3,400 on the Packages web page.</p>
</div>
<div class="slide">
<h1 id="short-cutting-the-search">Short-cutting the search</h1>
<p>The best HTTP client library is named <code>http-enumerator</code>.</p>
<p>We can read about it online:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/http-enumerator">hackage.haskell.org/package/http-enumerator</a></li>
</ul>
<p>That landing page for a package is intimidating, but look towards the bottom, at the section labeled &quot;Modules&quot;.</p>
<p>What do you see?</p>
</div>
<div class="slide">
<h1 id="installing-a-package">Installing a package</h1>
<p>Before we can use <code>http-enumerator</code>, we must install it.</p>
<p>To install the <code>http-enumerator</code> package, we just issue a single command:</p>
<pre><code>cabal install http-enumerator
</code></pre>
<p>This command figures out all the other libraries that <code>http-enumerator</code> depends on, and downloads, compiles, and installs the whole lot.</p>
<p>Expect it to take a few minutes and print a lot of output.</p>
</div>
<div class="slide">
<h1 id="reading-docs-packages-and-modules">Reading docs: packages and modules</h1>
<p>While we're waiting for the <code>http-enumerator</code> package and all of its dependencies to install, let's try to figure out how we should use it.</p>
<p>Remember the link to API documentation at the end of the package's web page? Click through to the API docs.</p>
<p>An API page begins with a title that looks something like this:</p>
<pre><code>Network.HTTP.Enumerator
</code></pre>
<p>This is the name of a <em>module</em>.</p>
<p>A module is a collection of related code.</p>
<p>A <em>package</em> is a collection of related modules.</p>
<p>(This will sound familiar if you know Python.)</p>
</div>
<div class="slide">
<h1 id="reading-docs-the-rest">Reading docs: the rest</h1>
<p>After the initial blurb, a module's docs consists of type signatures and descriptions.</p>
<p>Here is a really simple type signature:</p>
<pre><code>foo :: String
</code></pre>
<p>How the heck do we read this?</p>
<p>The <em>name</em> of the thing being defined comes before the <code>::</code> characters.</p>
<p>Its <em>type</em> follows after the <code>::</code>.</p>
<p>This means &quot;the value named <code>foo</code> has the type <code>String</code>&quot;.</p>
</div>
<div class="slide">
<h1 id="haskells-type-system">Haskell's type system</h1>
<p>Up until now, we have not bothered talking about types or type signatures.</p>
<p>Every expression and value in Haskell has a single type.</p>
<p>Those types can almost always be <em>inferred</em> automatically by the compiler or interpreter.</p>
</div>
<div class="slide">
<h1 id="the-most-common-basic-types">The most common basic types</h1>
<ul>
<li><p><code>Bool</code></p></li>
<li><p><code>Int</code></p></li>
<li><p><code>Char</code></p></li>
<li><p><code>Double</code></p></li>
</ul>
</div>
<div class="slide">
<h1 id="a-function-signature">A function signature</h1>
<p>Here's another type signature:</p>
<pre><code>words :: String -&gt; [String]
</code></pre>
<p>Here we see a new symbol, <code>-&gt;</code>, which means &quot;this is a function&quot;.</p>
<p>The type after the last <code>-&gt;</code> is the return type of the function.</p>
<p>All of its predecessors are argument types.</p>
<p>So this is a function that takes one <code>String</code> argument, and returns... what?</p>
</div>
<div class="slide">
<h1 id="list-notation">List notation</h1>
<p>The notation <code>[a]</code> means &quot;a list of values, all of some type <code>a</code>&quot;.</p>
<p>So <code>[String]</code> means &quot;a list of values, all of type <code>String</code>&quot;.</p>
</div>
<div class="slide">
<h1 id="type-synonyms">Type synonyms</h1>
<p>What's a <code>String</code>?</p>
<ul>
<li>It's not special, just a <em>synonym</em> for <code>[Char]</code>, i.e. &quot;a list of <code>Char</code>&quot;.</li>
</ul>
<p>We can introduce new synonyms of our own.</p>
<pre class="haskell"><code>type Dollars = Int
</code></pre>
<p>A type synonym can be handy for documenting an intended use for an existing type.</p>
</div>
<div class="slide">
<h1 id="words">Words</h1>
<pre><code>words :: String -&gt; [String]
</code></pre>
<p>We can now read that this function accepts a string as argument, and returns a list of strings.</p>
<p>From reading its name and type signature, can you guess what <code>words</code> might do?</p>
</div>
<div class="slide">
<h1 id="another-signature">Another signature</h1>
<p>Tell me about this signature:</p>
<pre><code>mystery :: [String] -&gt; String
</code></pre>
<p>What are some reasonable possible behaviours for this function?</p>
</div>
<div class="slide">
<h1 id="reading-real-world-docs">Reading real-world docs</h1>
<p>Here is the very first signature from <code>http-enumerator</code>:</p>
<pre><code>simpleHttp 
  :: (MonadIO m, Failure HttpException m) =&gt; 
     String -&gt; m ByteString
</code></pre>
<p>This is more complex! How the heck do we read it?</p>
<p>The bits between <code>::</code> and '=&gt;' are <em>constraints</em> on where we can use <code>simpleHttp</code> - but let's ignore constraints for now.</p>
<ul>
<li><em>Important</em>: it's often safe to gloss over things we don't (yet) understand.</li>
</ul>
<p>We'll also ignore that mysterious lowercase <code>m</code> for a bit.</p>
<p>What can we tell about this function?</p>
</div>
<div class="slide">
<h1 id="bytestring">ByteString</h1>
<p>A <code>ByteString</code> is a blob of binary data.</p>
<p>Unlike <code>String</code>, it is not represented as a list, but as a packed array.</p>
<p>However, it contains binary <em>bytes</em>, not text!</p>
<ul>
<li>Don't use <code>ByteString</code> for working with data that you have to manipulate as text.</li>
</ul>
</div>
<div class="slide">
<h1 id="lets-play-in-ghci">Let's play in ghci!</h1>
<p>Does everyone have <code>http-enumerator</code> installed now?</p>
<p>Fire up <code>ghci</code>, and let's play with the module:</p>
<pre><code>import Network.HTTP.Enumerator
</code></pre>
<p>Notice that after we type this, the prompt changes:</p>
<pre><code>Prelude Network.HTTP.Enumerator&gt;
</code></pre>
<p>This tells us that the module has loaded and is available.</p>
</div>
<div class="slide">
<h1 id="wait-are-you-on-windows">Wait! Are you on Windows?</h1>
<p>On Windows, we have to set up Winsock before any networking will work.</p>
<p>First, let's load the lowest-level networking module:</p>
<pre><code>import Network.Socket
</code></pre>
<p>And here's how we initialize Winsock:</p>
<pre><code>withSocketsDo (return ())
</code></pre>
<p>(It's harmless to do this on Unix.)</p>
</div>
<div class="slide">
<h1 id="with-that-out-of-the-way-...">With that out of the way ...</h1>
<p>Finally - let's load a web page!</p>
<pre><code>simpleHttp &quot;http://example.com/&quot;
</code></pre>
<p>Did that just print a ton of HTML in the terminal window? All right!</p>
</div>
<div class="slide">
<h1 id="from-binary-to-text">From binary to text</h1>
<p>Now we have a <code>ByteString</code>, which we need to turn into text for manipulating.</p>
<p>Let's cheat, and assume that all web pages are encoded in UTF-8.</p>
</div>
<div class="slide">
<h1 id="pure-code">Pure code</h1>
<p>So far, all of the code we have written has been &quot;pure&quot;.</p>
<ul>
<li><p>The behaviour of all of our functions has depended only on their inputs.</p></li>
<li><p>All of our data is immutable.</p></li>
<li><p>There's thus no way to change a global variable and modify the behaviour of a function.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="impure-code">Impure code</h1>
<p>And yet ... somehow we downloaded a web page!</p>
<ul>
<li>Web pages clearly are <em>not</em> pure.</li>
</ul>
<p>So can we write code like this?</p>
<pre class="haskell"><code>length (simpleHttp &quot;http://x.org/&quot;)
</code></pre>
<p>NO.</p>
<p>The type system segregates code that must be pure from code that may have side effects (&quot;impure&quot; code).</p>
</div>
<div class="slide">
<h1 id="are-we-stuck">Are we stuck?</h1>
<p>Well, let's look at a simpler example than <code>simpleHttp</code>.</p>
<p>Type this in <code>ghci</code>:</p>
<pre><code>:type readFile
</code></pre>
<p>This will tell us what the type of <code>readFile</code> is.</p>
</div>
<div class="slide">
<h1 id="io">IO</h1>
<p>The <code>:type</code> directive should print something like this:</p>
<pre class="haskell"><code>readFile :: FilePath -&gt; IO String
</code></pre>
<p>Notice that <code>IO</code> on the result type?</p>
<p>It means &quot;this function may have side effects&quot;.</p>
<p>We often refer to impure functions, with <code>IO</code> in the result type, as <em>actions</em>.</p>
<ul>
<li>This helps to distinguish them from pure functions.</li>
</ul>
</div>
<div class="slide">
<h1 id="mixing-io-and-other-stuff">Mixing IO and other stuff</h1>
<p>The type system keeps track of which functions have <code>IO</code> in their types, and keeps us honest.</p>
<p>We can still mix pure and impure code in a natural way:</p>
<pre class="haskell"><code>charCount fileName = do
  contents &lt;- readFile fileName
  return (length contents)
</code></pre>
</div>
<div class="slide">
<h1 id="do-notation">&quot;do&quot; notation</h1>
<p>Critical to what we just saw was the <code>do</code> keyword at the beginning of the function definition.</p>
<p>This introduces a series of <code>IO</code> actions, one per line.</p>
</div>
<div class="slide">
<h1 id="capturing-the-results-of-impure-code">Capturing the results of impure code</h1>
<p>To capture the result of an <code>IO</code> action, we use <code>&lt;-</code> instead of <code>=</code>.</p>
<pre class="haskell"><code>contents &lt;- readFile fileName
</code></pre>
<p>The result (<code>contents</code>) is pure - it <em>does not have</em> the <code>IO</code> type.</p>
<p>This is how we supply pure code with data returned from impure code.</p>
</div>
<div class="slide">
<h1 id="the-return-action">The &quot;return&quot; action</h1>
<p>This is <em>not</em> the <code>return</code> type you're used to!</p>
<p>It takes a <em>pure</em> value (without <code>IO</code> in its type), and <em>wraps</em> it with the <code>IO</code> type.</p>
<p>Pure code can't call impure code, but it can thread data back into the impure world using <code>return</code>.</p>
</div>
<div class="slide">
<h1 id="haskell-programs-and-io">Haskell programs and IO</h1>
<p>When you write a Haskell program, its entry point must be named <code>main</code>.</p>
<p>The type of <code>main</code> must be:</p>
<pre class="haskell"><code>main :: IO ()
</code></pre>
<p><code>()</code> is named &quot;unit&quot;, and means more or less the same thing as <code>void</code> in C or Java.</p>
<p>What this means is that <em>all</em> Haskell programs are impure!</p>
</div>
<div class="slide">
<h1 id="binary-to-text">Binary to text</h1>
<p>Remember we were planning to cheat earlier?</p>
<p>We had this:</p>
<pre class="haskell"><code>simpleHttp :: String -&gt; IO ByteString
</code></pre>
<p>We need something whose result is an <code>IO String</code> instead.</p>
<p>How should that look?</p>
</div>
<div class="slide">
<h1 id="utf-8-conversion">UTF-8 conversion</h1>
<p>To do the conversion, let's grab a package named <code>utf8-string</code>.</p>
<pre><code>cabal install utf8-string
</code></pre>
<p>That contains a package named <code>Data.ByteString.Lazy.UTF8</code>.</p>
<pre class="haskell"><code>import Data.ByteString.Lazy.UTF8
</code></pre>
<p>It defines a function named <code>toString</code>:</p>
<pre class="haskell"><code>toString :: ByteString -&gt; String
</code></pre>
</div>
<div class="slide">
<h1 id="utf-8-conversion-exercise">UTF-8 conversion exercise</h1>
<p>Write an action that downloads a URL and converts it from a <code>ByteString</code> to a <code>String</code> using <code>toString</code>.</p>
<p>Write a type signature for the action.</p>
<ul>
<li><p>Haskell definitions usually don't require type signatures.</p></li>
<li><p>Nevertheless, we write them for <em>documentation</em> on almost all top-level definitions.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="downloading-and-saving-a-web-page">Downloading and saving a web page</h1>
<p>Use your <code>download</code> function to save a local copy of the page you just wrote.</p>
<pre class="haskell"><code>saveAs :: String -&gt; Int -&gt; IO ()
</code></pre>
<p>For simplicity, let's save the local files as names containing numbers:</p>
<pre class="haskell"><code>makeFileName :: Int -&gt; FilePath
makeFileName k = &quot;download-&quot; ++ show k ++ &quot;.html&quot;
</code></pre>
<p>To save a local copy of a file, you'll need the <code>writeFile</code> action.</p>
</div>
<div class="slide">
<h1 id="shoveling-through-html">Shoveling through HTML</h1>
<p>Two truisms:</p>
<ul>
<li><p>Most HTML in the wild is a mess.</p></li>
<li><p>Even parsing well formed HTML is complicated.</p></li>
</ul>
<p>So! Let's use another library.</p>
<pre><code>cabal install tagsoup
</code></pre>
<p>The <code>tagsoup</code> package can parse arbitrarily messy HTML.</p>
<p>It will feed us a list of events, like a SAX parser.</p>
</div>
<div class="slide">
<h1 id="dealing-with-problems">Dealing with problems</h1>
<p>Try this:</p>
<pre class="haskell"><code>head [1]
</code></pre>
<p>Now try this:</p>
<pre class="haskell"><code>head []
</code></pre>
</div>
<div class="slide">
<h1 id="oops">Oops</h1>
<p>If we pass an empty list, the <code>head</code> function throws an exception.</p>
<p>Suppose we need a version of <code>head</code> that will <em>not</em> throw an exception.</p>
<pre class="haskell"><code>safeHead :: [a] -&gt; ????
</code></pre>
<p>What should the <code>????</code> be?</p>
<p>Let's invent something.</p>
<pre class="haskell"><code>safeHead (x:xs) = Some x
safeHead []     = None
</code></pre>
</div>
<div class="slide">
<h1 id="some-none">Some? None?</h1>
<ul>
<li><p>We're using a constructor named <code>Some</code> to capture the idea &quot;we have a result&quot;.</p></li>
<li><p>The constructor <code>None</code> indicates &quot;we don't have a result here&quot;.</p></li>
</ul>
<p>To bring these constructors into existence, we need to declare a new type.</p>
<pre class="haskell"><code>data Perhaps a = Some a
               | None
</code></pre>
<p>The <code>|</code> character separates the constructors. We can read it as:</p>
<ul>
<li><p>The <code>Perhaps</code> type has two constructors:</p></li>
<li><p><code>Some</code> followed by a single argument</p></li>
<li><p>or <code>None</code> with no arguments</p></li>
</ul>
</div>
<div class="slide">
<h1 id="maybe">Maybe</h1>
<p>Actually, Haskell already has a <code>Perhaps</code> type.</p>
<pre class="haskell"><code>data Maybe a = Just a
             | Nothing
</code></pre>
<p>The <code>a</code> is a <em>type parameter</em>, meaning that when we write this type, we have to supply another type as a parameter:</p>
<ul>
<li><p><code>Maybe Int</code></p></li>
<li><p><code>Maybe String</code></p></li>
</ul>
</div>
<div class="slide">
<h1 id="using-constructors">Using constructors</h1>
<p>If we want to construct a <code>Maybe Int</code> using the <code>Just</code> constructor, we must pass it an <code>Int</code>.</p>
<pre class="haskell"><code>Just 1  :: Maybe Int
Nothing :: Maybe Int
</code></pre>
<p>This will not work, because the types don't match:</p>
<pre class="haskell"><code>Just [1] :: Maybe String
</code></pre>
</div>
<div class="slide">
<h1 id="pattern-matching-over-constructors">Pattern matching over constructors</h1>
<p>We can pattern match over the constructors for <code>Maybe</code> just as we did for lists.</p>
<pre class="haskell"><code>case foo of
  Just x  -&gt; x
  Nothing -&gt; bar
</code></pre>
</div>
<div class="slide">
<h1 id="tags">Tags</h1>
<p>The <code>tagsoup</code> package defines the following type:</p>
<pre class="haskell"><code>data Tag = TagOpen String [Attribute]
         | TagClose String
         | TagText String
         | TagComment String
         | TagWarning String
         | TagPosition Row Column
</code></pre>
<p>What do you think the constructors mean?</p>
</div>
<div class="slide">
<h1 id="pattern-matching-on-a-tag">Pattern matching on a Tag</h1>
<p>Suppose we want to write a predicate that will tell is if a <code>Tag</code> is an opening tag.</p>
<ul>
<li><p>What should the type of this function be?</p></li>
<li><p>What should its body look like?</p></li>
</ul>
</div>
<div class="slide">
<h1 id="dont-care">Don't care!</h1>
<p>Our first body looked like this:</p>
<pre class="haskell"><code>isOpenTag (TagOpen x y)     = True
isOpenTag (TagClose x)      = False
isOpenTag (TagText x)       = False
isOpenTag (TagComment x)    = False
isOpenTag (TagWarning x)    = False
isOpenTag (TagPosition x y) = False
</code></pre>
<p>Concise, but ugly.</p>
<ul>
<li><p>We really only care about one constructor.</p></li>
<li><p>We never use the variables <code>x</code> or <code>y</code> that we declare.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="the-wild-card-pattern">The wild card pattern</h1>
<p>We can write &quot;I don't care what this pattern or variable is&quot; using the &quot;<code>_</code>&quot; character.</p>
<pre class="haskell"><code>isOpenTag (TagOpen _ _) = True
isOpenTag  _            = False
</code></pre>
<p>The wild card pattern always matches.</p>
<ul>
<li><p>Since we don't care about <code>x</code> or <code>y</code>, we can state that explicitly using <code>_</code>.</p></li>
<li><p>Since we don't care about any constructor except <code>TagOpen</code>, we can match all the others using <code>_</code>.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="just-a-quick-question">Just a quick question</h1>
<p>Why don't we write the function like this?</p>
<pre class="haskell"><code>isOpenTag  _            = False
isOpenTag (TagOpen _ _) = True
</code></pre>
</div>
<div class="slide">
<h1 id="extracting-links-from-a-web-page">Extracting links from a web page</h1>
<p>Suppose we have a page in memory already.</p>
<ul>
<li><p>Browse the <code>tagsoup</code> docs, in the <code>Text.HTML.TagSoup</code> module.</p></li>
<li><p>Find a function that will parse a web page into a series of tags.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="lets-use-it">Let's use it!</h1>
<pre class="haskell"><code>processPage url = do
  page &lt;- download url
  return (parseTags page)
</code></pre>
</div>
<div class="slide">
<h1 id="tidying-tags-up">Tidying tags up</h1>
<p>Parsed tags can contain a mixture of tag names.</p>
<pre><code>&lt;A HREF=&quot;...&quot;&gt;
</code></pre>
<pre><code>&lt;a hrEF=&quot;...&quot;&gt;
</code></pre>
<ul>
<li>Find a <code>tagsoup</code> function that will turn tag names and attributes to lower case.</li>
</ul>
</div>
<div class="slide">
<h1 id="canonical-tags">Canonical tags</h1>
<p>Let's use our function to clean up the result of <code>parseTags</code>.</p>
<pre class="haskell"><code>processPage url = do
  page &lt;- download url
  return
    (canonicalizeTags
      (parseTags page))
</code></pre>
</div>
<div class="slide">
<h1 id="extracting-links">Extracting links</h1>
<p>We only care about open tags that are links, so <code>&lt;a&gt;</code> tags.</p>
<ul>
<li><p>How would we write the type of a function that will indicate whether a <code>Tag</code> is an open tag with the correct name?</p></li>
<li><p>How would we use this function to extract only the open tags from a list of parsed tags?</p></li>
</ul>
</div>
<div class="slide">
<h1 id="whee">Whee!</h1>
<p>This cascade is getting a bit ridiculous.</p>
<pre class="haskell"><code>processPage url = do
  page &lt;- download url
  return
    (filter (isTagOpenName &quot;a&quot;)
      (canonicalizeTags
        (parseTags page)))
</code></pre>
<p>Two observations:</p>
<ul>
<li><p>Our action is now mostly pure code.</p></li>
<li><p>It sure looks like a pipeline.</p></li>
</ul>
</div>
<div class="slide">
<h1 id="a-rewriting-exercise">A rewriting exercise</h1>
<p>Take this function and split it into pure and impure parts.</p>
<p>Write the pure part using function composition.</p>
<pre class="haskell"><code>processPage url = do
  page &lt;- download url
  return
    (filter (isTagOpenName &quot;a&quot;)
      (canonicalizeTags
        (parseTags page)))
</code></pre>
</div>
<div class="slide">
<h1 id="my-solution-1">My solution</h1>
<pre class="haskell"><code>processPage url = do
  page &lt;- download url
  return (process page)

process =
    filter (isTagOpenName &quot;a&quot;) .
    canonicalizeTags .
    parseTags
</code></pre>
</div>
<div class="slide">
<h1 id="more-stuff-to-filter-out">More stuff to filter out</h1>
<p>Let's skip <code>nofollow</code> links.</p>
<p>We want to get the <code>&quot;rel&quot;</code> attribute of a tag.</p>
<ul>
<li>Find a function that extracts an attribute from a tag.</li>
</ul>
</div>
<div class="slide">
<h1 id="no-following">No following</h1>
<pre class="haskell"><code>nofollow tag = fromAttrib &quot;rel&quot; tag == &quot;nofollow&quot;
</code></pre>
<pre class="haskell"><code>process =
    filter (not . nofollow) .
    filter (isTagOpenName &quot;a&quot;) .
    canonicalizeTags .
    parseTags
</code></pre>
</div>
<div class="slide">
<h1 id="we-have-a-list-of-a-tags">We have a list of &lt;a&gt; tags</h1>
<p>How would we extract the <code>&quot;href&quot;</code> attribute from every element of the list?</p>
</div>
<div class="slide">
<h1 id="only-non-empty-a-href-tags">Only non-empty &lt;a href&gt; tags</h1>
<pre class="haskell"><code>process =
    filter (not . null) .
    map (fromAttrib &quot;href&quot;) .
    filter (not . nofollow) .
    filter (isTagOpenName &quot;a&quot;) .
    canonicalizeTags .
    parseTags
</code></pre>
</div>
<div class="slide">
<h1 id="canonical-urls">Canonical URLs</h1>
<p>Links can be absolute, relative, or invalid garbage, and we only want valid-looking absolute links.</p>
<p>To properly create an absolute link, we need to know the absolute URL of the page we're looking at.</p>
<pre class="haskell"><code>canonicalizeLink :: String -&gt; String -&gt; Maybe String
</code></pre>
</div>
<div class="slide">
<h1 id="working-with-uris">Working with URIs</h1>
<p>The <code>Network.URI</code> package contains some functions we might find handy.</p>
<pre class="haskell"><code>parseURI :: String -&gt; Maybe URI
parseURIReference :: String -&gt; Maybe URI
uriToString id &quot;&quot; :: URI -&gt; String
nonStrictRelativeTo :: URI -&gt; URI -&gt; Maybe URI
</code></pre>
</div>
<div class="slide">
<h1 id="a-monster-of-indentation">A monster of indentation</h1>
<p>This is really hard to read!</p>
<pre class="haskell"><code>import Network.URI

canon :: String -&gt; String -&gt; Maybe String
canon referer path =
  case parseURI referer of
    Nothing -&gt; Nothing
    Just r  -&gt;
      case parseURIReference path of
        Nothing -&gt; Nothing
        Just p  -&gt;
          case nonStrictRelativeTo p r of
            Nothing -&gt; Nothing
            Just u -&gt;
             Just (uriToString id u &quot;&quot;)
</code></pre>
<p>Surely there's a better way.</p>
</div>
<div class="slide">
<h1 id="stair-stepping">Stair stepping</h1>
<p>Notice that that function was a series of <code>case</code> inspections of <code>Maybe</code> values?</p>
<p>Suppose we had a function that accepted a normal value, and returned a <code>Maybe</code> value.</p>
<pre class="haskell"><code>a -&gt; Maybe b
</code></pre>
<p>And suppose we had a concise syntax for writing an anonymous function.</p>
<pre class="haskell"><code>\a -&gt; &quot;hi mom! &quot; ++ a
</code></pre>
<p>The <code>\</code> is pronounced &quot;lambda&quot;.</p>
</div>
<div class="slide">
<h1 id="observation">Observation</h1>
<p>The <code>case</code> analysis is quite verbose. Suppose we had a function that performed it, and called another function if our value was <code>Just</code>.</p>
<pre class="haskell"><code>bind :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b
bind  Nothing      _     = Nothing
bind (Just value) action = action value
</code></pre>
</div>
<div class="slide">
<h1 id="using-bind">Using bind</h1>
<p>How could we use this?</p>
<pre class="haskell"><code>canon1 referer path =
  parseURI referer                `bind`
   \r -&gt; parseURIReference path   `bind`
    \p -&gt; nonStrictRelativeTo p r `bind`
     \u -&gt; Just (uriToString id u &quot;&quot;)
</code></pre>
<p>If we enclose a function name in backticks, we can use the function as an infix operator.</p>
</div>
<div class="slide">
<h1 id="reformatting-the-code">Reformatting the code</h1>
<pre class="haskell"><code>canon referer path =
  parseURI referer         `bind` \r -&gt;
  parseURIReference path   `bind` \p -&gt;
  nonStrictRelativeTo p r  `bind` \u -&gt;
  Just (uriToString id u &quot;&quot;)
</code></pre>
</div>
<div class="slide">
<h1 id="a-built-in-name-for-bind">A built-in name for bind</h1>
<p>The <code>&gt;&gt;=</code> operator is a more general version of our <code>bind</code> function.</p>
<pre class="haskell"><code>canon referer path =
  parseURI referer &gt;&gt;= \r -&gt;
  parseURIReference path &gt;&gt;= \p -&gt;
  nonStrictRelativeTo p r &gt;&gt;= \u -&gt;
  Just (uriToString id u &quot;&quot;)
</code></pre>
</div>
<div class="slide">
<h1 id="using-syntactic-sugar">Using syntactic sugar</h1>
<p>Here's some tidier syntax that should look familiar.</p>
<pre class="haskell"><code>canonicalize :: String -&gt; String -&gt; Maybe String

canonicalize referer path = do
  r &lt;- parseURI referer
  p &lt;- parseURIReference path
  u &lt;- nonStrictRelativeTo p r
  return (uriToString id u &quot;&quot;)
</code></pre>
</div>
<div class="slide">
<h1 id="nearly-there">Nearly there</h1>
<pre class="haskell"><code>process url =
   map (canonicalize url) .
   filter (not . null) .
   map (fromAttrib &quot;href&quot;) .
   filter (\t -&gt; fromAttrib &quot;rel&quot; t /= &quot;nofollow&quot;) .
   filter (isTagOpenName &quot;a&quot;) .
   canonicalizeTags .
   parseTags
</code></pre>
<p>One awkward thing: what is the type of this function?</p>
</div>
<div class="slide">
<h1 id="from-maybe-a-to-a">From [Maybe a] to [a]</h1>
<p>Go to this web site:</p>
<ul>
<li><a href="http://haskell.org/hoogle">haskell.org/hoogle</a></li>
</ul>
<p>Type this into the search box:</p>
<pre class="haskell"><code>[Maybe a] -&gt; [a]
</code></pre>
<p>What does the first result say?</p>
</div>
<div class="slide">
<h1 id="were-there">We're there!</h1>
<pre class="haskell"><code>import Data.Maybe
import Network.URI

links url =
  catMaybes .
  map (canonicalize url) .
  filter (not . null) .
  map (fromAttrib &quot;href&quot;) .
  filter (\t -&gt; fromAttrib &quot;rel&quot; t /= &quot;nofollow&quot;) .
  filter (isTagOpenName &quot;a&quot;) .
  canonicalizeTags .
  parseTags
</code></pre>
</div>
<div class="slide">
<h1 id="from-links-to-spidering">From links to spidering</h1>
<p>If we can download the links from one page, we can easily write a spider to follow those links.</p>
<p>To keep things simple, let's set a limit on the number of pages we'll download.</p>
<p>What information do we want to generate?</p>
<p>What do we need to track along the way?</p>
</div>
<div class="slide">
<h1 id="what-we-need-to-track">What we need to track</h1>
<p>Here's the state we need to maintain:</p>
<ul>
<li><p>The number of pages we have downloaded</p></li>
<li><p>A collection of pages we have seen links to, but haven't downloaded</p></li>
<li><p>A collection of pages and their outbound links</p></li>
</ul>
</div>
<div class="slide">
<h1 id="tracking-what-weve-seen">Tracking what we've seen</h1>
<p>For any given page, we need to remember both it and all the pages it links to.</p>
<p>One possibility for associating the two is a <em>tuple</em>:</p>
<pre class="haskell"><code>(&quot;http://x.org/&quot;, [&quot;http://microsoft.com/&quot;])
</code></pre>
<p>Tuples are useful any time we want mixed-type data without the hassle of creating a new type.</p>
<p>Speaking of a new type, here's how we'd define one:</p>
<pre class="haskell"><code>data Link = Link String [String]

-- Let's define some accessors, too.
linkFrom (Link url _) = url
linkTo (Link _ links) = links
</code></pre>
</div>
<div class="slide">
<h1 id="avoiding-duplication">Avoiding duplication</h1>
<p>We don't want to visit any URL twice.</p>
<p>How do we avoid this?</p>
<pre class="haskell"><code>visited url = elem url . map linkTo
</code></pre>
<p>This function has a problem - what is that problem?</p>
</div>
<div class="slide">
<h1 id="better-performance">Better performance</h1>
<p>We really want a structure with a fast lookup operation.</p>
<p>What would you use in your language?</p>
</div>
<div class="slide">
<h1 id="maps-and-importing">Maps and importing</h1>
<p>In Haskell, we have mutable hash tables, but we don't use them.</p>
<p>Instead, we use <em>immutable</em> key-value maps.</p>
<p>We must perform fancy module importing tricks because the <code>Data.Map</code> module defines a lot of names that would otherwise overlap with built-in names.</p>
<p>This means &quot;only import the name <code>Map</code> from <code>Data.Map</code>&quot;:</p>
<pre class="haskell"><code>import Data.Map (Map)
</code></pre>
<p>And this means &quot;import everything from <code>Data.Map</code>, but all those names must be prefixed with <code>Map.</code>&quot;:</p>
<pre class="haskell"><code>import qualified Data.Map as Map
</code></pre>
</div>
<div class="slide">
<h1 id="what-use-is-an-immutable-data-structure">What use is an immutable data structure?</h1>
<p>Everyone knows how to add a key and value to a hash table, right?</p>
<p>And that seems like a fundamental operation.</p>
<p>What do we do with maps?</p>
<ul>
<li>Create a <em>new</em> map that is identical to the one we supply, with the requested element added.</li>
</ul>
<p>How can this possibly work? Is it efficient?</p>
</div>
<div class="slide">
<h1 id="a-fistful-of-dollars">A fistful of dollars</h1>
<p>Here's a surprisingly handy built-in operator:</p>
<pre class="haskell"><code>f $ x = f x
</code></pre>
<p>Why is this useful? Because it lets us eliminate parentheses.</p>
<p>Before:</p>
<pre class="haskell"><code>explode k = error (&quot;failed on &quot; ++ show k)
</code></pre>
<p>After:</p>
<pre class="haskell"><code>explode k = error $ &quot;failed on &quot; ++ show k
</code></pre>
</div>
<div class="slide">
<h1 id="partial-application">Partial application</h1>
<p>This is annoying to write:</p>
<pre class="haskell"><code>increment k = 1 + k
</code></pre>
<p>Almost as bad:</p>
<pre class="haskell"><code>\k -&gt; 1 + k
</code></pre>
<p>Much handier, and identical:</p>
<pre class="haskell"><code>(1+)
</code></pre>
<p>In fact, this is valid:</p>
<pre class="haskell"><code>increment = (1+)
</code></pre>
</div>
<div class="slide">
<h1 id="spidering-in-all-its-glory">Spidering, in all its glory</h1>
<pre class="haskell"><code>spider :: Int -&gt; URL -&gt; IO (Map URL [URL])
spider count url0 = go 0 Map.empty (Set.singleton url0)
  where
    go k seen queue0
        | k &gt;= count = return seen
        | otherwise  =
      case Set.minView queue0 of
        Nothing -&gt; return seen
        Just (url, queue) -&gt; do
          page &lt;- download url
          let ls       = links url page
              newSeen  = Map.insert url ls seen
              notSeen  = Set.fromList .
                         filter (`Map.notMember` newSeen) $ ls
              newQueue = queue `Set.union` notSeen
          go (k+1) newSeen newQueue
</code></pre>
</div>
<div class="slide">
<h1 id="where-do-we-stand">Where do we stand?</h1>
<p>We can now:</p>
<ul>
<li><p>Download a web page</p></li>
<li><p>Extract its links</p></li>
<li><p>Spider out from there, without repeat visits</p></li>
</ul>
<p>What remains?</p>
<ul>
<li><p>We could spider multiple pages concurrently</p></li>
<li><p>Or we could compute which pages are &quot;important&quot;</p></li>
</ul>
</div>
<div class="slide">
<h1 id="fin">Fin</h1>
<p>At this point, if we have miraculously not run out of time, we're going on a choose-your-own-adventure session in Emacs.</p>
<p>Thanks for sticking with the slideshow so far!</p>
</div>
</body>
</html>
